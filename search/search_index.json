{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])"},"docs":[{"location":"","text":"Ellar - ASGI Python Framework \u00b6 Ellar - Python ASGI web framework for building fast, efficient and scalable RESTAPIs and server-side application. Introduction \u00b6 Ellar is a lightweight ASGI framework for building efficient and scalable server-side python applications. It supports both OOP (Object-Oriented Programming) and FP (Functional Programming) Ellar is also a higher level of abstraction of Starlette (ASGI toolkit) , a lightweight ASGI framework/toolkit well-suited for developing asynchronous web services in Python. Inspiration \u00b6 Ellar was deeply influenced by NestJS for its ease of use, project structures and patterns that aids in building small or complex project applications. Also, Ellar took some concepts from FastAPI in terms of request parameter handling and data serialization with Pydantic. The objective of Ellar is to provide a high level of abstracted interface to the web, along with a well-structured project setup, give room for object-oriented approach to web application design, allow you chose your desired application architecture, and ultimately, deliver speedy handling to requests. Features Summary \u00b6 Easy to Use : Ellar has a simple and intuitive API that makes it easy to get started with building a fast and scalable web applications or web APIs with Python. Dependency Injection (DI) : It comes with DI system makes it easy to manage dependencies and reduce coupling between components. Pydantic Integration : It is properly integrated with Pydantic, a popular Python library for data validation, to ensure that input data is valid. Templating with Jinja2 : Ellar provides built-in support for Jinja2 templates, making it easy to create dynamic web pages. OpenAPI Documentation : It comes with built-in support for OpenAPI documentation, making it easy to generate Swagger or ReDoc documentation for your API. And more can be added with ease if necessary. Controller (MVC) Architecture : Ellar's controller architecture follows the Model-View-Controller (MVC) pattern, making it easy to organize your code. Guards for Authentication and Authorization : It provides built-in support for guards, allowing you to easily implement authentication and authorization in your application. Modularity : Ellar follows a modular architecture inspired by NestJS, making it easy to organize your code into reusable modules. Asynchronous programming : It allows you to takes advantage of Python's async/await feature to write efficient and fast code that can handle large numbers of concurrent requests Installation \u00b6 To get started, you need to scaffold a project using Ellar-CLI toolkit. This is recommended for a first-time user. The scaffolded project is more like a guide to project setup. $( venv ) pip install ellar After that, lets create a new project. Run the command below and change the project-name with whatever name you decide. $( venv ) ellar new project-name then, start the app with: $( venv ) ellar runserver --reload Open your browser and navigate to http://localhost:8000/ . Dependency Summary \u00b6 Python >= 3.7 Starlette Pydantic Injector Status \u00b6 Project is still in development Documentation - in progress Database Plugin with Encode/ORM","title":"Introduction"},{"location":"#ellar-asgi-python-framework","text":"Ellar - Python ASGI web framework for building fast, efficient and scalable RESTAPIs and server-side application.","title":"Ellar - ASGI Python Framework"},{"location":"#introduction","text":"Ellar is a lightweight ASGI framework for building efficient and scalable server-side python applications. It supports both OOP (Object-Oriented Programming) and FP (Functional Programming) Ellar is also a higher level of abstraction of Starlette (ASGI toolkit) , a lightweight ASGI framework/toolkit well-suited for developing asynchronous web services in Python.","title":"Introduction"},{"location":"#inspiration","text":"Ellar was deeply influenced by NestJS for its ease of use, project structures and patterns that aids in building small or complex project applications. Also, Ellar took some concepts from FastAPI in terms of request parameter handling and data serialization with Pydantic. The objective of Ellar is to provide a high level of abstracted interface to the web, along with a well-structured project setup, give room for object-oriented approach to web application design, allow you chose your desired application architecture, and ultimately, deliver speedy handling to requests.","title":"Inspiration"},{"location":"#features-summary","text":"Easy to Use : Ellar has a simple and intuitive API that makes it easy to get started with building a fast and scalable web applications or web APIs with Python. Dependency Injection (DI) : It comes with DI system makes it easy to manage dependencies and reduce coupling between components. Pydantic Integration : It is properly integrated with Pydantic, a popular Python library for data validation, to ensure that input data is valid. Templating with Jinja2 : Ellar provides built-in support for Jinja2 templates, making it easy to create dynamic web pages. OpenAPI Documentation : It comes with built-in support for OpenAPI documentation, making it easy to generate Swagger or ReDoc documentation for your API. And more can be added with ease if necessary. Controller (MVC) Architecture : Ellar's controller architecture follows the Model-View-Controller (MVC) pattern, making it easy to organize your code. Guards for Authentication and Authorization : It provides built-in support for guards, allowing you to easily implement authentication and authorization in your application. Modularity : Ellar follows a modular architecture inspired by NestJS, making it easy to organize your code into reusable modules. Asynchronous programming : It allows you to takes advantage of Python's async/await feature to write efficient and fast code that can handle large numbers of concurrent requests","title":"Features Summary"},{"location":"#installation","text":"To get started, you need to scaffold a project using Ellar-CLI toolkit. This is recommended for a first-time user. The scaffolded project is more like a guide to project setup. $( venv ) pip install ellar After that, lets create a new project. Run the command below and change the project-name with whatever name you decide. $( venv ) ellar new project-name then, start the app with: $( venv ) ellar runserver --reload Open your browser and navigate to http://localhost:8000/ .","title":"Installation"},{"location":"#dependency-summary","text":"Python >= 3.7 Starlette Pydantic Injector","title":"Dependency Summary"},{"location":"#status","text":"Project is still in development Documentation - in progress Database Plugin with Encode/ORM","title":"Status"},{"location":"contribution/","text":"Coming Soon \u00b6","title":"Contribution"},{"location":"contribution/#coming-soon","text":"","title":"Coming Soon"},{"location":"custom-setup/","text":"Installation \u00b6 pip install ellar Usage \u00b6 Create a file controller.py : from ellar.common import ModuleRouter , Controller , get router = ModuleRouter ( '' , tag = 'Math' ) @router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @Controller ( \"\" , tag = 'Math' ) class MathAPI : @get ( '/subtract' , ) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @get ( '/divide' , ) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @get ( '/multiple' , ) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } Create another file server.py : from ellar.core import AppFactory from ellar.openapi import OpenAPIDocumentBuilder , OpenAPIDocumentModule from .controller import router , MathAPI app = AppFactory . create_app ( routers = ( router , ), controllers = ( MathAPI , )) document_builder = OpenAPIDocumentBuilder () document_builder . set_title ( 'Your Title' ) \\ . set_version ( '1.0.2' ) \\ . set_contact ( name = 'Eadwin' , url = 'https://www.yahoo.com' , email = 'eadwin@gmail.com' ) \\ . set_license ( 'MIT Licence' , url = 'https://www.google.com' ) document = document_builder . build_document ( app ) module = app . install_module ( OpenAPIDocumentModule , document = document ) module . setup_swagger_doc () Start up Server \u00b6 uvicorn server:app --reload Interactive API docs \u00b6 Now go to http://localhost:8000/docs/ You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Custom setup"},{"location":"custom-setup/#installation","text":"pip install ellar","title":"Installation"},{"location":"custom-setup/#usage","text":"Create a file controller.py : from ellar.common import ModuleRouter , Controller , get router = ModuleRouter ( '' , tag = 'Math' ) @router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @Controller ( \"\" , tag = 'Math' ) class MathAPI : @get ( '/subtract' , ) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @get ( '/divide' , ) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @get ( '/multiple' , ) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } Create another file server.py : from ellar.core import AppFactory from ellar.openapi import OpenAPIDocumentBuilder , OpenAPIDocumentModule from .controller import router , MathAPI app = AppFactory . create_app ( routers = ( router , ), controllers = ( MathAPI , )) document_builder = OpenAPIDocumentBuilder () document_builder . set_title ( 'Your Title' ) \\ . set_version ( '1.0.2' ) \\ . set_contact ( name = 'Eadwin' , url = 'https://www.yahoo.com' , email = 'eadwin@gmail.com' ) \\ . set_license ( 'MIT Licence' , url = 'https://www.google.com' ) document = document_builder . build_document ( app ) module = app . install_module ( OpenAPIDocumentModule , document = document ) module . setup_swagger_doc ()","title":"Usage"},{"location":"custom-setup/#start-up-server","text":"uvicorn server:app --reload","title":"Start up Server"},{"location":"custom-setup/#interactive-api-docs","text":"Now go to http://localhost:8000/docs/ You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"release-notes/","text":"","title":"Release Notes"},{"location":"basics/api-docs/","text":"Coming Soon \u00b6","title":"Api docs"},{"location":"basics/api-docs/#coming-soon","text":"","title":"Coming Soon"},{"location":"basics/dynamic-modules/","text":"Dynamic Modules \u00b6 We have seen in many example given on how to statically configure a module . In this section we are going to look at different ways to dynamically set up a module. Why is this important? Consider a scenario where a general-purpose module needs to behave differently in different use cases, it may be useful to use a configuration-based approach to allow customization. This is similar to the concept of a \"plugin\" in many systems, where a generic facility requires some configuration before it can be used by a consumer. Module Dynamic Setup \u00b6 To dynamically configure a module, the module should inherit from IModuleSetup and provide a setup method or setup_register method that performs the necessary actions for setting up the module and then returns a DynamicModule or ModuleSetup instance. import typing as t from ellar.core.modules import DynamicModule , ModuleSetup class IModuleSetup : \"\"\"Modules that must have a custom setup should inherit from IModuleSetup\"\"\" @classmethod def setup ( cls , * args : t . Any , ** kwargs : t . Any ) -> DynamicModule : pass @classmethod def register_setup ( cls , * args : t . Any , ** kwargs : t . Any ) -> ModuleSetup : pass Note that setup method returns a DynamicModule instance, while register_setup method returns a ModuleSetup instance. The DynamicModule instance is used when the module requires some configuration before it can be used by a consumer, while the ModuleSetup instance is used when the module does not require any additional configuration outside the ones provided in the application config. DynamicModule \u00b6 DynamicModule is a dataclass type that is used override Module decorated attributes at easy without having to modify the module code directly. In other words, it gives you the flexibility to reconfigure module. For example: Lets look at the code below: from ellar.common import Module from ellar.core import DynamicModule from ellar.di import ProviderConfig @Module ( providers = [ ServiceA , ServiceB ]) class ModuleA : pass # we can reconfigure ModuleA dynamically using `DynamicModule` as shown below @Module ( modules = [ DynamicModule ( ModuleA , providers = [ ProviderConfig ( ServiceA , use_class = str ), ProviderConfig ( ServiceB , use_class = dict ), ] ) ] ) class ApplicationModule : pass ModuleA has been defined with some arbitrary providers ( ServiceA and ServiceB ), but during registration of ModuleA in ApplicationModule , we used DynamicModule to override its Module attribute providers with a new set of data. ModuleSetup \u00b6 ModuleSetup is a dataclass type that used to set up a module based on its dependencies. It allows you to define the module dependencies and allow a callback factory function for a module dynamic set up. ModuleSetup Properties : module : a required property that defines the type of module to be configured. The value must be a subclass of ModuleBase or IModuleSetup. inject : a sequence property that holds the types to be injected to the factory method. The order of the types will determine the order at which they are injected. factory : a factory function used to configure the module and take Module type as first argument and other services as listed in inject attribute. Let's look this ModuleSetup example code below with our focus on how we eventually configured DynamicService type, how we used my_module_configuration_factory to dynamically build MyModule module. import typing as t from ellar.common import Module , IModuleSetup from ellar.di import ProviderConfig from ellar.core import DynamicModule , ModuleBase , Config , ModuleSetup , AppFactory class Foo : def __init__ ( self ): self . foo = 'foo' class DynamicService : def __init__ ( self , param1 : t . Any , param2 : t . Any , foo : str ): self . param1 = param1 self . param2 = param2 self . foo = foo @Module () class MyModule ( ModuleBase , IModuleSetup ): @classmethod def setup ( cls , param1 : t . Any , param2 : t . Any , foo : Foo ) -> DynamicModule : return DynamicModule ( cls , providers = [ ProviderConfig ( DynamicService , use_value = DynamicService ( param1 , param2 , foo . foo ))], ) def my_module_configuration_factory ( module : t . Type [ MyModule ], config : Config , foo : Foo ): return module . setup ( param1 = config . param1 , param2 = config . param2 , foo = foo ) @Module ( modules = [ ModuleSetup ( MyModule , inject = [ Config , Foo ], factory = my_module_configuration_factory ),], providers = [ Foo ]) class ApplicationModule ( ModuleBase ): pass app = AppFactory . create_from_app_module ( ApplicationModule , config_module = dict ( param1 = \"param1\" , param2 = \"param2\" , )) dynamic_service = app . injector . get ( DynamicService ) assert dynamic_service . param1 == \"param1\" assert dynamic_service . param2 == \"param2\" assert dynamic_service . foo == \"foo\" In the example, we started by defining a service DynamicService , whose parameter depended on some values from application config and from another service Foo . We then set up a MyModule and used as setup method which takes all parameter needed by DynamicService after that, we created DynamicService as a singleton and registered as a provider in MyModule for it to be accessible and injectable. At this point, looking at the setup function of MyModule , its clear MyModule depends on Config and Foo service. And this is where ModuleSetup usefulness comes in. During registration in ApplicationModule , we wrapped MyModule around a ModuleSetup and stated its dependencies in the inject property and also provided a my_module_configuration_factory factory that takes in module dependencies and return a DynamicModule configuration of MyModule . When AppFactory starts module bootstrapping, my_module_configuration_factory will be called with all the required parameters and returned a DynamicModule of MyModule . For more example, checkout Ellar Throttle Module or Ellar Cache Module","title":"Dynamic Modules"},{"location":"basics/dynamic-modules/#dynamic-modules","text":"We have seen in many example given on how to statically configure a module . In this section we are going to look at different ways to dynamically set up a module. Why is this important? Consider a scenario where a general-purpose module needs to behave differently in different use cases, it may be useful to use a configuration-based approach to allow customization. This is similar to the concept of a \"plugin\" in many systems, where a generic facility requires some configuration before it can be used by a consumer.","title":"Dynamic Modules"},{"location":"basics/dynamic-modules/#module-dynamic-setup","text":"To dynamically configure a module, the module should inherit from IModuleSetup and provide a setup method or setup_register method that performs the necessary actions for setting up the module and then returns a DynamicModule or ModuleSetup instance. import typing as t from ellar.core.modules import DynamicModule , ModuleSetup class IModuleSetup : \"\"\"Modules that must have a custom setup should inherit from IModuleSetup\"\"\" @classmethod def setup ( cls , * args : t . Any , ** kwargs : t . Any ) -> DynamicModule : pass @classmethod def register_setup ( cls , * args : t . Any , ** kwargs : t . Any ) -> ModuleSetup : pass Note that setup method returns a DynamicModule instance, while register_setup method returns a ModuleSetup instance. The DynamicModule instance is used when the module requires some configuration before it can be used by a consumer, while the ModuleSetup instance is used when the module does not require any additional configuration outside the ones provided in the application config.","title":"Module Dynamic Setup"},{"location":"basics/dynamic-modules/#dynamicmodule","text":"DynamicModule is a dataclass type that is used override Module decorated attributes at easy without having to modify the module code directly. In other words, it gives you the flexibility to reconfigure module. For example: Lets look at the code below: from ellar.common import Module from ellar.core import DynamicModule from ellar.di import ProviderConfig @Module ( providers = [ ServiceA , ServiceB ]) class ModuleA : pass # we can reconfigure ModuleA dynamically using `DynamicModule` as shown below @Module ( modules = [ DynamicModule ( ModuleA , providers = [ ProviderConfig ( ServiceA , use_class = str ), ProviderConfig ( ServiceB , use_class = dict ), ] ) ] ) class ApplicationModule : pass ModuleA has been defined with some arbitrary providers ( ServiceA and ServiceB ), but during registration of ModuleA in ApplicationModule , we used DynamicModule to override its Module attribute providers with a new set of data.","title":"DynamicModule"},{"location":"basics/dynamic-modules/#modulesetup","text":"ModuleSetup is a dataclass type that used to set up a module based on its dependencies. It allows you to define the module dependencies and allow a callback factory function for a module dynamic set up. ModuleSetup Properties : module : a required property that defines the type of module to be configured. The value must be a subclass of ModuleBase or IModuleSetup. inject : a sequence property that holds the types to be injected to the factory method. The order of the types will determine the order at which they are injected. factory : a factory function used to configure the module and take Module type as first argument and other services as listed in inject attribute. Let's look this ModuleSetup example code below with our focus on how we eventually configured DynamicService type, how we used my_module_configuration_factory to dynamically build MyModule module. import typing as t from ellar.common import Module , IModuleSetup from ellar.di import ProviderConfig from ellar.core import DynamicModule , ModuleBase , Config , ModuleSetup , AppFactory class Foo : def __init__ ( self ): self . foo = 'foo' class DynamicService : def __init__ ( self , param1 : t . Any , param2 : t . Any , foo : str ): self . param1 = param1 self . param2 = param2 self . foo = foo @Module () class MyModule ( ModuleBase , IModuleSetup ): @classmethod def setup ( cls , param1 : t . Any , param2 : t . Any , foo : Foo ) -> DynamicModule : return DynamicModule ( cls , providers = [ ProviderConfig ( DynamicService , use_value = DynamicService ( param1 , param2 , foo . foo ))], ) def my_module_configuration_factory ( module : t . Type [ MyModule ], config : Config , foo : Foo ): return module . setup ( param1 = config . param1 , param2 = config . param2 , foo = foo ) @Module ( modules = [ ModuleSetup ( MyModule , inject = [ Config , Foo ], factory = my_module_configuration_factory ),], providers = [ Foo ]) class ApplicationModule ( ModuleBase ): pass app = AppFactory . create_from_app_module ( ApplicationModule , config_module = dict ( param1 = \"param1\" , param2 = \"param2\" , )) dynamic_service = app . injector . get ( DynamicService ) assert dynamic_service . param1 == \"param1\" assert dynamic_service . param2 == \"param2\" assert dynamic_service . foo == \"foo\" In the example, we started by defining a service DynamicService , whose parameter depended on some values from application config and from another service Foo . We then set up a MyModule and used as setup method which takes all parameter needed by DynamicService after that, we created DynamicService as a singleton and registered as a provider in MyModule for it to be accessible and injectable. At this point, looking at the setup function of MyModule , its clear MyModule depends on Config and Foo service. And this is where ModuleSetup usefulness comes in. During registration in ApplicationModule , we wrapped MyModule around a ModuleSetup and stated its dependencies in the inject property and also provided a my_module_configuration_factory factory that takes in module dependencies and return a DynamicModule configuration of MyModule . When AppFactory starts module bootstrapping, my_module_configuration_factory will be called with all the required parameters and returned a DynamicModule of MyModule . For more example, checkout Ellar Throttle Module or Ellar Cache Module","title":"ModuleSetup"},{"location":"basics/execution-context/","text":"Execution Context \u00b6 Execution context refers to the current context of execution, or the environment in which a specific piece of code is running. It contains information about the current request, the current response in the case of http connection, and the current state of the application. The execution context is created automatically when a request is received, and it is passed along through the various layers of the application as the request is handled. This allows different components of the application like exception handlers , functional middlewares and guards to access information about the current request. There are two class HostContext and ExecutionContext which provides set of methods and properties for accessing and manipulating the current context of execution. HostContext \u00b6 The HostContext class provides a wrapper around ASGI app parameters ( scope , receive and send ) and provides some methods that allows you choosing the appropriate context(e.g., HTTP or WebSockets). For example, the catch() method of an exception handlers is called with an IHostContext. # project_name/apps/custom_exceptions.py import typing as t from ellar.common import IExceptionHandler , IHostContext , Response class MyCustomException ( Exception ): pass class MyCustomExceptionHandler ( IExceptionHandler ): exception_type_or_code = MyCustomException async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: if ctx . get_type () == 'http' : # do something that is only important in the context of regular HTTP requests (REST) pass elif ctx . get_type () == 'websocket' : # do something that is only important in the context of regular Websocket pass app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , ) Switching to other Contexts \u00b6 Currently, in Ellar you can only switch between http and websocket context. And each context has get_client method that returns context session. async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: if ctx . get_type () == 'http' : # do something that is only important in the context of regular HTTP requests (REST) http_context = ctx . switch_to_http_connection () request : Request = http_context . get_request () response : Response = http_context . get_response () http_connection : HTTPConnection = http_context . get_client () elif ctx . get_type () == 'websocket' : # do something that is only important in the context of regular Websocket websocket_context = ctx . switch_to_websocket () websocket_session : WebSocket = websocket_context . get_client () app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , ) Info Its good to note that you can't switch to a context that does not match the current context type. Always use the .get_type() to verify the type before switching. IHostContext Properties \u00b6 Important properties of HostContext get_service_provider : returns current service provider using in handling the request get_app : returns current application instance get_type : gets scope type http , websocket get_args : returns scope , receive and send ASGI parameters switch_to_http_connection : returns HTTPConnectionHost instance switch_to_websocket : returns WebSocketConnectionHost instance class IHostContext ( ABC ): @abstractmethod def get_service_provider ( self ) -> \"RequestServiceProvider\" : \"\"\"Gets RequestServiceProvider instance\"\"\" @abstractmethod def switch_to_http_connection ( self ) -> IHTTPConnectionHost : \"\"\"Returns HTTPConnection instance\"\"\" @abstractmethod def switch_to_websocket ( self ) -> IWebSocketConnectionHost : \"\"\"Returns WebSocket instance\"\"\" @abstractmethod def get_app ( self ) -> \"App\" : \"\"\"Gets application instance\"\"\" @abstractmethod def get_type ( self ) -> str : \"\"\"returns scope type\"\"\" @abstractmethod def get_args ( self ) -> t . Tuple [ TScope , TReceive , TSend ]: \"\"\"returns all args passed to asgi function\"\"\" IHTTPConnectionHost and IWebSocketConnectionHost has some methods that maybe of interest. Here are methods for IHTTPConnectionHost : class IHTTPConnectionHost ( ABC ): @abstractmethod def get_response ( self ) -> Response : \"\"\"Gets response\"\"\" @abstractmethod def get_request ( self ) -> Request : \"\"\"Returns Request instance\"\"\" @abstractmethod def get_client ( self ) -> HTTPConnection : \"\"\"Returns HTTPConnection instance\"\"\" Following are the methods for IWebSocketConnectionHost : class IWebSocketConnectionHost ( ABC ): @abstractmethod def get_client ( self ) -> WebSocket : \"\"\"Returns WebSocket instance\"\"\" ExecutionContext Class \u00b6 ExecutionContext extends HostContext and provides extra information like Controller class and controller function that will handler the current request. import typing from ellar.common import ControllerBase from ellar.core import HostContext class ExecutionContext ( HostContext ): # Returns the type of the controller class which the current handler belongs to. def get_class ( self ) -> typing . Type [ ControllerBase ]: pass # Returns a reference to the handler (method) that will be handler the current request. def get_handler ( self ) -> typing . Callable : pass These extra information are necessary for reading metadata properties set on controllers or the route handler function. How to access the current execution context \u00b6 You can access the current execution context using the Context() function. This decorator can be applied to a parameter of a controller or service method, and it will inject the current ExecutionContext object into the method. For example, consider the following controller method: from ellar.common import Context , get , Controller @Controller ( '/users' ) class UserController : @get ( '/ {user_id} ' ) async def get_user ( self , user_id : str , ctx = Context ()): # Use the ctx object to access the current execution context res = ctx . switch_to_http_connection () . get_response () res . status_code = 200 res . body = f \"Request to get user with id= { user_id } \" . encode ( \"utf-8\" ) scope , receive , send = ctx . get_args () await res ( scope , receive , send ) # sends response In this example, the get_user method is decorated with the @get decorator to handle a GET request to the /users/:id route. The Context() function is applied to the second parameter of the method, which will inject the current ExecutionContext object into the method. Once you have access to the ExecutionContext object, you can use its methods and properties to access information about the current request. Reflector and Metadata \u00b6 Ellar provides the ability to attach custom metadata to route handlers through the @set_metadata() decorator. We can then access this metadata from within our class to make certain decisions. # project_name/apps/cars/controllers.py from ellar.common import Body , Controller , post , set_metadata , ControllerBase from .schemas import CreateCarSerializer @Controller ( '/car' ) class CarController ( ControllerBase ): @post () @set_metadata ( 'role' , [ 'admin' ]) async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result With the construction above, we attached the roles metadata (roles is a metadata key and ['admin'] is the associated value) to the create() method. While this works, it's not good practice to use @set_metadata() directly in your routes. Instead, create your own decorators, as shown below: # project_name/apps/cars/controllers.py import typing from ellar.common import Body , Controller , post , set_metadata , ControllerBase from .schemas import CreateCarSerializer def roles ( * _roles : str ) -> typing . Callable : return set_metadata ( 'roles' , list ( _roles )) @Controller ( '/car' ) class CarController ( ControllerBase ): @post () @roles ( 'admin' , 'is_staff' ) async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result Info It's important to note that ExecutionContext becomes available when there is route handler found to handle the current request. To access the route's role(s) (custom metadata), we'll use the Reflector helper class, which is provided out of the box by the framework. Reflector can be injected into a class in the normal way: # project_name/apps/cars/guards.py from ellar.di import injectable from ellar.common import GuardCanActivate , IExecutionContext from ellar.core.services import Reflector @injectable () class RoleGuard ( GuardCanActivate ): def __init__ ( self , reflector : Reflector ): self . reflector = reflector async def can_activate ( self , context : IExecutionContext ) -> bool : roles = self . reflector . get ( 'roles' , context . get_handler ()) # request = context.switch_to_http_connection().get_request() # check if user in request object has role if not roles : return True return 'user' in roles Next, we apply the RoleGuard to CarController # project_name/apps/cars/controllers.py import typing from ellar.common import Body , Controller , post , set_metadata , UseGuards , ControllerBase from .schemas import CreateCarSerializer from .guards import RoleGuard def roles ( * _roles : str ) -> typing . Callable : return set_metadata ( 'roles' , list ( _roles )) @Controller ( '/car' ) @UseGuards ( RoleGuard ) class CarController ( ControllerBase ): @post () @roles ( 'admin' , 'is_staff' ) async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result Also, since RoleGuard is marked as injectable , EllarInjector service will be able to resolve RoleGuard without RoleGuard registered as a provider.","title":"Execution Context"},{"location":"basics/execution-context/#execution-context","text":"Execution context refers to the current context of execution, or the environment in which a specific piece of code is running. It contains information about the current request, the current response in the case of http connection, and the current state of the application. The execution context is created automatically when a request is received, and it is passed along through the various layers of the application as the request is handled. This allows different components of the application like exception handlers , functional middlewares and guards to access information about the current request. There are two class HostContext and ExecutionContext which provides set of methods and properties for accessing and manipulating the current context of execution.","title":"Execution Context"},{"location":"basics/execution-context/#hostcontext","text":"The HostContext class provides a wrapper around ASGI app parameters ( scope , receive and send ) and provides some methods that allows you choosing the appropriate context(e.g., HTTP or WebSockets). For example, the catch() method of an exception handlers is called with an IHostContext. # project_name/apps/custom_exceptions.py import typing as t from ellar.common import IExceptionHandler , IHostContext , Response class MyCustomException ( Exception ): pass class MyCustomExceptionHandler ( IExceptionHandler ): exception_type_or_code = MyCustomException async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: if ctx . get_type () == 'http' : # do something that is only important in the context of regular HTTP requests (REST) pass elif ctx . get_type () == 'websocket' : # do something that is only important in the context of regular Websocket pass app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , )","title":"HostContext"},{"location":"basics/execution-context/#switching-to-other-contexts","text":"Currently, in Ellar you can only switch between http and websocket context. And each context has get_client method that returns context session. async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: if ctx . get_type () == 'http' : # do something that is only important in the context of regular HTTP requests (REST) http_context = ctx . switch_to_http_connection () request : Request = http_context . get_request () response : Response = http_context . get_response () http_connection : HTTPConnection = http_context . get_client () elif ctx . get_type () == 'websocket' : # do something that is only important in the context of regular Websocket websocket_context = ctx . switch_to_websocket () websocket_session : WebSocket = websocket_context . get_client () app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , ) Info Its good to note that you can't switch to a context that does not match the current context type. Always use the .get_type() to verify the type before switching.","title":"Switching to other Contexts"},{"location":"basics/execution-context/#ihostcontext-properties","text":"Important properties of HostContext get_service_provider : returns current service provider using in handling the request get_app : returns current application instance get_type : gets scope type http , websocket get_args : returns scope , receive and send ASGI parameters switch_to_http_connection : returns HTTPConnectionHost instance switch_to_websocket : returns WebSocketConnectionHost instance class IHostContext ( ABC ): @abstractmethod def get_service_provider ( self ) -> \"RequestServiceProvider\" : \"\"\"Gets RequestServiceProvider instance\"\"\" @abstractmethod def switch_to_http_connection ( self ) -> IHTTPConnectionHost : \"\"\"Returns HTTPConnection instance\"\"\" @abstractmethod def switch_to_websocket ( self ) -> IWebSocketConnectionHost : \"\"\"Returns WebSocket instance\"\"\" @abstractmethod def get_app ( self ) -> \"App\" : \"\"\"Gets application instance\"\"\" @abstractmethod def get_type ( self ) -> str : \"\"\"returns scope type\"\"\" @abstractmethod def get_args ( self ) -> t . Tuple [ TScope , TReceive , TSend ]: \"\"\"returns all args passed to asgi function\"\"\" IHTTPConnectionHost and IWebSocketConnectionHost has some methods that maybe of interest. Here are methods for IHTTPConnectionHost : class IHTTPConnectionHost ( ABC ): @abstractmethod def get_response ( self ) -> Response : \"\"\"Gets response\"\"\" @abstractmethod def get_request ( self ) -> Request : \"\"\"Returns Request instance\"\"\" @abstractmethod def get_client ( self ) -> HTTPConnection : \"\"\"Returns HTTPConnection instance\"\"\" Following are the methods for IWebSocketConnectionHost : class IWebSocketConnectionHost ( ABC ): @abstractmethod def get_client ( self ) -> WebSocket : \"\"\"Returns WebSocket instance\"\"\"","title":"IHostContext Properties"},{"location":"basics/execution-context/#executioncontext-class","text":"ExecutionContext extends HostContext and provides extra information like Controller class and controller function that will handler the current request. import typing from ellar.common import ControllerBase from ellar.core import HostContext class ExecutionContext ( HostContext ): # Returns the type of the controller class which the current handler belongs to. def get_class ( self ) -> typing . Type [ ControllerBase ]: pass # Returns a reference to the handler (method) that will be handler the current request. def get_handler ( self ) -> typing . Callable : pass These extra information are necessary for reading metadata properties set on controllers or the route handler function.","title":"ExecutionContext Class"},{"location":"basics/execution-context/#how-to-access-the-current-execution-context","text":"You can access the current execution context using the Context() function. This decorator can be applied to a parameter of a controller or service method, and it will inject the current ExecutionContext object into the method. For example, consider the following controller method: from ellar.common import Context , get , Controller @Controller ( '/users' ) class UserController : @get ( '/ {user_id} ' ) async def get_user ( self , user_id : str , ctx = Context ()): # Use the ctx object to access the current execution context res = ctx . switch_to_http_connection () . get_response () res . status_code = 200 res . body = f \"Request to get user with id= { user_id } \" . encode ( \"utf-8\" ) scope , receive , send = ctx . get_args () await res ( scope , receive , send ) # sends response In this example, the get_user method is decorated with the @get decorator to handle a GET request to the /users/:id route. The Context() function is applied to the second parameter of the method, which will inject the current ExecutionContext object into the method. Once you have access to the ExecutionContext object, you can use its methods and properties to access information about the current request.","title":"How to access the current execution context"},{"location":"basics/execution-context/#reflector-and-metadata","text":"Ellar provides the ability to attach custom metadata to route handlers through the @set_metadata() decorator. We can then access this metadata from within our class to make certain decisions. # project_name/apps/cars/controllers.py from ellar.common import Body , Controller , post , set_metadata , ControllerBase from .schemas import CreateCarSerializer @Controller ( '/car' ) class CarController ( ControllerBase ): @post () @set_metadata ( 'role' , [ 'admin' ]) async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result With the construction above, we attached the roles metadata (roles is a metadata key and ['admin'] is the associated value) to the create() method. While this works, it's not good practice to use @set_metadata() directly in your routes. Instead, create your own decorators, as shown below: # project_name/apps/cars/controllers.py import typing from ellar.common import Body , Controller , post , set_metadata , ControllerBase from .schemas import CreateCarSerializer def roles ( * _roles : str ) -> typing . Callable : return set_metadata ( 'roles' , list ( _roles )) @Controller ( '/car' ) class CarController ( ControllerBase ): @post () @roles ( 'admin' , 'is_staff' ) async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result Info It's important to note that ExecutionContext becomes available when there is route handler found to handle the current request. To access the route's role(s) (custom metadata), we'll use the Reflector helper class, which is provided out of the box by the framework. Reflector can be injected into a class in the normal way: # project_name/apps/cars/guards.py from ellar.di import injectable from ellar.common import GuardCanActivate , IExecutionContext from ellar.core.services import Reflector @injectable () class RoleGuard ( GuardCanActivate ): def __init__ ( self , reflector : Reflector ): self . reflector = reflector async def can_activate ( self , context : IExecutionContext ) -> bool : roles = self . reflector . get ( 'roles' , context . get_handler ()) # request = context.switch_to_http_connection().get_request() # check if user in request object has role if not roles : return True return 'user' in roles Next, we apply the RoleGuard to CarController # project_name/apps/cars/controllers.py import typing from ellar.common import Body , Controller , post , set_metadata , UseGuards , ControllerBase from .schemas import CreateCarSerializer from .guards import RoleGuard def roles ( * _roles : str ) -> typing . Callable : return set_metadata ( 'roles' , list ( _roles )) @Controller ( '/car' ) @UseGuards ( RoleGuard ) class CarController ( ControllerBase ): @post () @roles ( 'admin' , 'is_staff' ) async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result Also, since RoleGuard is marked as injectable , EllarInjector service will be able to resolve RoleGuard without RoleGuard registered as a provider.","title":"Reflector and Metadata"},{"location":"basics/file-streaming/","text":"","title":"File streaming"},{"location":"basics/injector-scopes/","text":"Injector Scopes \u00b6 There are 3 different scopes which defines ways a service/provider is instantiated. TRANSIENT SCOPE SINGLETON SCOPE REQUEST SCOPE transient_scope : \u00b6 Whenever a transient scoped provider is required, a new instance of the provider is created # main.py from ellar.di import EllarInjector , transient_scope , injectable injector = EllarInjector ( auto_bind = False ) @injectable ( scope = transient_scope ) class ATransientClass : pass injector . container . register ( ATransientClass ) # OR # injector.container.register_transient(ATransientClass) def validate_transient_scope (): a_transient_instance_1 = injector . get ( ATransientClass ) a_transient_instance_2 = injector . get ( ATransientClass ) assert a_transient_instance_2 != a_transient_instance_1 # True if __name__ == \"__main__\" : validate_transient_scope () singleton_scope : \u00b6 A singleton scoped provider is created once throughout the lifespan of the Container instance. For example: # main.py from ellar.di import EllarInjector , singleton_scope , injectable injector = EllarInjector ( auto_bind = False ) # OR @injectable ( scope = singleton_scope ) class ASingletonClass : pass injector . container . register ( ASingletonClass ) # OR # injector.container.register_singleton(ASingletonClass) def validate_singleton_scope (): a_singleton_instance_1 = injector . get ( ASingletonClass ) a_singleton_instance_2 = injector . get ( ASingletonClass ) assert a_singleton_instance_2 == a_singleton_instance_1 # True if __name__ == \"__main__\" : validate_singleton_scope () request_scope : \u00b6 A request scoped provider is instantiated once during the scope of the request. And it's destroyed once the request is complete. It is important to note that request_scope behaves like a singleton_scope during HTTPConnection mode and behaves like a transient_scope outside HTTPConnection mode. # main.py import uvicorn from ellar.di import EllarInjector , request_scope , injectable injector = EllarInjector ( auto_bind = False ) @injectable ( scope = request_scope ) class ARequestScopeClass : pass injector . container . register ( ARequestScopeClass ) async def scoped_request ( scope , receive , send ): async with injector . create_asgi_args ( scope , receive , send ) as request_injector : request_instance_1 = request_injector . get ( ARequestScopeClass ) request_instance_2 = request_injector . get ( ARequestScopeClass ) assert request_instance_2 == request_instance_1 request_instance_1 = injector . get ( ARequestScopeClass ) request_instance_2 = injector . get ( ARequestScopeClass ) assert request_instance_2 != request_instance_1 if __name__ == \"__main__\" : uvicorn . run ( \"main:scoped_request\" , port = 5000 , log_level = \"info\" )","title":"Injector Scopes"},{"location":"basics/injector-scopes/#injector-scopes","text":"There are 3 different scopes which defines ways a service/provider is instantiated. TRANSIENT SCOPE SINGLETON SCOPE REQUEST SCOPE","title":"Injector Scopes"},{"location":"basics/injector-scopes/#transient_scope","text":"Whenever a transient scoped provider is required, a new instance of the provider is created # main.py from ellar.di import EllarInjector , transient_scope , injectable injector = EllarInjector ( auto_bind = False ) @injectable ( scope = transient_scope ) class ATransientClass : pass injector . container . register ( ATransientClass ) # OR # injector.container.register_transient(ATransientClass) def validate_transient_scope (): a_transient_instance_1 = injector . get ( ATransientClass ) a_transient_instance_2 = injector . get ( ATransientClass ) assert a_transient_instance_2 != a_transient_instance_1 # True if __name__ == \"__main__\" : validate_transient_scope ()","title":"transient_scope:"},{"location":"basics/injector-scopes/#singleton_scope","text":"A singleton scoped provider is created once throughout the lifespan of the Container instance. For example: # main.py from ellar.di import EllarInjector , singleton_scope , injectable injector = EllarInjector ( auto_bind = False ) # OR @injectable ( scope = singleton_scope ) class ASingletonClass : pass injector . container . register ( ASingletonClass ) # OR # injector.container.register_singleton(ASingletonClass) def validate_singleton_scope (): a_singleton_instance_1 = injector . get ( ASingletonClass ) a_singleton_instance_2 = injector . get ( ASingletonClass ) assert a_singleton_instance_2 == a_singleton_instance_1 # True if __name__ == \"__main__\" : validate_singleton_scope ()","title":"singleton_scope:"},{"location":"basics/injector-scopes/#request_scope","text":"A request scoped provider is instantiated once during the scope of the request. And it's destroyed once the request is complete. It is important to note that request_scope behaves like a singleton_scope during HTTPConnection mode and behaves like a transient_scope outside HTTPConnection mode. # main.py import uvicorn from ellar.di import EllarInjector , request_scope , injectable injector = EllarInjector ( auto_bind = False ) @injectable ( scope = request_scope ) class ARequestScopeClass : pass injector . container . register ( ARequestScopeClass ) async def scoped_request ( scope , receive , send ): async with injector . create_asgi_args ( scope , receive , send ) as request_injector : request_instance_1 = request_injector . get ( ARequestScopeClass ) request_instance_2 = request_injector . get ( ARequestScopeClass ) assert request_instance_2 == request_instance_1 request_instance_1 = injector . get ( ARequestScopeClass ) request_instance_2 = injector . get ( ARequestScopeClass ) assert request_instance_2 != request_instance_1 if __name__ == \"__main__\" : uvicorn . run ( \"main:scoped_request\" , port = 5000 , log_level = \"info\" )","title":"request_scope:"},{"location":"basics/lifespan/","text":"Lifespan \u00b6 Ellar applications registers a lifespan manager. The manager handles lifespan handler registered in the configuration under the variable name DEFAULT_LIFESPAN_HANDLER and also executes code that needs to run before the application starts up, or when the application is shutting down. The lifespan manager must be run before ellar starts serving incoming request. import uvicorn import contextlib from ellar.core import App , AppFactory @contextlib . asynccontextmanager async def some_async_resource (): print ( \"running some-async-resource function\" ) yield print ( \"existing some-async-resource function\" ) @contextlib . asynccontextmanager async def lifespan ( app : App ): async with some_async_resource (): print ( \"Run at startup!\" ) yield print ( \"Run on shutdown!\" ) application = AppFactory . create_app ( config_module = dict ( DEFAULT_LIFESPAN_HANDLER = lifespan )) if __name__ == \"__main__\" : uvicorn . run ( application , port = 5000 , log_level = \"info\" ) The construct above will generate the output below: INFO: Started server process [ 11772 ] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://127.0.0.1:5000 ( Press CTRL+C to quit ) running some-async-resource function Run at startup! INFO: Shutting down INFO: Waiting for application shutdown. INFO: Application shutdown complete. INFO: Finished server process [ 11772 ] Run on shutdown! existing some-async-resource function Modules and Lifespan \u00b6 Any module that wants to engage in application lifespan must inherit IApplicationStartup for startup actions or IApplicationShutdown for shutdown actions or inherit both for startup and shutdown actions. IApplicationStartup has an abstractmethod on_startup function and IApplicationShutdown has an abstractmethod on_shutdown function. from abc import abstractmethod class IApplicationStartup : @abstractmethod async def on_startup ( self , app : \"App\" ) -> None : ... class IApplicationShutdown : @abstractmethod async def on_shutdown ( self ) -> None : ... Let's assume we have a module that extends both IApplicationStartup and IApplicationShutdown to execute some actions on startup and on shutdown as shown below: from ellar.common import IApplicationShutdown , IApplicationStartup , Module @Module () class SampleModule ( IApplicationShutdown , IApplicationStartup ): async def on_startup ( self , app ) -> None : print ( \"Run at startup! in SampleModule\" ) async def on_shutdown ( self ) -> None : print ( \"Run on shutdown! in SampleModule\" ) Running lifespan in tests \u00b6 You should use TestClient as a context manager, to ensure that the lifespan is called. from ellar.testing import Test from .main import SampleModule test_module = Test . create_test_module ( modules = [ SampleModule ]) def test_lifespan (): with test_module . get_test_client () as client : # Application's lifespan is called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # And the lifespan's teardown is run when exiting the block.","title":"Lifespan"},{"location":"basics/lifespan/#lifespan","text":"Ellar applications registers a lifespan manager. The manager handles lifespan handler registered in the configuration under the variable name DEFAULT_LIFESPAN_HANDLER and also executes code that needs to run before the application starts up, or when the application is shutting down. The lifespan manager must be run before ellar starts serving incoming request. import uvicorn import contextlib from ellar.core import App , AppFactory @contextlib . asynccontextmanager async def some_async_resource (): print ( \"running some-async-resource function\" ) yield print ( \"existing some-async-resource function\" ) @contextlib . asynccontextmanager async def lifespan ( app : App ): async with some_async_resource (): print ( \"Run at startup!\" ) yield print ( \"Run on shutdown!\" ) application = AppFactory . create_app ( config_module = dict ( DEFAULT_LIFESPAN_HANDLER = lifespan )) if __name__ == \"__main__\" : uvicorn . run ( application , port = 5000 , log_level = \"info\" ) The construct above will generate the output below: INFO: Started server process [ 11772 ] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://127.0.0.1:5000 ( Press CTRL+C to quit ) running some-async-resource function Run at startup! INFO: Shutting down INFO: Waiting for application shutdown. INFO: Application shutdown complete. INFO: Finished server process [ 11772 ] Run on shutdown! existing some-async-resource function","title":"Lifespan"},{"location":"basics/lifespan/#modules-and-lifespan","text":"Any module that wants to engage in application lifespan must inherit IApplicationStartup for startup actions or IApplicationShutdown for shutdown actions or inherit both for startup and shutdown actions. IApplicationStartup has an abstractmethod on_startup function and IApplicationShutdown has an abstractmethod on_shutdown function. from abc import abstractmethod class IApplicationStartup : @abstractmethod async def on_startup ( self , app : \"App\" ) -> None : ... class IApplicationShutdown : @abstractmethod async def on_shutdown ( self ) -> None : ... Let's assume we have a module that extends both IApplicationStartup and IApplicationShutdown to execute some actions on startup and on shutdown as shown below: from ellar.common import IApplicationShutdown , IApplicationStartup , Module @Module () class SampleModule ( IApplicationShutdown , IApplicationStartup ): async def on_startup ( self , app ) -> None : print ( \"Run at startup! in SampleModule\" ) async def on_shutdown ( self ) -> None : print ( \"Run on shutdown! in SampleModule\" )","title":"Modules and Lifespan"},{"location":"basics/lifespan/#running-lifespan-in-tests","text":"You should use TestClient as a context manager, to ensure that the lifespan is called. from ellar.testing import Test from .main import SampleModule test_module = Test . create_test_module ( modules = [ SampleModule ]) def test_lifespan (): with test_module . get_test_client () as client : # Application's lifespan is called on entering the block. response = client . get ( \"/\" ) assert response . status_code == 200 # And the lifespan's teardown is run when exiting the block.","title":"Running lifespan in tests"},{"location":"basics/model-view-controller/","text":"","title":"Model view controller"},{"location":"basics/testing/","text":"Testing \u00b6 Automated testing is the practice of using software tools to automatically run tests on a software application or system, rather than relying on manual testing by humans. It is considered an essential part of software development as it helps increase productivity, ensure quality and performance goals are met, and provide faster feedback loops to developers. Automated tests can include various types such as unit tests, integration tests, end-to-end tests, and more. While setting up automated tests can be tedious, the benefits of increased test coverage and productivity make it an important aspect of software development. Ellar aims to encourage the use of development best practices, including effective testing, by providing various features to assist developers and teams in creating and automating tests. These features include: automatically generated default unit tests files for components testing offering a util, Test Factory class, that constructs an isolated module/application setup making the Ellar dependency injection system accessible in the testing environment for convenient component mocking. Ellar is compatible with unittest and pytest testing frameworks in python but in this documentation, we will be using pytest . Getting started \u00b6 You will need to install pytest pip install pytest Unit testing \u00b6 In the following example, we test two classes: CarController and CarRepository . For this we need to use TestClientFactory to build them in isolation from the application since we are writing unit test. Looking at the car module we scaffolded earlier, there is a tests folder provided and inside that folder there is test_controllers.py module. We are going to be writing unit test for CarController in there. # project_name/car/tests/test_controllers.py from project_name.apps.car.controllers import CarController from project_name.apps.car.schemas import CreateCarSerializer , CarListFilter from project_name.apps.car.services import CarRepository class TestCarController : def setup ( self ): self . controller : CarController = CarController ( repo = CarRepository ()) async def test_create_action ( self , anyio_backend ): result = await self . controller . create ( CreateCarSerializer ( name = \"Mercedes\" , year = 2022 , model = \"CLS\" ) ) assert result == { \"id\" : \"1\" , \"message\" : \"This action adds a new car\" , \"model\" : \"CLS\" , \"name\" : \"Mercedes\" , \"year\" : 2022 , } In example above, we aren't really testing anything Ellar-specific. Notice that we are not using dependency injection; rather, we pass an instance of CarController to our CarRepository . This type of testing, where we manually instantiate the classes being tested, is commonly referred to as isolated testing because it is framework-independent Using Test Factory \u00b6 Test factory function in ellar.testing package, is a great tool employ for a quick and better test setup. Let's rewrite the previous example using the built-in Test class: # project_name/car/tests/test_controllers.py from unittest.mock import patch from ellar.di import ProviderConfig from ellar.testing import Test from project_name.apps.car.controllers import CarController from project_name.apps.car.schemas import CreateCarSerializer , CarListFilter from project_name.apps.car.services import CarRepository class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )] ) self . controller : CarController = test_module . get ( CarController ) async def test_create_action ( self , anyio_backend ): result = await self . controller . create ( CreateCarSerializer ( name = \"Mercedes\" , year = 2022 , model = \"CLS\" ) ) assert result == { \"id\" : \"1\" , \"message\" : \"This action adds a new car\" , \"model\" : \"CLS\" , \"name\" : \"Mercedes\" , \"year\" : 2022 , } @patch . object ( CarRepository , 'get_all' , return_value = [ dict ( id = 2 , model = 'CLS' , name = 'Mercedes' , year = 2023 )]) async def test_get_all_action ( self , mock_get_all , anyio_backend ): result = await self . controller . get_all ( query = CarListFilter ( offset = 0 , limit = 10 )) assert result == { 'cars' : [ { 'id' : 2 , 'model' : 'CLS' , 'name' : 'Mercedes' , 'year' : 2023 } ], 'message' : 'This action returns all cars at limit=10, offset=0' } With the Test class, you can create an application execution context that simulates the entire Ellar runtime, providing hooks to easily manage class instances by allowing for mocking and overriding. The Test class has a create_test_module() method that takes a module metadata object as its argument (the same object you pass to the @Module() decorator). This method returns a TestingModule instance which in turn provides a few methods: override_provider : Essential for overriding providers or guards with a mocked type. create_application : This method will return an application instance for the isolated testing module. get_test_client : creates and return a TestClient for the application which will allow you to make requests against your application, using the httpx library. Overriding Providers \u00b6 TestingModule override_provider method allows you to provide an alternative for a provider type or a guard type. For example: from ellar.testing import Test class MockCarRepository ( CarRepository ): pass class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,] ) . override_provider ( CarRepository , use_class = MockCarRepository ) override_provider takes the same arguments as ellar.di.ProviderConfig and in fact, it builds to ProvideConfig behind the scenes. In example above, we created a MockCarRepository for CarRepository and applied it as shown above. We can also create an instance of MockCarRepository and have it behave as a singleton within the scope of test_module instance. from ellar.testing import Test class MockCarRepository ( CarRepository ): pass class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,] ) . override_provider ( CarRepository , use_value = MockCarRepository ()) We this, anywhere CarRepository is needed, a MockCarRepository() instance will be applied. In same way, we can override UseGuards used in controllers during testing. For example, lets assume CarController has a guard JWTGuard import typing from ellar.common.compatible import AttributeDict from ellar.common import UseGuards , Controller , ControllerBase from ellar.core.guard import HttpBearerAuth from ellar.di import injectable @injectable () class JWTGuard ( HttpBearerAuth ): async def authenticate ( self , connection , credentials ) -> typing . Any : # JWT verification goes here return AttributeDict ( is_authenticated = True , first_name = 'Ellar' , last_name = 'ASGI Framework' ) @UseGuards ( JWTGuard ) @Controller ( '/car' ) class CarController ( ControllerBase ): ... During testing, we can replace JWTGuard with a MockAuthGuard as shown below. from ellar.testing import Test from .controllers import CarController , JWTGuard class MockAuthGuard ( JWTGuard ): async def authenticate ( self , connection , credentials ) -> typing . Any : # Jwt verification goes here. return dict ( first_name = 'Ellar' , last_name = 'ASGI Framework' ) class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,] ) . override_provider ( JWTGuard , use_class = MockAuthGuard ) Create Application \u00b6 We can access the application instance after setting up the TestingModule . You simply need to call create_application method of the TestingModule . For example: from ellar.di import ProviderConfig from ellar.testing import Test class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )] ) app = test_module . create_application () car_repo = app . injector . get ( CarRepository ) assert isinstance ( car_repo , CarRepository ) Overriding Application Conf During Testing \u00b6 Having different application configurations for different environments is a best practice in software development. It involves creating different sets of configuration variables, such as database connection details, API keys, and environment-specific settings, for different environments such as development, staging, and production. During testing, there two ways to apply or modify configuration. In a file Inline In config.py file, we can define another configuration for testing eg, class TestConfiguration and then we can apply it to config_module when creating TestingModule . For example: # project_name/config.py ... class BaseConfig ( ConfigDefaultTypesMixin ): DEBUG : bool = False class TestingConfiguration ( BaseConfig ): DEBUG = True ANOTHER_CONFIG_VAR = 'Ellar' We have created TestingConfiguration inside project_name.config python module. Lets apply this to TestingModule. # project_name/car/tests/test_controllers.py class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )], config_module = 'project_name.config:TestingConfiguration' ) self . controller : CarController = test_module . get ( CarController ) Also, we can expose the testing config to environment for more global scope, for example: # project_name/tests/conftest.py import os from ellar.constants import ELLAR_CONFIG_MODULE os . environ . setdefault ( ELLAR_CONFIG_MODULE , 'project_name.config:TestingConfiguration' ) This method doesn't require configuration file, we simply go ahead and define the configuration variables in a dictionary type set to config_module . For instance: # project_name/car/tests/test_controllers.py class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )], config_module = dict ( DEBUG = True , ANOTHER_CONFIG_VAR = 'Ellar' ) ) self . controller : CarController = test_module . get ( CarController ) End-to-End Test \u00b6 End-to-end (e2e) testing operates on a higher level of abstraction than unit testing, assessing the interaction between classes and modules in a way that approximates user behavior with the production system. As an application expands, manual e2e testing of every API endpoint becomes increasingly difficult, which is where automated e2e testing becomes essential in validating that the system's overall behavior is correct and aligned with project requirements. To execute e2e tests, we adopt a similar configuration to that of unit testing, and Ellar's use of TestClient , a tool provided by Starlette, to facilitates the simulation of HTTP requests TestClient \u00b6 Starlette provides a TestClient for making requests ASGI Applications, and it's based on httpx library similar to requests. from starlette.responses import HTMLResponse from starlette.testclient import TestClient async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body>Hello, world!</body></html>' ) await response ( scope , receive , send ) def test_app (): client = TestClient ( app ) response = client . get ( '/' ) assert response . status_code == 200 In example above, TestClient needs an ASGI Callable. It exposes the same interface as any other httpx session. In particular, note that the calls to make a request are just standard function calls, not awaitable. Let's see how we can use TestClient in writing e2e testing for CarController and CarRepository . # project_name/car/tests/test_controllers.py from ellar.di import ProviderConfig from ellar.testing import Test , TestClient from project_name.apps.car.controllers import CarController from project_name.apps.car.services import CarRepository class MockCarRepository ( CarRepository ): def get_all ( self ): return [ dict ( id = 2 , model = 'CLS' , name = 'Mercedes' , year = 2023 )] class TestCarControllerE2E : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = MockCarRepository )], config_module = dict ( REDIRECT_SLASHES = True ) ) self . client : TestClient = test_module . get_test_client () def test_create_action ( self ): res = self . client . post ( '/car' , json = dict ( name = \"Mercedes\" , year = 2022 , model = \"CLS\" )) assert res . status_code == 200 assert res . json () == { \"id\" : \"1\" , \"message\" : \"This action adds a new car\" , \"model\" : \"CLS\" , \"name\" : \"Mercedes\" , \"year\" : 2022 , } def test_get_all_action ( self ): res = self . client . get ( '/car?offset=0&limit=10' ) assert res . status_code == 200 assert res . json () == { 'cars' : [ { 'id' : 2 , 'model' : 'CLS' , 'name' : 'Mercedes' , 'year' : 2023 } ], 'message' : 'This action returns all cars at limit=10, offset=0' } In the construct above, test_module.get_test_client() created an isolated application instance and used it to instantiate a TestClient . And with we are able to simulate request behaviour on CarController .","title":"Testing"},{"location":"basics/testing/#testing","text":"Automated testing is the practice of using software tools to automatically run tests on a software application or system, rather than relying on manual testing by humans. It is considered an essential part of software development as it helps increase productivity, ensure quality and performance goals are met, and provide faster feedback loops to developers. Automated tests can include various types such as unit tests, integration tests, end-to-end tests, and more. While setting up automated tests can be tedious, the benefits of increased test coverage and productivity make it an important aspect of software development. Ellar aims to encourage the use of development best practices, including effective testing, by providing various features to assist developers and teams in creating and automating tests. These features include: automatically generated default unit tests files for components testing offering a util, Test Factory class, that constructs an isolated module/application setup making the Ellar dependency injection system accessible in the testing environment for convenient component mocking. Ellar is compatible with unittest and pytest testing frameworks in python but in this documentation, we will be using pytest .","title":"Testing"},{"location":"basics/testing/#getting-started","text":"You will need to install pytest pip install pytest","title":"Getting started"},{"location":"basics/testing/#unit-testing","text":"In the following example, we test two classes: CarController and CarRepository . For this we need to use TestClientFactory to build them in isolation from the application since we are writing unit test. Looking at the car module we scaffolded earlier, there is a tests folder provided and inside that folder there is test_controllers.py module. We are going to be writing unit test for CarController in there. # project_name/car/tests/test_controllers.py from project_name.apps.car.controllers import CarController from project_name.apps.car.schemas import CreateCarSerializer , CarListFilter from project_name.apps.car.services import CarRepository class TestCarController : def setup ( self ): self . controller : CarController = CarController ( repo = CarRepository ()) async def test_create_action ( self , anyio_backend ): result = await self . controller . create ( CreateCarSerializer ( name = \"Mercedes\" , year = 2022 , model = \"CLS\" ) ) assert result == { \"id\" : \"1\" , \"message\" : \"This action adds a new car\" , \"model\" : \"CLS\" , \"name\" : \"Mercedes\" , \"year\" : 2022 , } In example above, we aren't really testing anything Ellar-specific. Notice that we are not using dependency injection; rather, we pass an instance of CarController to our CarRepository . This type of testing, where we manually instantiate the classes being tested, is commonly referred to as isolated testing because it is framework-independent","title":"Unit testing"},{"location":"basics/testing/#using-test-factory","text":"Test factory function in ellar.testing package, is a great tool employ for a quick and better test setup. Let's rewrite the previous example using the built-in Test class: # project_name/car/tests/test_controllers.py from unittest.mock import patch from ellar.di import ProviderConfig from ellar.testing import Test from project_name.apps.car.controllers import CarController from project_name.apps.car.schemas import CreateCarSerializer , CarListFilter from project_name.apps.car.services import CarRepository class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )] ) self . controller : CarController = test_module . get ( CarController ) async def test_create_action ( self , anyio_backend ): result = await self . controller . create ( CreateCarSerializer ( name = \"Mercedes\" , year = 2022 , model = \"CLS\" ) ) assert result == { \"id\" : \"1\" , \"message\" : \"This action adds a new car\" , \"model\" : \"CLS\" , \"name\" : \"Mercedes\" , \"year\" : 2022 , } @patch . object ( CarRepository , 'get_all' , return_value = [ dict ( id = 2 , model = 'CLS' , name = 'Mercedes' , year = 2023 )]) async def test_get_all_action ( self , mock_get_all , anyio_backend ): result = await self . controller . get_all ( query = CarListFilter ( offset = 0 , limit = 10 )) assert result == { 'cars' : [ { 'id' : 2 , 'model' : 'CLS' , 'name' : 'Mercedes' , 'year' : 2023 } ], 'message' : 'This action returns all cars at limit=10, offset=0' } With the Test class, you can create an application execution context that simulates the entire Ellar runtime, providing hooks to easily manage class instances by allowing for mocking and overriding. The Test class has a create_test_module() method that takes a module metadata object as its argument (the same object you pass to the @Module() decorator). This method returns a TestingModule instance which in turn provides a few methods: override_provider : Essential for overriding providers or guards with a mocked type. create_application : This method will return an application instance for the isolated testing module. get_test_client : creates and return a TestClient for the application which will allow you to make requests against your application, using the httpx library.","title":"Using Test Factory"},{"location":"basics/testing/#overriding-providers","text":"TestingModule override_provider method allows you to provide an alternative for a provider type or a guard type. For example: from ellar.testing import Test class MockCarRepository ( CarRepository ): pass class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,] ) . override_provider ( CarRepository , use_class = MockCarRepository ) override_provider takes the same arguments as ellar.di.ProviderConfig and in fact, it builds to ProvideConfig behind the scenes. In example above, we created a MockCarRepository for CarRepository and applied it as shown above. We can also create an instance of MockCarRepository and have it behave as a singleton within the scope of test_module instance. from ellar.testing import Test class MockCarRepository ( CarRepository ): pass class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,] ) . override_provider ( CarRepository , use_value = MockCarRepository ()) We this, anywhere CarRepository is needed, a MockCarRepository() instance will be applied. In same way, we can override UseGuards used in controllers during testing. For example, lets assume CarController has a guard JWTGuard import typing from ellar.common.compatible import AttributeDict from ellar.common import UseGuards , Controller , ControllerBase from ellar.core.guard import HttpBearerAuth from ellar.di import injectable @injectable () class JWTGuard ( HttpBearerAuth ): async def authenticate ( self , connection , credentials ) -> typing . Any : # JWT verification goes here return AttributeDict ( is_authenticated = True , first_name = 'Ellar' , last_name = 'ASGI Framework' ) @UseGuards ( JWTGuard ) @Controller ( '/car' ) class CarController ( ControllerBase ): ... During testing, we can replace JWTGuard with a MockAuthGuard as shown below. from ellar.testing import Test from .controllers import CarController , JWTGuard class MockAuthGuard ( JWTGuard ): async def authenticate ( self , connection , credentials ) -> typing . Any : # Jwt verification goes here. return dict ( first_name = 'Ellar' , last_name = 'ASGI Framework' ) class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,] ) . override_provider ( JWTGuard , use_class = MockAuthGuard )","title":"Overriding Providers"},{"location":"basics/testing/#create-application","text":"We can access the application instance after setting up the TestingModule . You simply need to call create_application method of the TestingModule . For example: from ellar.di import ProviderConfig from ellar.testing import Test class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )] ) app = test_module . create_application () car_repo = app . injector . get ( CarRepository ) assert isinstance ( car_repo , CarRepository )","title":"Create Application"},{"location":"basics/testing/#overriding-application-conf-during-testing","text":"Having different application configurations for different environments is a best practice in software development. It involves creating different sets of configuration variables, such as database connection details, API keys, and environment-specific settings, for different environments such as development, staging, and production. During testing, there two ways to apply or modify configuration. In a file Inline In config.py file, we can define another configuration for testing eg, class TestConfiguration and then we can apply it to config_module when creating TestingModule . For example: # project_name/config.py ... class BaseConfig ( ConfigDefaultTypesMixin ): DEBUG : bool = False class TestingConfiguration ( BaseConfig ): DEBUG = True ANOTHER_CONFIG_VAR = 'Ellar' We have created TestingConfiguration inside project_name.config python module. Lets apply this to TestingModule. # project_name/car/tests/test_controllers.py class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )], config_module = 'project_name.config:TestingConfiguration' ) self . controller : CarController = test_module . get ( CarController ) Also, we can expose the testing config to environment for more global scope, for example: # project_name/tests/conftest.py import os from ellar.constants import ELLAR_CONFIG_MODULE os . environ . setdefault ( ELLAR_CONFIG_MODULE , 'project_name.config:TestingConfiguration' ) This method doesn't require configuration file, we simply go ahead and define the configuration variables in a dictionary type set to config_module . For instance: # project_name/car/tests/test_controllers.py class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = CarRepository )], config_module = dict ( DEBUG = True , ANOTHER_CONFIG_VAR = 'Ellar' ) ) self . controller : CarController = test_module . get ( CarController )","title":"Overriding Application Conf During Testing"},{"location":"basics/testing/#end-to-end-test","text":"End-to-end (e2e) testing operates on a higher level of abstraction than unit testing, assessing the interaction between classes and modules in a way that approximates user behavior with the production system. As an application expands, manual e2e testing of every API endpoint becomes increasingly difficult, which is where automated e2e testing becomes essential in validating that the system's overall behavior is correct and aligned with project requirements. To execute e2e tests, we adopt a similar configuration to that of unit testing, and Ellar's use of TestClient , a tool provided by Starlette, to facilitates the simulation of HTTP requests","title":"End-to-End Test"},{"location":"basics/testing/#testclient","text":"Starlette provides a TestClient for making requests ASGI Applications, and it's based on httpx library similar to requests. from starlette.responses import HTMLResponse from starlette.testclient import TestClient async def app ( scope , receive , send ): assert scope [ 'type' ] == 'http' response = HTMLResponse ( '<html><body>Hello, world!</body></html>' ) await response ( scope , receive , send ) def test_app (): client = TestClient ( app ) response = client . get ( '/' ) assert response . status_code == 200 In example above, TestClient needs an ASGI Callable. It exposes the same interface as any other httpx session. In particular, note that the calls to make a request are just standard function calls, not awaitable. Let's see how we can use TestClient in writing e2e testing for CarController and CarRepository . # project_name/car/tests/test_controllers.py from ellar.di import ProviderConfig from ellar.testing import Test , TestClient from project_name.apps.car.controllers import CarController from project_name.apps.car.services import CarRepository class MockCarRepository ( CarRepository ): def get_all ( self ): return [ dict ( id = 2 , model = 'CLS' , name = 'Mercedes' , year = 2023 )] class TestCarControllerE2E : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], providers = [ ProviderConfig ( CarRepository , use_class = MockCarRepository )], config_module = dict ( REDIRECT_SLASHES = True ) ) self . client : TestClient = test_module . get_test_client () def test_create_action ( self ): res = self . client . post ( '/car' , json = dict ( name = \"Mercedes\" , year = 2022 , model = \"CLS\" )) assert res . status_code == 200 assert res . json () == { \"id\" : \"1\" , \"message\" : \"This action adds a new car\" , \"model\" : \"CLS\" , \"name\" : \"Mercedes\" , \"year\" : 2022 , } def test_get_all_action ( self ): res = self . client . get ( '/car?offset=0&limit=10' ) assert res . status_code == 200 assert res . json () == { 'cars' : [ { 'id' : 2 , 'model' : 'CLS' , 'name' : 'Mercedes' , 'year' : 2023 } ], 'message' : 'This action returns all cars at limit=10, offset=0' } In the construct above, test_module.get_test_client() created an isolated application instance and used it to instantiate a TestClient . And with we are able to simulate request behaviour on CarController .","title":"TestClient"},{"location":"cli/command-grouping/","text":"Command Grouping \u00b6 Ella CLI provides a way by which commands can be grouped. For instance, a db command may have sub-commands like makemigrations , migrate , reset-db etc. To achieve this use-case, let us create a file commands.py in the root level of the project. from ellar.common import EllarTyper db = EllarTyper ( name = \"db\" ) @db . command ( name = \"make-migrations\" ) def makemigrations (): \"\"\"Create DB Migration \"\"\" @db . command () def migrate (): \"\"\"Applies Migrations\"\"\" Register EllarTyper Command \u00b6 Lets, make the db visible on the CLI. In other for Ellar CLI to identify custom command, its has to be registered to a @Module class. from ellar.common import Module from ellar.core import ModuleBase from .commands import db @Module ( commands = [ db ]) class ApplicationModule ( ModuleBase ): pass open your terminal and navigate to project directory and run the command below ellar db --help command output Usage: Ellar, Python Web framework db [ OPTIONS ] COMMAND [ ARGS ] ... Options: --help Show this message and exit. Commands: make-migrations Create DB Migration migrate Applies Migrations","title":"Command Grouping"},{"location":"cli/command-grouping/#command-grouping","text":"Ella CLI provides a way by which commands can be grouped. For instance, a db command may have sub-commands like makemigrations , migrate , reset-db etc. To achieve this use-case, let us create a file commands.py in the root level of the project. from ellar.common import EllarTyper db = EllarTyper ( name = \"db\" ) @db . command ( name = \"make-migrations\" ) def makemigrations (): \"\"\"Create DB Migration \"\"\" @db . command () def migrate (): \"\"\"Applies Migrations\"\"\"","title":"Command Grouping"},{"location":"cli/command-grouping/#register-ellartyper-command","text":"Lets, make the db visible on the CLI. In other for Ellar CLI to identify custom command, its has to be registered to a @Module class. from ellar.common import Module from ellar.core import ModuleBase from .commands import db @Module ( commands = [ db ]) class ApplicationModule ( ModuleBase ): pass open your terminal and navigate to project directory and run the command below ellar db --help command output Usage: Ellar, Python Web framework db [ OPTIONS ] COMMAND [ ARGS ] ... Options: --help Show this message and exit. Commands: make-migrations Create DB Migration migrate Applies Migrations","title":"Register EllarTyper Command"},{"location":"cli/create-module-command/","text":"Create Module Command \u00b6 This command helps you create an Ellar project module, like a small app within a project. It depends on the existence of an Ellar project. ellar create-module my_project_module directory for example: ellar create-module my_project_module apps/ will create a folder as follows: john_doe/ \u251c\u2500 apps/ \u2502 \u251c\u2500 my_project_module/ \u2502 \u2502 \u251c\u2500 tests/ \u2502 \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u2502 \u251c\u2500 controllers.py \u2502 \u2502 \u251c\u2500 module.py \u2502 \u2502 \u251c\u2500 routers.py \u2502 \u2502 \u251c\u2500 services.py \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 core/ \u251c\u2500 domain/ \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 __init__.py/ \u251c\u2500 config.py \u251c\u2500 root_module.py dsssss cxccccccxxcxxnew_file \u251c\u2500 server.py New Command CLI Arguments \u00b6 module-name Set the resulting module name. directory Path to dump the scaffolded files. . can be used to select current directory.","title":"create module"},{"location":"cli/create-module-command/#create-module-command","text":"This command helps you create an Ellar project module, like a small app within a project. It depends on the existence of an Ellar project. ellar create-module my_project_module directory for example: ellar create-module my_project_module apps/ will create a folder as follows: john_doe/ \u251c\u2500 apps/ \u2502 \u251c\u2500 my_project_module/ \u2502 \u2502 \u251c\u2500 tests/ \u2502 \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u2502 \u251c\u2500 controllers.py \u2502 \u2502 \u251c\u2500 module.py \u2502 \u2502 \u251c\u2500 routers.py \u2502 \u2502 \u251c\u2500 services.py \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 core/ \u251c\u2500 domain/ \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 __init__.py/ \u251c\u2500 config.py \u251c\u2500 root_module.py dsssss cxccccccxxcxxnew_file \u251c\u2500 server.py","title":"Create Module Command"},{"location":"cli/create-module-command/#new-command-cli-arguments","text":"module-name Set the resulting module name. directory Path to dump the scaffolded files. . can be used to select current directory.","title":"New Command CLI Arguments"},{"location":"cli/create-project-command/","text":"Create Project Command \u00b6 This command helps you create just an Ellar project provided the \"pyproject.toml\" file exists in the working directory( CWD ) ellar create-project my_new_project directory for example: ellar create-project my_new_project will create a folder as follows: my_new_project/ \u251c\u2500 apps/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 core/ \u251c\u2500 config.py \u251c\u2500 domain \u251c\u2500 root_module.py \u251c\u2500 server.py \u251c\u2500 __init__.py Create Project Command Arguments \u00b6 project-name Set the resulting project module name. directory Path to dump the scaffolded files. . can be used to select current directory.","title":"create project"},{"location":"cli/create-project-command/#create-project-command","text":"This command helps you create just an Ellar project provided the \"pyproject.toml\" file exists in the working directory( CWD ) ellar create-project my_new_project directory for example: ellar create-project my_new_project will create a folder as follows: my_new_project/ \u251c\u2500 apps/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 core/ \u251c\u2500 config.py \u251c\u2500 domain \u251c\u2500 root_module.py \u251c\u2500 server.py \u251c\u2500 __init__.py","title":"Create Project Command"},{"location":"cli/create-project-command/#create-project-command-arguments","text":"project-name Set the resulting project module name. directory Path to dump the scaffolded files. . can be used to select current directory.","title":"Create Project Command Arguments"},{"location":"cli/custom-commands/","text":"Custom Commands \u00b6 In this section, we are going to go over how to create a custom command and throw more light on how Ella CLI works. Create Custom Command \u00b6 Let's create a file called commands.py at the root level of the project. # project_name/commands.py from ellar.common import command @command def my_new_command (): \"\"\"my_new_command cli description \"\"\" Custom Command with Context \u00b6 Ellar CLI tools is a wrapper round typer . So, therefore, we can easily get the command context by adding a parameter with the annotation of typer.Context Ellar CLI adds some meta-data CLI context that provides an interface for interaction with the Ellar project. For example: import typing as t import typer from ellar.common import command from ellar_cli.service import EllarCLIService from ellar_cli.constants import ELLAR_META @command def my_new_command ( ctx : typer . Context ): \"\"\"my_new_command CLI Description \"\"\" ellar_cli_service = t . cast ( t . Optional [ EllarCLIService ], ctx . meta . get ( ELLAR_META )) app = ellar_cli_service . import_application () EllarCLIService is an Ellar CLI meta-data for interacting with Ellar project. Some important method that may be of interest: import_application : returns application instance. get_application_config : gets current application config. Register a Custom Command \u00b6 Lets, make the my_new_command visible on the CLI. In other for Ellar CLI to identify custom command, its has to be registered to a @Module class. For example: # project_name/root_module.py from ellar.common import Module from ellar.core import ModuleBase from .commands import my_new_command @Module ( commands = [ my_new_command ]) class ApplicationModule ( ModuleBase ): pass open your terminal and navigate to project directory and run the command below ellar --help command output Usage: Ellar, Python Web framework [ OPTIONS ] COMMAND [ ARGS ] ... Options: -p, --project TEXT Run Specific Command on a specific project --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: create-module - Scaffolds Ellar Application Module - create-project - Scaffolds Ellar Application - my-new-command - my_new_command cli description new - Runs a complete Ellar project scaffold and creates... runserver - Starts Uvicorn Server - say-hi","title":"Custom Commands"},{"location":"cli/custom-commands/#custom-commands","text":"In this section, we are going to go over how to create a custom command and throw more light on how Ella CLI works.","title":"Custom Commands"},{"location":"cli/custom-commands/#create-custom-command","text":"Let's create a file called commands.py at the root level of the project. # project_name/commands.py from ellar.common import command @command def my_new_command (): \"\"\"my_new_command cli description \"\"\"","title":"Create Custom Command"},{"location":"cli/custom-commands/#custom-command-with-context","text":"Ellar CLI tools is a wrapper round typer . So, therefore, we can easily get the command context by adding a parameter with the annotation of typer.Context Ellar CLI adds some meta-data CLI context that provides an interface for interaction with the Ellar project. For example: import typing as t import typer from ellar.common import command from ellar_cli.service import EllarCLIService from ellar_cli.constants import ELLAR_META @command def my_new_command ( ctx : typer . Context ): \"\"\"my_new_command CLI Description \"\"\" ellar_cli_service = t . cast ( t . Optional [ EllarCLIService ], ctx . meta . get ( ELLAR_META )) app = ellar_cli_service . import_application () EllarCLIService is an Ellar CLI meta-data for interacting with Ellar project. Some important method that may be of interest: import_application : returns application instance. get_application_config : gets current application config.","title":"Custom Command with Context"},{"location":"cli/custom-commands/#register-a-custom-command","text":"Lets, make the my_new_command visible on the CLI. In other for Ellar CLI to identify custom command, its has to be registered to a @Module class. For example: # project_name/root_module.py from ellar.common import Module from ellar.core import ModuleBase from .commands import my_new_command @Module ( commands = [ my_new_command ]) class ApplicationModule ( ModuleBase ): pass open your terminal and navigate to project directory and run the command below ellar --help command output Usage: Ellar, Python Web framework [ OPTIONS ] COMMAND [ ARGS ] ... Options: -p, --project TEXT Run Specific Command on a specific project --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: create-module - Scaffolds Ellar Application Module - create-project - Scaffolds Ellar Application - my-new-command - my_new_command cli description new - Runs a complete Ellar project scaffold and creates... runserver - Starts Uvicorn Server - say-hi","title":"Register a Custom Command"},{"location":"cli/introduction/","text":"Ellar CLI \u00b6 Ellar CLI is an abstracted tool for the Ellar web framework that helps in the standard project scaffold of the framework, module project scaffold, running the project local server using UVICORN, and running custom commands registered in the application module or any Ellar module. Installation \u00b6 if you have ellar install ready pip install ellar-cli Usage \u00b6 To verify ellar-cli is working, run the command belove ellar --help Above command should output this: Usage: Ellar, Python Web framework [OPTIONS] COMMAND [ARGS]... Options: -p, --project TEXT Run Specific Command on a specific project --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: create-module - Scaffolds Ellar Application Module - create-project - Scaffolds Ellar Application - new - Runs a complete Ellar project scaffold and creates... runserver - Starts Uvicorn Server - say-hi","title":"Introduction"},{"location":"cli/introduction/#ellar-cli","text":"Ellar CLI is an abstracted tool for the Ellar web framework that helps in the standard project scaffold of the framework, module project scaffold, running the project local server using UVICORN, and running custom commands registered in the application module or any Ellar module.","title":"Ellar CLI"},{"location":"cli/introduction/#installation","text":"if you have ellar install ready pip install ellar-cli","title":"Installation"},{"location":"cli/introduction/#usage","text":"To verify ellar-cli is working, run the command belove ellar --help Above command should output this: Usage: Ellar, Python Web framework [OPTIONS] COMMAND [ARGS]... Options: -p, --project TEXT Run Specific Command on a specific project --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: create-module - Scaffolds Ellar Application Module - create-project - Scaffolds Ellar Application - new - Runs a complete Ellar project scaffold and creates... runserver - Starts Uvicorn Server - say-hi","title":"Usage"},{"location":"cli/new-command/","text":"Create New Project Command \u00b6 This command will help you kickstart your new Ellar project. It creates a new project for you with a directory structure and adds all required files for Ellar CLI to properly manage your project. ellar new my-project will create a folder as follows: my-project/ \u251c\u2500 my_project/ \u2502 \u251c\u2500 apps/ \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u251c\u2500 core/ \u2502 \u251c\u2500 config.py \u2502 \u251c\u2500 domain \u2502 \u251c\u2500 root_module.py \u2502 \u251c\u2500 server.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 pyproject.toml \u251c\u2500 README.md If you want to name your project differently than the folder, you can pass the --project-name option. ellar new my-project path/to/scaffold-the-new-project will create a folder as follows: path/to/scaffold-the-new-project/ \u251c\u2500 my_project/ \u2502 \u251c\u2500 apps/ \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u251c\u2500 core/ \u2502 \u251c\u2500 config.py \u2502 \u251c\u2500 domain \u2502 \u251c\u2500 root_module.py \u2502 \u251c\u2500 server.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 pyproject.toml \u251c\u2500 README.md New Command CLI Arguments \u00b6 project-name Set the resulting project module name. directory Path to dump the scaffolded files. . can be used to select current directory.","title":"new"},{"location":"cli/new-command/#create-new-project-command","text":"This command will help you kickstart your new Ellar project. It creates a new project for you with a directory structure and adds all required files for Ellar CLI to properly manage your project. ellar new my-project will create a folder as follows: my-project/ \u251c\u2500 my_project/ \u2502 \u251c\u2500 apps/ \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u251c\u2500 core/ \u2502 \u251c\u2500 config.py \u2502 \u251c\u2500 domain \u2502 \u251c\u2500 root_module.py \u2502 \u251c\u2500 server.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 pyproject.toml \u251c\u2500 README.md If you want to name your project differently than the folder, you can pass the --project-name option. ellar new my-project path/to/scaffold-the-new-project will create a folder as follows: path/to/scaffold-the-new-project/ \u251c\u2500 my_project/ \u2502 \u251c\u2500 apps/ \u2502 \u2502 \u251c\u2500 __init__.py \u2502 \u251c\u2500 core/ \u2502 \u251c\u2500 config.py \u2502 \u251c\u2500 domain \u2502 \u251c\u2500 root_module.py \u2502 \u251c\u2500 server.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 pyproject.toml \u251c\u2500 README.md","title":"Create New Project Command"},{"location":"cli/new-command/#new-command-cli-arguments","text":"project-name Set the resulting project module name. directory Path to dump the scaffolded files. . can be used to select current directory.","title":"New Command CLI Arguments"},{"location":"cli/runserver-command/","text":"Runserver Command \u00b6 This is command is a wrapper around the UVICORN ASGI server. It helps to create a link necessary for UVICORN to run your Ellar application properly. ellar runserver --reload will product the following output: INFO: Will watch for changes in these directories: [ '/home/user/working-directory' ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) INFO: Started reloader process [ 2934815 ] using WatchFiles INFO: APP SETTINGS MODULE: john_doe.config:DevelopmentConfig INFO: Started server process [ 2934818 ] INFO: Waiting for application startup. INFO: Application startup complete. Runserver CLI Options \u00b6 ellar runserver --help OR Please check Uvicorn CLI Options","title":"runserver"},{"location":"cli/runserver-command/#runserver-command","text":"This is command is a wrapper around the UVICORN ASGI server. It helps to create a link necessary for UVICORN to run your Ellar application properly. ellar runserver --reload will product the following output: INFO: Will watch for changes in these directories: [ '/home/user/working-directory' ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) INFO: Started reloader process [ 2934815 ] using WatchFiles INFO: APP SETTINGS MODULE: john_doe.config:DevelopmentConfig INFO: Started server process [ 2934818 ] INFO: Waiting for application startup. INFO: Application startup complete.","title":"Runserver Command"},{"location":"cli/runserver-command/#runserver-cli-options","text":"ellar runserver --help OR Please check Uvicorn CLI Options","title":"Runserver CLI Options"},{"location":"overview/controllers/","text":"Controllers \u00b6 The Controller is responsible for handling incoming requests and returning responses to the client. The purpose of a controller is to receive specific requests for an application ApplicationRouter . ApplicationRouter on the other hand, decides which controller should handle an incoming request. Controllers can be said to be a router with many routes registered in them. Creating a Controller \u00b6 To create a controller, we use classes and decorators. The Controller decorator associates classes with a required metadata needed for Ellar to create a routing table from ellar.common import Controller , ControllerBase @Controller () class UserController ( ControllerBase ): \"\"\"We have created a controller that will manage our Users\"\"\" Routing \u00b6 In this section, we are going to highlight key features of the @Controller() , a class decorator for defining a controller. By default, @Controller() will create a path prefix /car gotten from the class name in Car Controller. This will be used to group related routes and minimize duplicate route definitions. For example, we may choose to group a set of routes that manage interactions with a customer entity under the route /user . In that case, we could specify the path prefix /user in the @Controller() decorator so we don't have to repeat that portion of the path for each route in the controller. # project_name/apps/car/controllers.py from ellar.common import Controller , get , ControllerBase @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self ): return 'This action returns all car' @get ( \"/welcome\" ) def index ( self ): return { \"detail\" : \"Welcome to Car Resource\" } Hint Class Decorators name are capitalized while function/method decorator name are in lower case The @get() HTTP method decorator before the get_all(self) method marks get_all(self) as the HTTP request handler that will handle a specific endpoint matching the route path and HTTP method of GET . But what then is the route path of get_all(self) ? The route path is determined by concatenating the controller path prefix and the path specified in the HTTP method function decorator @get() . For example, we've declared a prefix for every route (car) , and haven't added any path information in the decorator, which means the path will default to / . In that case, Ellar will map GET /car/ requests to the get_all(self) handler. Another example to help make things clear, a path prefix of /users combined with the decorator @get('/profile') would produce a route mapping for requests like GET /users/profile . Overview of HTTP function decorator parameters: \u00b6 @get(path: str, name: str, include_in_schema: bool, response: t.Union[t.Dict[int, t.Type], t.List[t.Tuple[int, t.Type]], t.Type]) path : defines the path for route mapping. default='/' name : defines a name that will be used to identify this route during URL reversing. default is function name eg: get_all include_in_schema : indicates if an endpoint should be available in OPENAPI docs response : defines different response schema , status code , and Response type that is available on the endpoint. This is only necessary for OPENAPI documentation. default: None Ellar serializes all route handler returned data to JSON unless the data returned is a Response object. For the above example, get_all returned a string. This will be serialized to JSON with a status code 200. Request Object \u00b6 There are different ways handlers can access client request details: Annotation ( parameter_name:Request ) \u00b6 Ellar will resolve any parameter annotated as Request in the request handler signature as a Request object. # project_name/apps/car/controllers.py from ellar.common import Controller , get , ControllerBase from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self , request : Request ): assert isinstance ( request , Request ) # True return 'This action returns all cars' ... injection ( parameter_name=Req() ) \u00b6 We can also inject request object to any handler by using @Req decorator in handler signature. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get , Req from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self , req_data : Request , req_data_2 = Req ()): assert isinstance ( req_data , Request ) # True assert isinstance ( req_data_2 , Request ) assert req_data == req_data_2 return 'This action returns all cars' ... Controllers Context \u00b6 During request handler execution, Execution Context is available on the Controller instance and the request object can be gotten from the context. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self ): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return 'This action returns all cars' ... Other request handler signature injectors Req() for Request object Res() for Response object Path() pydantic field - resolves path parameters Body() pydantic field - resolves required Request body parameters Form() pydantic field - resolves required Request body parameters with content-type= x-www-form-urlencoded Header() pydantic field - resolves required Request header parameters Query() pydantic field - resolves required Request query parameters File() pydantic field - resolves required Request body parameters with content-type= x-www-form-urlencoded Ctx() Injects ExecutionContext . Cookie() pydantic field - resolves required Request cookie parameters Session() injects Request session data Host() injects Request clients host Provide() injects services Resource \u00b6 Let add create endpoint to our CarController resource. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get , post from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @post () def create ( self ): return 'This action adds a new car' @get () def get_all ( self ): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return 'This action returns all cars' ... HTTP Methods \u00b6 Ellar provides decorators for all the standard HTTP methods: @get - GET HTTP method @post - POST HTTP method @put - PUT HTTP method @patch - PATCH HTTP method @delete - DELETE HTTP method @trace - TRACE HTTP method @options - OPTIONS HTTP method @head - HEAD HTTP method @http_route - allows one or more HTTP methods combination, eg: @http_route(methods=['PUT', 'PATCH']) Asynchronicity \u00b6 Ellar supports modern asynchronous programming in python using async and await syntax. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get , post from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @post () async def create ( self ): return 'This action adds a new car' @get () async def get_all ( self ): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return 'This action returns all cars' ... Request Payload \u00b6 Let's use @Body() to define the required data to create a car in our previous create (POST) endpoint. Before that, we need to define our data input/output serializers # project_name/apps/car/schema.py from ellar.common import Serializer from pydantic import Field class CreateCarSerializer ( Serializer ): name : str year : int = Field ( ... , gt = 0 ) model : str class CarListFilter ( Serializer ): offset : int = 1 limit : int = 10 class CarSerializer ( Serializer ): id : str name : str year : int model : str Let's add the CreateCarSerializer to create endpoint, # project_name/apps/car/controllers.py ... from ellar.common import Body , post from .schemas import CreateCarSerializer @post () async def create ( self , payload : CreateCarSerializer = Body ()): return 'This action adds a new car' CreateCarSerializer is a pydantic type. These means name , year and model fields are type validated out of the box. It's important to note the way we used CreateCarSerializer as a type annotation of the payload parameter in the create route handler method. Ellar will compute values for all the route handler parameters and validates them based on the annotated types before executing the handler. Info if a parameter is not annotated, it will be assumed as a string type Let's add other endpoints # project_name/apps/car/controllers.py from ellar.common import Body , Controller , ControllerBase , delete , get , post , put , Query from ellar.core import Request from .schemas import CreateCarSerializer , CarListFilter @Controller ( '/car' ) class CarController ( ControllerBase ): @post () async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result @put ( '/{car_id:str}' ) async def update ( self , car_id : str , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = f 'This action updated # { car_id } car resource' ) return result @get ( '/{car_id:str}' ) async def get_one ( self , car_id : str ): return f \"This action returns a # { car_id } car\" @delete ( '/{car_id:str}' ) async def delete ( self , car_id : str ): return f \"This action removes a # { car_id } car\" @get () async def get_all ( self , query : CarListFilter = Query ()): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return f 'This action returns all cars at limit= { query . limit } , offset= { query . offset } ' Linking Controller \u00b6 In the previous page, we already wired our car module ( CarModule ) to ApplicationModule in project_name/root_module but this time we shall be adding things to the CarModule . To keep things more simple, organized, and modular. Let's register CarController to CarModule . @Module() takes controllers as a parameter which is an array of the ControllerBase type. In the car/module.py , # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .controllers import CarController @Module ( controllers = [ CarController ], providers = [], routers = [], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass","title":"Controllers"},{"location":"overview/controllers/#controllers","text":"The Controller is responsible for handling incoming requests and returning responses to the client. The purpose of a controller is to receive specific requests for an application ApplicationRouter . ApplicationRouter on the other hand, decides which controller should handle an incoming request. Controllers can be said to be a router with many routes registered in them.","title":"Controllers"},{"location":"overview/controllers/#creating-a-controller","text":"To create a controller, we use classes and decorators. The Controller decorator associates classes with a required metadata needed for Ellar to create a routing table from ellar.common import Controller , ControllerBase @Controller () class UserController ( ControllerBase ): \"\"\"We have created a controller that will manage our Users\"\"\"","title":"Creating a Controller"},{"location":"overview/controllers/#routing","text":"In this section, we are going to highlight key features of the @Controller() , a class decorator for defining a controller. By default, @Controller() will create a path prefix /car gotten from the class name in Car Controller. This will be used to group related routes and minimize duplicate route definitions. For example, we may choose to group a set of routes that manage interactions with a customer entity under the route /user . In that case, we could specify the path prefix /user in the @Controller() decorator so we don't have to repeat that portion of the path for each route in the controller. # project_name/apps/car/controllers.py from ellar.common import Controller , get , ControllerBase @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self ): return 'This action returns all car' @get ( \"/welcome\" ) def index ( self ): return { \"detail\" : \"Welcome to Car Resource\" } Hint Class Decorators name are capitalized while function/method decorator name are in lower case The @get() HTTP method decorator before the get_all(self) method marks get_all(self) as the HTTP request handler that will handle a specific endpoint matching the route path and HTTP method of GET . But what then is the route path of get_all(self) ? The route path is determined by concatenating the controller path prefix and the path specified in the HTTP method function decorator @get() . For example, we've declared a prefix for every route (car) , and haven't added any path information in the decorator, which means the path will default to / . In that case, Ellar will map GET /car/ requests to the get_all(self) handler. Another example to help make things clear, a path prefix of /users combined with the decorator @get('/profile') would produce a route mapping for requests like GET /users/profile .","title":"Routing"},{"location":"overview/controllers/#overview-of-http-function-decorator-parameters","text":"@get(path: str, name: str, include_in_schema: bool, response: t.Union[t.Dict[int, t.Type], t.List[t.Tuple[int, t.Type]], t.Type]) path : defines the path for route mapping. default='/' name : defines a name that will be used to identify this route during URL reversing. default is function name eg: get_all include_in_schema : indicates if an endpoint should be available in OPENAPI docs response : defines different response schema , status code , and Response type that is available on the endpoint. This is only necessary for OPENAPI documentation. default: None Ellar serializes all route handler returned data to JSON unless the data returned is a Response object. For the above example, get_all returned a string. This will be serialized to JSON with a status code 200.","title":"Overview of HTTP function decorator parameters:"},{"location":"overview/controllers/#request-object","text":"There are different ways handlers can access client request details:","title":"Request Object"},{"location":"overview/controllers/#annotation-parameter_namerequest","text":"Ellar will resolve any parameter annotated as Request in the request handler signature as a Request object. # project_name/apps/car/controllers.py from ellar.common import Controller , get , ControllerBase from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self , request : Request ): assert isinstance ( request , Request ) # True return 'This action returns all cars' ...","title":"Annotation (parameter_name:Request)"},{"location":"overview/controllers/#injection-parameter_namereq","text":"We can also inject request object to any handler by using @Req decorator in handler signature. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get , Req from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self , req_data : Request , req_data_2 = Req ()): assert isinstance ( req_data , Request ) # True assert isinstance ( req_data_2 , Request ) assert req_data == req_data_2 return 'This action returns all cars' ...","title":"injection (parameter_name=Req())"},{"location":"overview/controllers/#controllers-context","text":"During request handler execution, Execution Context is available on the Controller instance and the request object can be gotten from the context. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @get () def get_all ( self ): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return 'This action returns all cars' ... Other request handler signature injectors Req() for Request object Res() for Response object Path() pydantic field - resolves path parameters Body() pydantic field - resolves required Request body parameters Form() pydantic field - resolves required Request body parameters with content-type= x-www-form-urlencoded Header() pydantic field - resolves required Request header parameters Query() pydantic field - resolves required Request query parameters File() pydantic field - resolves required Request body parameters with content-type= x-www-form-urlencoded Ctx() Injects ExecutionContext . Cookie() pydantic field - resolves required Request cookie parameters Session() injects Request session data Host() injects Request clients host Provide() injects services","title":"Controllers Context"},{"location":"overview/controllers/#resource","text":"Let add create endpoint to our CarController resource. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get , post from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @post () def create ( self ): return 'This action adds a new car' @get () def get_all ( self ): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return 'This action returns all cars' ...","title":"Resource"},{"location":"overview/controllers/#http-methods","text":"Ellar provides decorators for all the standard HTTP methods: @get - GET HTTP method @post - POST HTTP method @put - PUT HTTP method @patch - PATCH HTTP method @delete - DELETE HTTP method @trace - TRACE HTTP method @options - OPTIONS HTTP method @head - HEAD HTTP method @http_route - allows one or more HTTP methods combination, eg: @http_route(methods=['PUT', 'PATCH'])","title":"HTTP Methods"},{"location":"overview/controllers/#asynchronicity","text":"Ellar supports modern asynchronous programming in python using async and await syntax. # project_name/apps/car/controllers.py from ellar.common import Controller , ControllerBase , get , post from ellar.core import Request @Controller ( '/car' ) class CarController ( ControllerBase ): @post () async def create ( self ): return 'This action adds a new car' @get () async def get_all ( self ): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return 'This action returns all cars' ...","title":"Asynchronicity"},{"location":"overview/controllers/#request-payload","text":"Let's use @Body() to define the required data to create a car in our previous create (POST) endpoint. Before that, we need to define our data input/output serializers # project_name/apps/car/schema.py from ellar.common import Serializer from pydantic import Field class CreateCarSerializer ( Serializer ): name : str year : int = Field ( ... , gt = 0 ) model : str class CarListFilter ( Serializer ): offset : int = 1 limit : int = 10 class CarSerializer ( Serializer ): id : str name : str year : int model : str Let's add the CreateCarSerializer to create endpoint, # project_name/apps/car/controllers.py ... from ellar.common import Body , post from .schemas import CreateCarSerializer @post () async def create ( self , payload : CreateCarSerializer = Body ()): return 'This action adds a new car' CreateCarSerializer is a pydantic type. These means name , year and model fields are type validated out of the box. It's important to note the way we used CreateCarSerializer as a type annotation of the payload parameter in the create route handler method. Ellar will compute values for all the route handler parameters and validates them based on the annotated types before executing the handler. Info if a parameter is not annotated, it will be assumed as a string type Let's add other endpoints # project_name/apps/car/controllers.py from ellar.common import Body , Controller , ControllerBase , delete , get , post , put , Query from ellar.core import Request from .schemas import CreateCarSerializer , CarListFilter @Controller ( '/car' ) class CarController ( ControllerBase ): @post () async def create ( self , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = 'This action adds a new car' ) return result @put ( '/{car_id:str}' ) async def update ( self , car_id : str , payload : CreateCarSerializer = Body ()): result = payload . dict () result . update ( message = f 'This action updated # { car_id } car resource' ) return result @get ( '/{car_id:str}' ) async def get_one ( self , car_id : str ): return f \"This action returns a # { car_id } car\" @delete ( '/{car_id:str}' ) async def delete ( self , car_id : str ): return f \"This action removes a # { car_id } car\" @get () async def get_all ( self , query : CarListFilter = Query ()): assert isinstance ( self . context . switch_to_http_connection () . get_request (), Request ) # True return f 'This action returns all cars at limit= { query . limit } , offset= { query . offset } '","title":"Request Payload"},{"location":"overview/controllers/#linking-controller","text":"In the previous page, we already wired our car module ( CarModule ) to ApplicationModule in project_name/root_module but this time we shall be adding things to the CarModule . To keep things more simple, organized, and modular. Let's register CarController to CarModule . @Module() takes controllers as a parameter which is an array of the ControllerBase type. In the car/module.py , # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .controllers import CarController @Module ( controllers = [ CarController ], providers = [], routers = [], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass","title":"Linking Controller"},{"location":"overview/custom_decorators/","text":"Custom Decorators \u00b6 Ellar provides a variety of function decorators in the ellar.common python module that can be used to modify the behavior of route functions. These decorators can be used to change the response type of a route function, add filters to the response schema, define the OPENAPI context, and more. In general, these decorators can help to simplify and streamline the process of creating routes. HTTP Method Decorator \u00b6 @get , @post , @put , @patch , @delete , @trace , @options , @head are decorators that define the standard HTTP methods for a route function. They indicate the type of HTTP request that the route function can handle, such as a GET request or a POST request. @http_route is a decorator that can be used to define a route that can handle multiple HTTP methods at once. @ws_route is a decorator that is used to define a route that can handle WebSocket connections. These decorators help to specify which type of request a route function can handle. Route Function Parameters Decorators \u00b6 These decorators are Pydantic ModelField that can be used to define and validate the dependencies of route function parameters. They are used to ensure that the specified parameters are present in the request and are of the correct type. If any of the specified parameters are missing or are of an invalid type, the decorators will raise a 422 error code and also provide a clear error message if the input validation fails. This helps to ensure that the application is receiving valid input and can process the request correctly. Body(..., embed=False) Form(..., embed=True) Query(...) File(...) Path(...) Header(...) Cookie(...) Please refer to the \"How-to-Guide\" on parsing inputs here to see how this input decorators work. WsBody(..., embed=False) \u00b6 WsBody(...) is a decorator that defines the message format that should be transmitted from the client in a WebSocket when there is a successful connection. This decorator can be used to specify the structure of the message that is sent over the WebSocket, and to validate the message against a specified schema but for only use_extra_handler=True . For example: from ellar.common import WsBody , ws_route from ellar.core import WebSocket ... @ws_route ( '/websocket' , use_extra_handler = True ) def sample_endpoint_ws ( self , websocket : WebSocket , data_schema : str = WsBody ()): pass @ws_route . connect ( sample_endpoint_ws ) async def on_connect ( self , websocket : WebSocket ): # Called when there is a connection to `sample_endpoint_ws` await websocket . accept () @ws_route . disconnect ( sample_endpoint_ws ) async def on_disconnect ( self , websocket : WebSocket , code : int ): # Called when there is a disconnect from `sample_endpoint_ws` await websocket . close ( code ) Non Route Function Parameters Decorators \u00b6 We discussed decorators that are used to define route function parameter dependencies in Ellar. These decorators, such as Query , Form , and Body , etc. are pydantic models used to specify the expected parameters for a route function. However, there are also some route parameters that are system dependent, such as the request or websocket object, and the response object. These parameters are resolved by the application and supplied to the route function when needed, and are not specified with pydantic models or user input. Provide(Type) \u00b6 The Provide(Type) decorator is used to resolve a service provider and inject it into a route function parameter. This can be useful when using the ModuleRouter feature in Ellar. It allows for easy injection of services into route functions, making it easier to manage dependencies and improve code organization. This can be useful for resolving database connections, external APIs, or other resources that are used by the route function. For example: from ellar.common import ModuleRouter , Provide from ellar.core import App , Config router = ModuleRouter ( '/test-provide' ) @router . get ( '/app' ) def example_endpoint ( app : Provide ( App ), config : Provide ( Config )): assert isinstance ( app , App ) assert app . config == config assert isinstance ( config , Config ) return { 'message' : 'injected App and Configuration object to route function' } In the example above, example_endpoint function has two parameters app and config which are decorated with Provide(Type) decorator. This decorator tells the application to resolve the App and Config service providers and inject them as the app and config parameters when the endpoint is called. This allows for easy access to the objects without having to manually import and instantiate them. It also makes the code more modular and easier to test. Info Only types registered in the application can be resolved, but you can set INJECTOR_AUTO_BIND = True in configuration for the injector to register automatically that are not found. please note that this automatic registration will be scoped to singleton by the EllarInjector . Context \u00b6 The Context() decorator injects the current IExecutionContext to route function parameter. See ExecutionContext For example: from ellar.common import ModuleRouter , Context router = ModuleRouter ( '/test-context' ) @router . get ( '/' ) def example_endpoint ( ctx = Context ()): http_connection_instance = ctx . switch_to_http_connection () . get_client () query_params = http_connection_instance . query_params return { 'message' : 'inject execution context' , 'query_params' : query_params } In this example, the example_endpoint function is decorated with the Context() decorator, which injects the current IExecutionContext object into the ctx parameter of the function. The IExecutionContext object provides access to various resources and information related to the current execution context, such as the current HTTP connection, query parameters, and more. In this example, the switch_to_http_connection() method is used to access the current HTTP connection and the get_client() method is used to get the client object for the connection. The query_params attribute of the client object is then accessed and included in the response returned by the endpoint. Req \u00b6 Req() decorator injects current Request object to route function parameter. For example: from ellar.common import ModuleRouter , Req router = ModuleRouter ( '/test-req' ) @router . get ( '/' ) def example_endpoint ( req = Req ()): headers = req . headers query_params = req . query_params return { 'message' : 'injected request object' , 'headers' : headers , 'query_params' : query_params } In this example, the example_endpoint function has a parameter req decorated with Req() , which will be automatically populated with the current Request object at runtime. The headers and query_params attributes of the req object can then be accessed and used within the function. Res \u00b6 Res() decorator injects current Response object to route function parameter. For example: from ellar.common import ModuleRouter , Res router = ModuleRouter ( '/test-response' ) @router . get ( '/' ) def example_endpoint ( res = Res ()): res . headers [ 'x-custom-header' ] = 'hello' return { 'message' : 'inject response object' } In this example, the Res() decorator injects the current Response object to the res parameter of the example_endpoint function. This will allow you to manipulate the headers of the response before it is sent back to the client. Ws \u00b6 Ws() decorator injects current WebSocket object to route function parameter. For example: from ellar.common import ModuleRouter , Ws router = ModuleRouter ( '/test-ws' ) @router . ws_route ( '/' ) async def example_endpoint ( ws = Ws ()): await ws . accept () await ws . send_json ({ 'message' : 'injected WebSocket object to route function' }) The above code creates a WebSocket route '/test-ws' and when a client connects to this route, the example_endpoint function is executed. The Ws decorator injects the current WebSocket object to the ws parameter of the function, which can then be used to interact with the WebSocket connection, such as accepting the connection and sending data to the client. The same conditions and examples applies for: Host() decorator injects current client host address to route function parameter. Session() decorator injects current Session object to route function parameter. This requires SessionMiddleware module from Starlette added in application middleware and also SessionMiddleware module depends on itsdangerous package. Http() decorator injects current HTTP connection object to route function parameter. Creating a Custom Parameter Decorators \u00b6 You can still create your own route parameter decorators that suits your need. You simply need to follow a contract, NonParameterResolver , and override the resolve function. The NonParameterResolver has two attribute, type_annotation and parameter_name , that are provided automatically when computing route parameter dependencies. They are gotten from the application of the NonParameterResolver, like so - def s(parameter_name:type_annotation = NonParameterResolver()) . NonParameterResolver receives current IExecutionContext must return a tuple of dict object of the resulting resolve data with parameter_name and list of errors if any. As shown in the return statements in the example below. For example: import typing as t from ellar.common.params import NonParameterResolver from ellar.common import IExecutionContext from pydantic.error_wrappers import ErrorWrapper class UserParam ( NonParameterResolver ): async def resolve ( self , ctx : IExecutionContext , ** kwargs : t . Any ) -> t . Any : request = ctx . switch_to_http_connection () . get_request () user = request . get ( 'user' , None ) if user : return { self . parameter_name : user }, [] return {}, [ ErrorWrapper ( 'Authenticated Users Only' , loc = 'system' )] This example defines a custom decorator called UserParam that inherits from NonParameterResolver . The resolve method is overridden to extract the user from the current IExecutionContext 's request. If the user is found, it is returned as a dict with the key as the parameter_name of the decorator, along with an empty list of errors. If no user is found, an empty dict and a list of errors containing an ErrorWrapper object is returned. This UserParam decorator can then be used to inject the user object to a route function parameter like so: @router . get ( '/user' ) def example_endpoint ( user : UserParam ()): return { 'message' : 'injected user object to route function' , 'user' : user } Route Function Decorators \u00b6 These decorators are used to modify the output data of a route function, add filtering to the output schema, or add extra OPENAPI information about the route function. They include: RENDER \u00b6 @render() decorator converts a route function response to HTML template response. for example: from ellar.common import get , render ... @get ( '/index-template' ) @render ( template_name = 'my_template' ) def index ( self ): return { 'name' : 'Ellar Template' } In the example, the index function is decorated with the render decorator, which will return a 200 status code and HTML content from my_template. The return object from the index function will be used as the templating context for my_template during the template rendering process. This allows the function to pass data to the template and have it rendered with the provided context, the rendered template will be the response body. See HTML Templating for more information on render and HTML templating with Ellar. FILE \u00b6 @file() decorator converts a route function response to file or streaming response type. Based on the value of streaming parameter, file decorator creates FileResponseModel or StreamingResponseModel . FileResponseModel as file(streaming=False) \u00b6 When streaming parameter in @file(streaming=False) decorator is set to False , a FileResponseModel is created as the response model for the decorated route function. And the route function is required to return a dictionary object that follows a FileResponseModelSchema format: import typing as t from enum import Enum from ellar.common import Serializer class ContentDispositionType ( str , Enum ): inline = \"inline\" attachment = \"attachment\" class FileResponseModelSchema ( Serializer ): path : str media_type : t . Optional [ str ] = None filename : t . Optional [ str ] = None method : t . Optional [ str ] = None content_disposition_type : ContentDispositionType = ContentDispositionType . attachment path : This is a required key whose value defines the path to the file to attach to the response. filename : when specified, it will be used as the attached file's filename. The default value is computed from the file referenced. content_disposition_type : defines the content disposition type, can be either inline or attachment. The default is attachment. media_type : states the MIME type of the file to be attached. The default value is computed from the file referenced. method : HTTP method, defaults: HEAD for example: from ellar.common import get , file ... @get () @file ( media_type = 'text/html' , streaming = False ) def file_download ( self ): return { 'path' : 'path/to/file.html' , 'filename' : 'code.html' , 'content_disposition_type' : 'attachment' } In the example, an additional parameter media_type is added to the @file(streaming=False) decorator to define the content-type of the file returned. This is helpful for creating the route function's OPENAPI documentation, as it allows the content-type to be defined upfront. Without this parameter, the content-type will be computed during runtime when returning a response for a request. It is a way to explicitly define the content-type of the file which will be returned. StreamingResponseModel as file(streaming=True) \u00b6 On the other hand, when streaming parameter in @file(streaming=True) decorator is set to True , a StreamingResponseModel is created as the response model for the decorated route function. And the route function is required to return an ContentStream . ContentStream is an synchronous or asynchronous iterator of string or bytes. Type definition is shown below. import typing import asyncio from ellar.common import get , file Content = typing . Union [ str , bytes ] SyncContentStream = typing . Iterator [ Content ] AsyncContentStream = typing . AsyncIterable [ Content ] ContentStream = typing . Union [ AsyncContentStream , SyncContentStream ] async def slow_numbers ( minimum : int , maximum : int ): yield ( \"<html><body><ul>\" ) for number in range ( minimum , maximum + 1 ): yield \"<li> %d </li>\" % number await asyncio . sleep ( 0.01 ) yield ( \"</ul></body></html>\" ) ... @get ( '/stream' ) @file ( media_type = 'text/html' , streaming = True ) def file_stream ( self ): # file_stream function must return ContentStream return slow_numbers ( 1 , 4 ) OPENAPI-INFO \u00b6 @openapi_info() decorator adds extra route function OPENAPI properties to route function OPENAPI documentation. They include: Parameters: tags : adds more OPENAPI tags to route function OPENAPI docs. deprecated : marks route function as deprecated. Default is false descriptions : adds description to route function OPENAPI docs operation_id : modifies operationid for the route function OPENAPI docs summary : adds summary to route function OPENAPI docs For example: from ellar.common import get , openapi_info ... @get ( \"/open-api-info\" ) @openapi_info ( tags = [ 'query' ], deprecated = False , description = 'open api info testing' , operation_id = 'some-operation-id' , summary = 'some summary' ) def openapi_info_function ( self , query : str ): return f \"foo bar { query } \" SERIALIZER FILTER \u00b6 @serializer_filter() decorator provides Pydantic filtering options to decorated route function output schema. Parameters: include : fields to include in the returned dictionary exclude : fields to exclude from the returned dictionary by_alias : whether field aliases should be used as keys in the returned dictionary; default False exclude_unset : whether fields which were not explicitly set when creating the model should be excluded from the returned dictionary; default False . exclude_defaults : whether fields which are equal to their default values (whether set or otherwise) should be excluded from the returned dictionary; default False exclude_none : whether fields which are equal to None should be excluded from the returned dictionary; default False For example: import typing as t from ellar.common import serializer_filter , get , Serializer class UserSchema ( Serializer ): username : str password : str first_name : t . Optional [ str ] last_name : t . Optional [ str ] ... @get ( \"/serialize-filter-1\" , response = UserSchema ) @serializer_filter ( exclude_none = True , exclude = { 'password' }) def serialized_output_1 ( self ): return dict ( username = 'python' , password = 'secret' , first_name = 'ellar' ) In example, serializer_filter to filter values that are None and also excluded password property from been returned. See Pydantic Model Export for more examples. VERSION \u00b6 @version() is a decorator that provides endpoint versioning for a route function. This decorator allows you to specify the version of the endpoint that the function is associated with. Based on the versioning scheme configuration in the application, versioned route functions are called. This can be useful for maintaining backward compatibility, or for rolling out new features to different versions of an application. More information on how to use this decorator can be found in the Versioning documentation A quick example on how to use version decorator: from ellar.common import post , Version @post ( \"/create\" , name = 'v2_v3_list' ) @Version ( '2' , '3' ) async def get_item_v2_v3 ( self ): return { 'message' : 'for v2 and v3 request' } The version decorator takes a list of values as an argument, for example @version('2', '3') . This indicates that the get_item_v2_v3 route function will handle version 2 and version 3 requests of the /create endpoint. This allows for multiple versions of the same endpoint to be handled by different route functions, each with their own logic and implementation. UseGuards \u00b6 @UseGuards() is a decorator that applies a protection class of type GuardCanActivate to a route function. These protection classes have a can_execute function that is called to determine whether a route function should be executed. This decorator allows you to apply certain conditions or checks before a route function is executed, such as authentication or authorization checks. This can help to ensure that only authorized users can access certain resources. More information on how to use this decorator can be found in the Guard Documentation A quick example on how to use UseGuards decorator: import typing as t from ellar.common import get , UseGuards from ellar.core import APIKeyQuery , HTTPConnection class MyAPIKeyQuery ( APIKeyQuery ): async def authenticate ( self , connection : HTTPConnection , key : t . Optional [ t . Any ]) -> t . Optional [ t . Any ]: if key == 'supersecret' : return True return False @get ( \"/\" ) @UseGuards ( MyAPIKeyQuery (), ) async def get_guarded_items ( self ): return { 'message' : 'worked fine with `key`=`supersecret`' } The UseGuards decorator, like the version decorator, takes a list of values as an argument. During a request, the provided guards are called in the order in which they are provided. This allows you to apply multiple guards to a single route function and have them executed in a specific order. This is useful for applying multiple levels of security or access control to a single endpoint. Each guard class has a can_execute function that is called in the order specified by the decorator, if any of the guard's can_execute function returns False, the route function will not be executed. Command Decorators \u00b6 The command decorator is used to convert a decorated function into a command that can be executed through the Ellar command-line interface (CLI) actions. This allows you to define custom commands that can be run from the command-line, which can be useful for tasks such as running database migrations, generating code, or other tasks that can be automated. See Ellar-CLI Custom Commands Module Function Decorators \u00b6 @exception_handler : This decorator is used to register a function as an exception handler. This function will be called when an unhandled exception occurs during a request. It should take the exception instance as its only argument and return a response object. @middleware : This decorator is used to register a function as a middleware. Middlewares are called for each incoming request and can be used to modify the request or response, or perform any other actions before or after the request is handled. @template_filter : This decorator is used to register a function as a Jinja2 template filter. The function should take one or more arguments and return a modified value. @template_global : This decorator is used to register a function as a global variable available in all Jinja2 templates. The function can be called without any arguments and should return a value. These decorators can be used to define functions that will be executed at specific points in the application's lifecycle. They provide a way to separate and organize the different parts of an application. See Module Additional Configuration for examples on how these decorator functions are used.","title":"Custom Decorators"},{"location":"overview/custom_decorators/#custom-decorators","text":"Ellar provides a variety of function decorators in the ellar.common python module that can be used to modify the behavior of route functions. These decorators can be used to change the response type of a route function, add filters to the response schema, define the OPENAPI context, and more. In general, these decorators can help to simplify and streamline the process of creating routes.","title":"Custom Decorators"},{"location":"overview/custom_decorators/#http-method-decorator","text":"@get , @post , @put , @patch , @delete , @trace , @options , @head are decorators that define the standard HTTP methods for a route function. They indicate the type of HTTP request that the route function can handle, such as a GET request or a POST request. @http_route is a decorator that can be used to define a route that can handle multiple HTTP methods at once. @ws_route is a decorator that is used to define a route that can handle WebSocket connections. These decorators help to specify which type of request a route function can handle.","title":"HTTP Method Decorator"},{"location":"overview/custom_decorators/#route-function-parameters-decorators","text":"These decorators are Pydantic ModelField that can be used to define and validate the dependencies of route function parameters. They are used to ensure that the specified parameters are present in the request and are of the correct type. If any of the specified parameters are missing or are of an invalid type, the decorators will raise a 422 error code and also provide a clear error message if the input validation fails. This helps to ensure that the application is receiving valid input and can process the request correctly. Body(..., embed=False) Form(..., embed=True) Query(...) File(...) Path(...) Header(...) Cookie(...) Please refer to the \"How-to-Guide\" on parsing inputs here to see how this input decorators work.","title":"Route Function Parameters Decorators"},{"location":"overview/custom_decorators/#wsbody-embedfalse","text":"WsBody(...) is a decorator that defines the message format that should be transmitted from the client in a WebSocket when there is a successful connection. This decorator can be used to specify the structure of the message that is sent over the WebSocket, and to validate the message against a specified schema but for only use_extra_handler=True . For example: from ellar.common import WsBody , ws_route from ellar.core import WebSocket ... @ws_route ( '/websocket' , use_extra_handler = True ) def sample_endpoint_ws ( self , websocket : WebSocket , data_schema : str = WsBody ()): pass @ws_route . connect ( sample_endpoint_ws ) async def on_connect ( self , websocket : WebSocket ): # Called when there is a connection to `sample_endpoint_ws` await websocket . accept () @ws_route . disconnect ( sample_endpoint_ws ) async def on_disconnect ( self , websocket : WebSocket , code : int ): # Called when there is a disconnect from `sample_endpoint_ws` await websocket . close ( code )","title":"WsBody(..., embed=False)"},{"location":"overview/custom_decorators/#non-route-function-parameters-decorators","text":"We discussed decorators that are used to define route function parameter dependencies in Ellar. These decorators, such as Query , Form , and Body , etc. are pydantic models used to specify the expected parameters for a route function. However, there are also some route parameters that are system dependent, such as the request or websocket object, and the response object. These parameters are resolved by the application and supplied to the route function when needed, and are not specified with pydantic models or user input.","title":"Non Route Function Parameters Decorators"},{"location":"overview/custom_decorators/#providetype","text":"The Provide(Type) decorator is used to resolve a service provider and inject it into a route function parameter. This can be useful when using the ModuleRouter feature in Ellar. It allows for easy injection of services into route functions, making it easier to manage dependencies and improve code organization. This can be useful for resolving database connections, external APIs, or other resources that are used by the route function. For example: from ellar.common import ModuleRouter , Provide from ellar.core import App , Config router = ModuleRouter ( '/test-provide' ) @router . get ( '/app' ) def example_endpoint ( app : Provide ( App ), config : Provide ( Config )): assert isinstance ( app , App ) assert app . config == config assert isinstance ( config , Config ) return { 'message' : 'injected App and Configuration object to route function' } In the example above, example_endpoint function has two parameters app and config which are decorated with Provide(Type) decorator. This decorator tells the application to resolve the App and Config service providers and inject them as the app and config parameters when the endpoint is called. This allows for easy access to the objects without having to manually import and instantiate them. It also makes the code more modular and easier to test. Info Only types registered in the application can be resolved, but you can set INJECTOR_AUTO_BIND = True in configuration for the injector to register automatically that are not found. please note that this automatic registration will be scoped to singleton by the EllarInjector .","title":"Provide(Type)"},{"location":"overview/custom_decorators/#context","text":"The Context() decorator injects the current IExecutionContext to route function parameter. See ExecutionContext For example: from ellar.common import ModuleRouter , Context router = ModuleRouter ( '/test-context' ) @router . get ( '/' ) def example_endpoint ( ctx = Context ()): http_connection_instance = ctx . switch_to_http_connection () . get_client () query_params = http_connection_instance . query_params return { 'message' : 'inject execution context' , 'query_params' : query_params } In this example, the example_endpoint function is decorated with the Context() decorator, which injects the current IExecutionContext object into the ctx parameter of the function. The IExecutionContext object provides access to various resources and information related to the current execution context, such as the current HTTP connection, query parameters, and more. In this example, the switch_to_http_connection() method is used to access the current HTTP connection and the get_client() method is used to get the client object for the connection. The query_params attribute of the client object is then accessed and included in the response returned by the endpoint.","title":"Context"},{"location":"overview/custom_decorators/#req","text":"Req() decorator injects current Request object to route function parameter. For example: from ellar.common import ModuleRouter , Req router = ModuleRouter ( '/test-req' ) @router . get ( '/' ) def example_endpoint ( req = Req ()): headers = req . headers query_params = req . query_params return { 'message' : 'injected request object' , 'headers' : headers , 'query_params' : query_params } In this example, the example_endpoint function has a parameter req decorated with Req() , which will be automatically populated with the current Request object at runtime. The headers and query_params attributes of the req object can then be accessed and used within the function.","title":"Req"},{"location":"overview/custom_decorators/#res","text":"Res() decorator injects current Response object to route function parameter. For example: from ellar.common import ModuleRouter , Res router = ModuleRouter ( '/test-response' ) @router . get ( '/' ) def example_endpoint ( res = Res ()): res . headers [ 'x-custom-header' ] = 'hello' return { 'message' : 'inject response object' } In this example, the Res() decorator injects the current Response object to the res parameter of the example_endpoint function. This will allow you to manipulate the headers of the response before it is sent back to the client.","title":"Res"},{"location":"overview/custom_decorators/#ws","text":"Ws() decorator injects current WebSocket object to route function parameter. For example: from ellar.common import ModuleRouter , Ws router = ModuleRouter ( '/test-ws' ) @router . ws_route ( '/' ) async def example_endpoint ( ws = Ws ()): await ws . accept () await ws . send_json ({ 'message' : 'injected WebSocket object to route function' }) The above code creates a WebSocket route '/test-ws' and when a client connects to this route, the example_endpoint function is executed. The Ws decorator injects the current WebSocket object to the ws parameter of the function, which can then be used to interact with the WebSocket connection, such as accepting the connection and sending data to the client. The same conditions and examples applies for: Host() decorator injects current client host address to route function parameter. Session() decorator injects current Session object to route function parameter. This requires SessionMiddleware module from Starlette added in application middleware and also SessionMiddleware module depends on itsdangerous package. Http() decorator injects current HTTP connection object to route function parameter.","title":"Ws"},{"location":"overview/custom_decorators/#creating-a-custom-parameter-decorators","text":"You can still create your own route parameter decorators that suits your need. You simply need to follow a contract, NonParameterResolver , and override the resolve function. The NonParameterResolver has two attribute, type_annotation and parameter_name , that are provided automatically when computing route parameter dependencies. They are gotten from the application of the NonParameterResolver, like so - def s(parameter_name:type_annotation = NonParameterResolver()) . NonParameterResolver receives current IExecutionContext must return a tuple of dict object of the resulting resolve data with parameter_name and list of errors if any. As shown in the return statements in the example below. For example: import typing as t from ellar.common.params import NonParameterResolver from ellar.common import IExecutionContext from pydantic.error_wrappers import ErrorWrapper class UserParam ( NonParameterResolver ): async def resolve ( self , ctx : IExecutionContext , ** kwargs : t . Any ) -> t . Any : request = ctx . switch_to_http_connection () . get_request () user = request . get ( 'user' , None ) if user : return { self . parameter_name : user }, [] return {}, [ ErrorWrapper ( 'Authenticated Users Only' , loc = 'system' )] This example defines a custom decorator called UserParam that inherits from NonParameterResolver . The resolve method is overridden to extract the user from the current IExecutionContext 's request. If the user is found, it is returned as a dict with the key as the parameter_name of the decorator, along with an empty list of errors. If no user is found, an empty dict and a list of errors containing an ErrorWrapper object is returned. This UserParam decorator can then be used to inject the user object to a route function parameter like so: @router . get ( '/user' ) def example_endpoint ( user : UserParam ()): return { 'message' : 'injected user object to route function' , 'user' : user }","title":"Creating a Custom Parameter Decorators"},{"location":"overview/custom_decorators/#route-function-decorators","text":"These decorators are used to modify the output data of a route function, add filtering to the output schema, or add extra OPENAPI information about the route function. They include:","title":"Route Function Decorators"},{"location":"overview/custom_decorators/#render","text":"@render() decorator converts a route function response to HTML template response. for example: from ellar.common import get , render ... @get ( '/index-template' ) @render ( template_name = 'my_template' ) def index ( self ): return { 'name' : 'Ellar Template' } In the example, the index function is decorated with the render decorator, which will return a 200 status code and HTML content from my_template. The return object from the index function will be used as the templating context for my_template during the template rendering process. This allows the function to pass data to the template and have it rendered with the provided context, the rendered template will be the response body. See HTML Templating for more information on render and HTML templating with Ellar.","title":"RENDER"},{"location":"overview/custom_decorators/#file","text":"@file() decorator converts a route function response to file or streaming response type. Based on the value of streaming parameter, file decorator creates FileResponseModel or StreamingResponseModel .","title":"FILE"},{"location":"overview/custom_decorators/#fileresponsemodel-as-filestreamingfalse","text":"When streaming parameter in @file(streaming=False) decorator is set to False , a FileResponseModel is created as the response model for the decorated route function. And the route function is required to return a dictionary object that follows a FileResponseModelSchema format: import typing as t from enum import Enum from ellar.common import Serializer class ContentDispositionType ( str , Enum ): inline = \"inline\" attachment = \"attachment\" class FileResponseModelSchema ( Serializer ): path : str media_type : t . Optional [ str ] = None filename : t . Optional [ str ] = None method : t . Optional [ str ] = None content_disposition_type : ContentDispositionType = ContentDispositionType . attachment path : This is a required key whose value defines the path to the file to attach to the response. filename : when specified, it will be used as the attached file's filename. The default value is computed from the file referenced. content_disposition_type : defines the content disposition type, can be either inline or attachment. The default is attachment. media_type : states the MIME type of the file to be attached. The default value is computed from the file referenced. method : HTTP method, defaults: HEAD for example: from ellar.common import get , file ... @get () @file ( media_type = 'text/html' , streaming = False ) def file_download ( self ): return { 'path' : 'path/to/file.html' , 'filename' : 'code.html' , 'content_disposition_type' : 'attachment' } In the example, an additional parameter media_type is added to the @file(streaming=False) decorator to define the content-type of the file returned. This is helpful for creating the route function's OPENAPI documentation, as it allows the content-type to be defined upfront. Without this parameter, the content-type will be computed during runtime when returning a response for a request. It is a way to explicitly define the content-type of the file which will be returned.","title":"FileResponseModel as file(streaming=False)"},{"location":"overview/custom_decorators/#streamingresponsemodel-as-filestreamingtrue","text":"On the other hand, when streaming parameter in @file(streaming=True) decorator is set to True , a StreamingResponseModel is created as the response model for the decorated route function. And the route function is required to return an ContentStream . ContentStream is an synchronous or asynchronous iterator of string or bytes. Type definition is shown below. import typing import asyncio from ellar.common import get , file Content = typing . Union [ str , bytes ] SyncContentStream = typing . Iterator [ Content ] AsyncContentStream = typing . AsyncIterable [ Content ] ContentStream = typing . Union [ AsyncContentStream , SyncContentStream ] async def slow_numbers ( minimum : int , maximum : int ): yield ( \"<html><body><ul>\" ) for number in range ( minimum , maximum + 1 ): yield \"<li> %d </li>\" % number await asyncio . sleep ( 0.01 ) yield ( \"</ul></body></html>\" ) ... @get ( '/stream' ) @file ( media_type = 'text/html' , streaming = True ) def file_stream ( self ): # file_stream function must return ContentStream return slow_numbers ( 1 , 4 )","title":"StreamingResponseModel as file(streaming=True)"},{"location":"overview/custom_decorators/#openapi-info","text":"@openapi_info() decorator adds extra route function OPENAPI properties to route function OPENAPI documentation. They include: Parameters: tags : adds more OPENAPI tags to route function OPENAPI docs. deprecated : marks route function as deprecated. Default is false descriptions : adds description to route function OPENAPI docs operation_id : modifies operationid for the route function OPENAPI docs summary : adds summary to route function OPENAPI docs For example: from ellar.common import get , openapi_info ... @get ( \"/open-api-info\" ) @openapi_info ( tags = [ 'query' ], deprecated = False , description = 'open api info testing' , operation_id = 'some-operation-id' , summary = 'some summary' ) def openapi_info_function ( self , query : str ): return f \"foo bar { query } \"","title":"OPENAPI-INFO"},{"location":"overview/custom_decorators/#serializer-filter","text":"@serializer_filter() decorator provides Pydantic filtering options to decorated route function output schema. Parameters: include : fields to include in the returned dictionary exclude : fields to exclude from the returned dictionary by_alias : whether field aliases should be used as keys in the returned dictionary; default False exclude_unset : whether fields which were not explicitly set when creating the model should be excluded from the returned dictionary; default False . exclude_defaults : whether fields which are equal to their default values (whether set or otherwise) should be excluded from the returned dictionary; default False exclude_none : whether fields which are equal to None should be excluded from the returned dictionary; default False For example: import typing as t from ellar.common import serializer_filter , get , Serializer class UserSchema ( Serializer ): username : str password : str first_name : t . Optional [ str ] last_name : t . Optional [ str ] ... @get ( \"/serialize-filter-1\" , response = UserSchema ) @serializer_filter ( exclude_none = True , exclude = { 'password' }) def serialized_output_1 ( self ): return dict ( username = 'python' , password = 'secret' , first_name = 'ellar' ) In example, serializer_filter to filter values that are None and also excluded password property from been returned. See Pydantic Model Export for more examples.","title":"SERIALIZER FILTER"},{"location":"overview/custom_decorators/#version","text":"@version() is a decorator that provides endpoint versioning for a route function. This decorator allows you to specify the version of the endpoint that the function is associated with. Based on the versioning scheme configuration in the application, versioned route functions are called. This can be useful for maintaining backward compatibility, or for rolling out new features to different versions of an application. More information on how to use this decorator can be found in the Versioning documentation A quick example on how to use version decorator: from ellar.common import post , Version @post ( \"/create\" , name = 'v2_v3_list' ) @Version ( '2' , '3' ) async def get_item_v2_v3 ( self ): return { 'message' : 'for v2 and v3 request' } The version decorator takes a list of values as an argument, for example @version('2', '3') . This indicates that the get_item_v2_v3 route function will handle version 2 and version 3 requests of the /create endpoint. This allows for multiple versions of the same endpoint to be handled by different route functions, each with their own logic and implementation.","title":"VERSION"},{"location":"overview/custom_decorators/#useguards","text":"@UseGuards() is a decorator that applies a protection class of type GuardCanActivate to a route function. These protection classes have a can_execute function that is called to determine whether a route function should be executed. This decorator allows you to apply certain conditions or checks before a route function is executed, such as authentication or authorization checks. This can help to ensure that only authorized users can access certain resources. More information on how to use this decorator can be found in the Guard Documentation A quick example on how to use UseGuards decorator: import typing as t from ellar.common import get , UseGuards from ellar.core import APIKeyQuery , HTTPConnection class MyAPIKeyQuery ( APIKeyQuery ): async def authenticate ( self , connection : HTTPConnection , key : t . Optional [ t . Any ]) -> t . Optional [ t . Any ]: if key == 'supersecret' : return True return False @get ( \"/\" ) @UseGuards ( MyAPIKeyQuery (), ) async def get_guarded_items ( self ): return { 'message' : 'worked fine with `key`=`supersecret`' } The UseGuards decorator, like the version decorator, takes a list of values as an argument. During a request, the provided guards are called in the order in which they are provided. This allows you to apply multiple guards to a single route function and have them executed in a specific order. This is useful for applying multiple levels of security or access control to a single endpoint. Each guard class has a can_execute function that is called in the order specified by the decorator, if any of the guard's can_execute function returns False, the route function will not be executed.","title":"UseGuards"},{"location":"overview/custom_decorators/#command-decorators","text":"The command decorator is used to convert a decorated function into a command that can be executed through the Ellar command-line interface (CLI) actions. This allows you to define custom commands that can be run from the command-line, which can be useful for tasks such as running database migrations, generating code, or other tasks that can be automated. See Ellar-CLI Custom Commands","title":"Command Decorators"},{"location":"overview/custom_decorators/#module-function-decorators","text":"@exception_handler : This decorator is used to register a function as an exception handler. This function will be called when an unhandled exception occurs during a request. It should take the exception instance as its only argument and return a response object. @middleware : This decorator is used to register a function as a middleware. Middlewares are called for each incoming request and can be used to modify the request or response, or perform any other actions before or after the request is handled. @template_filter : This decorator is used to register a function as a Jinja2 template filter. The function should take one or more arguments and return a modified value. @template_global : This decorator is used to register a function as a global variable available in all Jinja2 templates. The function can be called without any arguments and should return a value. These decorators can be used to define functions that will be executed at specific points in the application's lifecycle. They provide a way to separate and organize the different parts of an application. See Module Additional Configuration for examples on how these decorator functions are used.","title":"Module Function Decorators"},{"location":"overview/exception_handling/","text":"Exceptions & Exception Handling \u00b6 The ExceptionMiddleware and ExceptionMiddlewareService handle all unhandled exceptions throughout an application and provide user-friendly responses. { \"status_code\" : 403 , \"detail\" : \"Forbidden\" } Types of exceptions managed by default: HTTPException : Provided by Starlette to handle HTTP errors WebSocketException : Provided by Starlette to manage websocket errors RequestValidationException : Provided by Pydantic for validation of request data APIException : Handles HTTP errors and provides more context about the error. HTTPException \u00b6 The HTTPException class provides a base class that you can use for any handled exceptions. HTTPException(status_code, detail=None, headers=None) WebSocketException \u00b6 You can use the WebSocketException class to raise errors inside WebSocket endpoints. WebSocketException(code=1008, reason=None) You can set any code valid as defined in the specification . APIException \u00b6 It is a type of exception for REST API based applications. It gives more concept to error and provides a simple interface for creating other custom exception needs in your application without having to create an extra exception handler. For example, from ellar.common.exceptions import APIException from starlette import status class ServiceUnavailableException ( APIException ): status_code = status . HTTP_503_SERVICE_UNAVAILABLE code = 'service_unavailable' Hint You should only raise HTTPException and APIException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly. Let's use this ServiceUnavailableException in our previous project. For example, in the CarController , we have a get_all() method (a GET route handler). Let's assume that this route handler throws an exception for some reason. To demonstrate this, we'll hard-code it as follows: # project_name/apps/car/controllers.py @get () def get_all ( self ): raise ServiceUnavailableException () Now, when you visit http://127.0.0.1/car/ , you will get a JSON response. { \"detail\" : \"Service Unavailable\" } When we raise the ServiceUnavailableException exception type, it produces a JSON response because Ellar has implemented an exception handler for any APIException exception type. We will see how to change the default exception handler later. There is another error presentation available on the APIException instance: - .detail : returns textual description of the error. - get_full_details() : returns both textual description and other information about the error. >>> print ( exc.detail ) Service Unavailable >>> print ( exc.get_full_details ()) { 'detail' : 'Service Unavailable' , 'code' : 'service_unavailable' , 'description' : 'The server cannot process the request due to a high load' } Creating Custom Exception Handler \u00b6 To create an exception handler for your custom exception, you have to make a class that follows the IExceptionHandler contract. At the root project folder, create a file custom_exceptions.py , # project_name/custom_exceptions.py import typing as t from ellar.common import IExceptionHandler , IHostContext from starlette.responses import Response class MyCustomException ( Exception ): pass class MyCustomExceptionHandler ( IExceptionHandler ): exception_type_or_code = MyCustomException async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , ) IExceptionHandler Overview: exception_type_or_code : defines the exception class OR status code to target when resolving exception handlers. catch() : defines the handling code and response to be returned to the client. Creating Exception Handler for status code \u00b6 Let's create a handler for MethodNotAllowedException which, according to the HTTP code is 405 . # project_name/apps/custom_exceptions.py import typing as t from ellar.common import IExceptionHandler , IHostContext , render_template from starlette.responses import Response from starlette.exceptions import HTTPException class MyCustomException ( Exception ): pass class MyCustomExceptionHandler ( IExceptionHandler ): exception_type_or_code = MyCustomException async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , ) class ExceptionHandlerAction405 ( IExceptionHandler ): exception_type_or_code = 405 async def catch ( self , ctx : IHostContext , exc : HTTPException ) -> t . Union [ Response , t . Any ]: context_kwargs = {} return render_template ( '405.html' , request = ctx . switch_to_http_connection () . get_request (), ** context_kwargs ) We have registered a handler for any HTTP exception with a 405 status code which we are returning a template 405.html as a response. Info Ellar will look for 405.html in all registered modules. So car folder, create a templates folder and add 405.html . The same way can create Handler for 500 error code. Registering Exception Handlers \u00b6 We have successfully created two exception handlers ExceptionHandlerAction405 and MyCustomExceptionHandler but they are not yet visible to the application. config.py : The config file holds manage application settings. The EXCEPTION_HANDLERS variable defines all custom exception handlers registered to ExceptionMiddlewareService when bootstrapping the application. # project_name/config.py import typing as t from ellar.core import ConfigDefaultTypesMixin from ellar.common import IExceptionHandler from .apps.custom_exceptions import MyCustomExceptionHandler , ExceptionHandlerAction405 class BaseConfig ( ConfigDefaultTypesMixin ): EXCEPTION_HANDLERS : t . List [ IExceptionHandler ] = [ MyCustomExceptionHandler (), ExceptionHandlerAction405 () ] - application instance : You can also add exception through app instance. # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from .root_module import ApplicationModule from .apps.custom_exceptions import MyCustomExceptionHandler , ExceptionHandlerAction405 application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"project_name.config:DevelopmentConfig\" ), ) application . add_exception_handler ( MyCustomExceptionHandler (), ExceptionHandlerAction405 () ) Override Default Exception Handler \u00b6 We have seen how to create an exception handler for status codes and specific exception types. To override any exception handler, it follows the same pattern and then defines the target to exception type For example: # project_name/apps/custom_exceptions.py import typing as t from ellar.common import IHostContext , IExceptionHandler , APIException from starlette.responses import Response class OverrideAPIExceptionHandler ( IExceptionHandler ): exception_type_or_code = APIException async def catch ( self , ctx : IHostContext , exc : APIException ) -> t . Union [ Response , t . Any ]: app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'message' : exc . detail }, status_code = exc . status_code , ) Once we register the OverrideAPIExceptionHandler exception handler, it will become the default handler for the APIException exception type.","title":"Exception Handling"},{"location":"overview/exception_handling/#exceptions-exception-handling","text":"The ExceptionMiddleware and ExceptionMiddlewareService handle all unhandled exceptions throughout an application and provide user-friendly responses. { \"status_code\" : 403 , \"detail\" : \"Forbidden\" } Types of exceptions managed by default: HTTPException : Provided by Starlette to handle HTTP errors WebSocketException : Provided by Starlette to manage websocket errors RequestValidationException : Provided by Pydantic for validation of request data APIException : Handles HTTP errors and provides more context about the error.","title":"Exceptions &amp; Exception Handling"},{"location":"overview/exception_handling/#httpexception","text":"The HTTPException class provides a base class that you can use for any handled exceptions. HTTPException(status_code, detail=None, headers=None)","title":"HTTPException"},{"location":"overview/exception_handling/#websocketexception","text":"You can use the WebSocketException class to raise errors inside WebSocket endpoints. WebSocketException(code=1008, reason=None) You can set any code valid as defined in the specification .","title":"WebSocketException"},{"location":"overview/exception_handling/#apiexception","text":"It is a type of exception for REST API based applications. It gives more concept to error and provides a simple interface for creating other custom exception needs in your application without having to create an extra exception handler. For example, from ellar.common.exceptions import APIException from starlette import status class ServiceUnavailableException ( APIException ): status_code = status . HTTP_503_SERVICE_UNAVAILABLE code = 'service_unavailable' Hint You should only raise HTTPException and APIException inside routing or endpoints. Middleware classes should instead just return appropriate responses directly. Let's use this ServiceUnavailableException in our previous project. For example, in the CarController , we have a get_all() method (a GET route handler). Let's assume that this route handler throws an exception for some reason. To demonstrate this, we'll hard-code it as follows: # project_name/apps/car/controllers.py @get () def get_all ( self ): raise ServiceUnavailableException () Now, when you visit http://127.0.0.1/car/ , you will get a JSON response. { \"detail\" : \"Service Unavailable\" } When we raise the ServiceUnavailableException exception type, it produces a JSON response because Ellar has implemented an exception handler for any APIException exception type. We will see how to change the default exception handler later. There is another error presentation available on the APIException instance: - .detail : returns textual description of the error. - get_full_details() : returns both textual description and other information about the error. >>> print ( exc.detail ) Service Unavailable >>> print ( exc.get_full_details ()) { 'detail' : 'Service Unavailable' , 'code' : 'service_unavailable' , 'description' : 'The server cannot process the request due to a high load' }","title":"APIException"},{"location":"overview/exception_handling/#creating-custom-exception-handler","text":"To create an exception handler for your custom exception, you have to make a class that follows the IExceptionHandler contract. At the root project folder, create a file custom_exceptions.py , # project_name/custom_exceptions.py import typing as t from ellar.common import IExceptionHandler , IHostContext from starlette.responses import Response class MyCustomException ( Exception ): pass class MyCustomExceptionHandler ( IExceptionHandler ): exception_type_or_code = MyCustomException async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , ) IExceptionHandler Overview: exception_type_or_code : defines the exception class OR status code to target when resolving exception handlers. catch() : defines the handling code and response to be returned to the client.","title":"Creating Custom Exception Handler"},{"location":"overview/exception_handling/#creating-exception-handler-for-status-code","text":"Let's create a handler for MethodNotAllowedException which, according to the HTTP code is 405 . # project_name/apps/custom_exceptions.py import typing as t from ellar.common import IExceptionHandler , IHostContext , render_template from starlette.responses import Response from starlette.exceptions import HTTPException class MyCustomException ( Exception ): pass class MyCustomExceptionHandler ( IExceptionHandler ): exception_type_or_code = MyCustomException async def catch ( self , ctx : IHostContext , exc : MyCustomException ) -> t . Union [ Response , t . Any ]: app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'detail' : str ( exc )}, status_code = 400 , ) class ExceptionHandlerAction405 ( IExceptionHandler ): exception_type_or_code = 405 async def catch ( self , ctx : IHostContext , exc : HTTPException ) -> t . Union [ Response , t . Any ]: context_kwargs = {} return render_template ( '405.html' , request = ctx . switch_to_http_connection () . get_request (), ** context_kwargs ) We have registered a handler for any HTTP exception with a 405 status code which we are returning a template 405.html as a response. Info Ellar will look for 405.html in all registered modules. So car folder, create a templates folder and add 405.html . The same way can create Handler for 500 error code.","title":"Creating Exception Handler for status code"},{"location":"overview/exception_handling/#registering-exception-handlers","text":"We have successfully created two exception handlers ExceptionHandlerAction405 and MyCustomExceptionHandler but they are not yet visible to the application. config.py : The config file holds manage application settings. The EXCEPTION_HANDLERS variable defines all custom exception handlers registered to ExceptionMiddlewareService when bootstrapping the application. # project_name/config.py import typing as t from ellar.core import ConfigDefaultTypesMixin from ellar.common import IExceptionHandler from .apps.custom_exceptions import MyCustomExceptionHandler , ExceptionHandlerAction405 class BaseConfig ( ConfigDefaultTypesMixin ): EXCEPTION_HANDLERS : t . List [ IExceptionHandler ] = [ MyCustomExceptionHandler (), ExceptionHandlerAction405 () ] - application instance : You can also add exception through app instance. # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from .root_module import ApplicationModule from .apps.custom_exceptions import MyCustomExceptionHandler , ExceptionHandlerAction405 application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"project_name.config:DevelopmentConfig\" ), ) application . add_exception_handler ( MyCustomExceptionHandler (), ExceptionHandlerAction405 () )","title":"Registering Exception Handlers"},{"location":"overview/exception_handling/#override-default-exception-handler","text":"We have seen how to create an exception handler for status codes and specific exception types. To override any exception handler, it follows the same pattern and then defines the target to exception type For example: # project_name/apps/custom_exceptions.py import typing as t from ellar.common import IHostContext , IExceptionHandler , APIException from starlette.responses import Response class OverrideAPIExceptionHandler ( IExceptionHandler ): exception_type_or_code = APIException async def catch ( self , ctx : IHostContext , exc : APIException ) -> t . Union [ Response , t . Any ]: app_config = ctx . get_app () . config return app_config . DEFAULT_JSON_CLASS ( { 'message' : exc . detail }, status_code = exc . status_code , ) Once we register the OverrideAPIExceptionHandler exception handler, it will become the default handler for the APIException exception type.","title":"Override Default Exception Handler"},{"location":"overview/guards/","text":"Guards \u00b6 A Guard in Ellar is a way to add authentication and authorization checks to your application. It acts as a middleware and runs before executing the route handler. If the guard returns false , the request is rejected and the execution is stopped. Guards can be used to check for specific roles, permissions, or any other arbitrary condition. They can be easily applied to individual routes or groups of routes using @guard decorator. Unlike middleware, a guard have access to the ExecutionContext which provides information for the route function to be executed and its controller. Note Guards are executed after all middleware Authorization guard \u00b6 Authorization is a great example of a guard because some routes should be available only to specific authenticated user and or users that sufficient permissions. Let's assume we have a AuthGard which checks if a making a request is authenticated. from ellar.common import GuardCanActivate , IExecutionContext from ellar.di import injectable @injectable () class AuthGuard ( GuardCanActivate ): async def can_activate ( self , context : IExecutionContext ) -> bool : request = context . switch_to_http_connection () . get_request () return self . validate_request ( request ) def validate_request ( self , request ) -> bool : ... The implementation of the validate_request() function, in the example above, can be simple or complex depending on the use case. The primary objective is to demonstrate the integration of guards into the request/response cycle. Every guard must inherit from GuardCanActivate and override can_activate() function. The can_activate() function is required to return a boolean value. The return value determines the next action: If the function returns true , the request will be processed. If the function returns false , Ellar will reject the request. Role-based authentication \u00b6 Let's build a more functional guard that permits access only to users with a specific role. We'll start with a basic guard template, and build on it in the coming sections. For now, it allows all requests to proceed: # project_name/cars/guards.py from ellar.common import GuardCanActivate , IExecutionContext from ellar.di import injectable @injectable () class RoleGuard ( GuardCanActivate ): async def can_activate ( self , context : IExecutionContext ) -> bool : return True Applying guards \u00b6 Guards can be controller-scoped , method-scoped , or global-scoped . We apply guards to controllers or route function by using @Guards . The @UseGuards takes a single argument, or a comma-separated list of arguments of GuardCanActivate types or instances. import typing as t def UseGuards ( * _guards : t . Type [ \"GuardCanActivate\" ] | \"GuardCanActivate\" ) -> t . Callable : ... Controller-scoped \u00b6 We set up controller scoped guards on controller by using @UseGuards decorator. For example: # project_name/cars/controllers.py from ellar.common import Controller , UseGuards from .guards import RoleGuard @Controller () @UseGuards ( RoleGuard ) class CarsController : ... The above example attaches the guard to every handler declared by this controller. If we wish the guard to apply only to a single method, we apply the @UseGuards() decorator at the method level. Method-scoped \u00b6 We can also use @UseGuards() on route-function when necessary. # project_name/cars/controllers.py from ellar.common import Controller , UseGuards , get from .guards import RoleGuard @Controller () @UseGuards ( RoleGuard ) class CarsController : @UseGuards ( RoleGuard ()) @get ( '/guarded-route' ) def guarded_route ( self ): return \"Passed Guard\" In the example, we decorated guarded_route with @UseGuards(RoleGuard()) with an instance of RoleGuard . When request execution for /guarded-route , guarded_route guard definition will be precedence over CarsController guard definitions. Global-scope \u00b6 Global guards are used across the whole application, for every controller and every route function but individual controller or route function @UseGuards definition can override global scoped guards. Global guards are applied at the global_guards parameter of the AppFactory creation level as shown below: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from .apps.cars.guards import RoleGuard from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [ RoleGuard ] ) Rounding up RoleGuard \u00b6 Our RolesGuard is working, but it's not very smart yet. Let's assume we want our RoleGuard to manage user role permissions in a more general context employing the power of ExecutionContext and custom metadata . In CarController , for example, could have different permission schemes for different routes. Some might be available only for an admin user, and others could be open for everyone. from ellar.common import post , set_metadata ... @post () @set_metadata ( 'roles' , [ 'admin' ]) async def create ( self , payload : CreateCarSerializer = Body ()): self . repo . create_car ( payload ) return 'This action adds a new car' ... In the above example, we attached the roles metadata (roles is a key, while ['admin'] is a particular value) to the create() method. While this works, it's not good practice to use @set_metadata() directly in your routes. So we can refactor that code as shown below: # project_name/role_decorator.py import typing from ellar.common import set_metadata def roles ( * _roles : str ) -> typing . Callable : return set_metadata ( 'roles' , list ( _roles )) This approach is much cleaner and more readable, and is strongly typed. Now that we have a custom @roles() decorator, we can use it to decorate the create() method. ... @post () @role ( 'admin' , 'staff' ) async def create ( self , payload : CreateCarSerializer = Body ()): self . repo . create_car ( payload ) return 'This action adds a new car' ... Let's now go back and tie this together with our RolesGuard . Currently, it simply returns true in all cases, allowing every request to proceed. We want to make the return value conditional based on the comparing the roles assigned to the current user to the actual roles required by the current route being processed. In order to access the route's function role(s) (custom metadata) , we'll use the Reflector helper class, which is provided out of the box by the framework. # project_name/apps/cars/guards.py import typing as t from ellar.di import injectable from ellar.common import GuardCanActivate , IExecutionContext from ellar.core.services import Reflector @injectable () class RoleGuard ( GuardCanActivate ): def __init__ ( self , reflector : Reflector ): self . reflector = reflector def match_roles ( self , roles : t . List [ str ], user_roles : t . List [ str ]) -> bool : for user_role in user_roles : if user_role in roles : return True return False async def can_activate ( self , context : IExecutionContext ) -> bool : roles = self . reflector . get ( 'roles' , context . get_handler ()) # request = context.switch_to_http_connection().get_request() # check if user in request object has role if not roles : return True request = context . switch_to_http_connection () . get_request () user = request . user return self . match_roles ( roles , user_roles = user . roles ) Here, we are assuming an authenticated user object exist in request object. When a user with insufficient privileges requests an endpoint, Ellar automatically returns the following response: { \"detail\" : \"Forbidden\" , \"status_code\" : 403 } Note that behind the scenes, when a guard returns false , the framework throws a HTTPException with status code 403 . If you want to return a different error response, you should throw your own specific exception by override raise_exception function as shown below: from ellar.common import APIException , GuardCanActivate from ellar.di import injectable from ellar.core import Reflector @injectable () class RoleGuard ( GuardCanActivate ): def __init__ ( self , reflector : Reflector ): self . reflector = reflector def raise_exception ( self ) -> None : raise APIException ( detail = \"You don't have the permission to perform this action\" , status_code = 403 ) ... The construct will output the json below when the guard returns false { \"detail\" : \"You don't have the permission to perform this action\" }","title":"Guards"},{"location":"overview/guards/#guards","text":"A Guard in Ellar is a way to add authentication and authorization checks to your application. It acts as a middleware and runs before executing the route handler. If the guard returns false , the request is rejected and the execution is stopped. Guards can be used to check for specific roles, permissions, or any other arbitrary condition. They can be easily applied to individual routes or groups of routes using @guard decorator. Unlike middleware, a guard have access to the ExecutionContext which provides information for the route function to be executed and its controller. Note Guards are executed after all middleware","title":"Guards"},{"location":"overview/guards/#authorization-guard","text":"Authorization is a great example of a guard because some routes should be available only to specific authenticated user and or users that sufficient permissions. Let's assume we have a AuthGard which checks if a making a request is authenticated. from ellar.common import GuardCanActivate , IExecutionContext from ellar.di import injectable @injectable () class AuthGuard ( GuardCanActivate ): async def can_activate ( self , context : IExecutionContext ) -> bool : request = context . switch_to_http_connection () . get_request () return self . validate_request ( request ) def validate_request ( self , request ) -> bool : ... The implementation of the validate_request() function, in the example above, can be simple or complex depending on the use case. The primary objective is to demonstrate the integration of guards into the request/response cycle. Every guard must inherit from GuardCanActivate and override can_activate() function. The can_activate() function is required to return a boolean value. The return value determines the next action: If the function returns true , the request will be processed. If the function returns false , Ellar will reject the request.","title":"Authorization guard"},{"location":"overview/guards/#role-based-authentication","text":"Let's build a more functional guard that permits access only to users with a specific role. We'll start with a basic guard template, and build on it in the coming sections. For now, it allows all requests to proceed: # project_name/cars/guards.py from ellar.common import GuardCanActivate , IExecutionContext from ellar.di import injectable @injectable () class RoleGuard ( GuardCanActivate ): async def can_activate ( self , context : IExecutionContext ) -> bool : return True","title":"Role-based authentication"},{"location":"overview/guards/#applying-guards","text":"Guards can be controller-scoped , method-scoped , or global-scoped . We apply guards to controllers or route function by using @Guards . The @UseGuards takes a single argument, or a comma-separated list of arguments of GuardCanActivate types or instances. import typing as t def UseGuards ( * _guards : t . Type [ \"GuardCanActivate\" ] | \"GuardCanActivate\" ) -> t . Callable : ...","title":"Applying guards"},{"location":"overview/guards/#controller-scoped","text":"We set up controller scoped guards on controller by using @UseGuards decorator. For example: # project_name/cars/controllers.py from ellar.common import Controller , UseGuards from .guards import RoleGuard @Controller () @UseGuards ( RoleGuard ) class CarsController : ... The above example attaches the guard to every handler declared by this controller. If we wish the guard to apply only to a single method, we apply the @UseGuards() decorator at the method level.","title":"Controller-scoped"},{"location":"overview/guards/#method-scoped","text":"We can also use @UseGuards() on route-function when necessary. # project_name/cars/controllers.py from ellar.common import Controller , UseGuards , get from .guards import RoleGuard @Controller () @UseGuards ( RoleGuard ) class CarsController : @UseGuards ( RoleGuard ()) @get ( '/guarded-route' ) def guarded_route ( self ): return \"Passed Guard\" In the example, we decorated guarded_route with @UseGuards(RoleGuard()) with an instance of RoleGuard . When request execution for /guarded-route , guarded_route guard definition will be precedence over CarsController guard definitions.","title":"Method-scoped"},{"location":"overview/guards/#global-scope","text":"Global guards are used across the whole application, for every controller and every route function but individual controller or route function @UseGuards definition can override global scoped guards. Global guards are applied at the global_guards parameter of the AppFactory creation level as shown below: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from .apps.cars.guards import RoleGuard from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [ RoleGuard ] )","title":"Global-scope"},{"location":"overview/guards/#rounding-up-roleguard","text":"Our RolesGuard is working, but it's not very smart yet. Let's assume we want our RoleGuard to manage user role permissions in a more general context employing the power of ExecutionContext and custom metadata . In CarController , for example, could have different permission schemes for different routes. Some might be available only for an admin user, and others could be open for everyone. from ellar.common import post , set_metadata ... @post () @set_metadata ( 'roles' , [ 'admin' ]) async def create ( self , payload : CreateCarSerializer = Body ()): self . repo . create_car ( payload ) return 'This action adds a new car' ... In the above example, we attached the roles metadata (roles is a key, while ['admin'] is a particular value) to the create() method. While this works, it's not good practice to use @set_metadata() directly in your routes. So we can refactor that code as shown below: # project_name/role_decorator.py import typing from ellar.common import set_metadata def roles ( * _roles : str ) -> typing . Callable : return set_metadata ( 'roles' , list ( _roles )) This approach is much cleaner and more readable, and is strongly typed. Now that we have a custom @roles() decorator, we can use it to decorate the create() method. ... @post () @role ( 'admin' , 'staff' ) async def create ( self , payload : CreateCarSerializer = Body ()): self . repo . create_car ( payload ) return 'This action adds a new car' ... Let's now go back and tie this together with our RolesGuard . Currently, it simply returns true in all cases, allowing every request to proceed. We want to make the return value conditional based on the comparing the roles assigned to the current user to the actual roles required by the current route being processed. In order to access the route's function role(s) (custom metadata) , we'll use the Reflector helper class, which is provided out of the box by the framework. # project_name/apps/cars/guards.py import typing as t from ellar.di import injectable from ellar.common import GuardCanActivate , IExecutionContext from ellar.core.services import Reflector @injectable () class RoleGuard ( GuardCanActivate ): def __init__ ( self , reflector : Reflector ): self . reflector = reflector def match_roles ( self , roles : t . List [ str ], user_roles : t . List [ str ]) -> bool : for user_role in user_roles : if user_role in roles : return True return False async def can_activate ( self , context : IExecutionContext ) -> bool : roles = self . reflector . get ( 'roles' , context . get_handler ()) # request = context.switch_to_http_connection().get_request() # check if user in request object has role if not roles : return True request = context . switch_to_http_connection () . get_request () user = request . user return self . match_roles ( roles , user_roles = user . roles ) Here, we are assuming an authenticated user object exist in request object. When a user with insufficient privileges requests an endpoint, Ellar automatically returns the following response: { \"detail\" : \"Forbidden\" , \"status_code\" : 403 } Note that behind the scenes, when a guard returns false , the framework throws a HTTPException with status code 403 . If you want to return a different error response, you should throw your own specific exception by override raise_exception function as shown below: from ellar.common import APIException , GuardCanActivate from ellar.di import injectable from ellar.core import Reflector @injectable () class RoleGuard ( GuardCanActivate ): def __init__ ( self , reflector : Reflector ): self . reflector = reflector def raise_exception ( self ) -> None : raise APIException ( detail = \"You don't have the permission to perform this action\" , status_code = 403 ) ... The construct will output the json below when the guard returns false { \"detail\" : \"You don't have the permission to perform this action\" }","title":"Rounding up RoleGuard"},{"location":"overview/interceptors/","text":"Interceptors - (AOP) technique \u00b6 An interceptor is a class annotated with the @injectable() decorator and implements the EllarInterceptor interface. During request-response cycle, interceptors are called after middleware execution before route handler execution. Interceptors have a set of useful capabilities which are inspired by the Aspect Oriented Programming (AOP) technique technique. They make it possible to: bind extra logic before / after method execution transform the result returned from a function transform the exception thrown from a function extend the basic function behavior completely override a function depending on specific conditions (e.g., for caching purposes) Basic \u00b6 Each interceptor implements the intercept() method, which takes two arguments. The first one is the ExecutionContext instance (exactly the same object as for guards ) and next_interceptor awaitable function that executes the next interceptor in the execution chain. import typing as t from abc import ABC , abstractmethod from ellar.common import IExecutionContext class EllarInterceptor ( ABC ): @abstractmethod async def intercept ( self , context : IExecutionContext , next_interceptor : t . Callable [ ... , t . Coroutine ] ) -> t . Any : \"\"\"implementation comes here\"\"\" Note intercept function of interceptor class is an asynchronous function. Execution context \u00b6 The ExecutionContext adds several new helper methods that provide additional details about the current execution process. These details can be helpful in building more generic interceptors that can work across a broad set of controllers, methods, and execution contexts. Learn more about ExecutionContext here . Next Interceptor Handler \u00b6 The second argument, next_interceptor , in intercept of EllarInterceptor class is used to invoke the route handler method at some point in your interceptor. If you don't call the next_interceptor method in your implementation of the intercept() method, the route handler method won't be executed at all. This approach means that the intercept() method effectively wraps the request/response cycle. As a result, you may implement custom logic both before and after the execution of the final route handler. It's clear that you can write code in your intercept() method that executes before calling next_interceptor() , but how do you affect what happens afterward? depending on the nature of the data returned by next_interceptor() , further manipulation can be done before final response to the client. Using Aspect Oriented Programming terminology, the invocation of the route handler (i.e., calling next_interceptor() ) is called a Pointcut, indicating that it's the point at which our additional logic is inserted. Consider, for example, an incoming POST /car request. This request is destined for the create() handler defined inside the CarController . If an interceptor which does not call the next_interceptor() method is called anywhere along the way, the create() method won't be executed. Once next_interceptor() is called, the create() handler will be triggered. And once the response is returned, additional operations can be performed on the data returned, and a final result returned to the client. Aspect interception \u00b6 The first use case we'll look at is to use an interceptor to log user interaction (e.g., storing user calls, asynchronously dispatching events or calculating a timestamp). We show a simple LoggingInterceptor below: import typing as t import logging import time from ellar.common import EllarInterceptor , IExecutionContext from ellar.di import injectable logger = logging . getLogger ( 'ellar' ) @injectable () class LoggingInterceptor ( EllarInterceptor ): async def intercept ( self , context : IExecutionContext , next_interceptor : t . Callable [ ... , t . Coroutine ] ) -> t . Any : logger . info ( 'Before Route Handler Execution...' ) start_time = time . time () res = await next_interceptor () logger . info ( f 'After Route Handler Execution.... { time . time () - start_time } s' ) return res Hint Interceptors, like controllers, providers, guards, and so on, can inject dependencies through their constructor . Binding interceptors \u00b6 In order to set up the interceptor, we use the @UseInterceptors() decorator imported from the ellar.common package. Like guards , interceptors can be controller-scoped, method-scoped, or global-scoped. from ellar.common import UseInterceptors , Controller @UseInterceptors ( LoggingInterceptor ) @Controller () class CarController : ... Note that we passed the LoggingInterceptor type (instead of an instance), leaving responsibility for instantiation to the framework and enabling dependency injection. As with guards, we can also pass an in-place instance: from ellar.common import UseInterceptors , Controller @UseInterceptors ( LoggingInterceptor ()) @Controller () class CarController : ... As mentioned, the construction above attaches the interceptor to every handler declared by this controller. If we want to restrict the interceptor's scope to a single method, we simply apply the decorator at the method level. In order to set up a global interceptor, we use the use_global_interceptors() method of the Ellar application instance: from ellar.core import AppFactory app = AppFactory . create_from_app_module ( ApplicationModule ) app . use_global_interceptors ( LoggingInterceptor ()) # OR # app.use_global_interceptors(LoggingInterceptor) Exception Handling \u00b6 You can also handle exception through on the process of request/response cycle before it gets handled by system exception handlers. class CustomException ( Exception ): pass @injectable class InterceptCustomException ( EllarInterceptor ): async def intercept ( self , context : IExecutionContext , next_interceptor : t . Callable [ ... , t . Coroutine ] ) -> t . Any : try : return await next_interceptor () except CustomException as cex : res = context . switch_to_http_connection () . get_response () res . status_code = 400 return { \"message\" : str ( cex )}","title":"Interceptors"},{"location":"overview/interceptors/#interceptors-aop-technique","text":"An interceptor is a class annotated with the @injectable() decorator and implements the EllarInterceptor interface. During request-response cycle, interceptors are called after middleware execution before route handler execution. Interceptors have a set of useful capabilities which are inspired by the Aspect Oriented Programming (AOP) technique technique. They make it possible to: bind extra logic before / after method execution transform the result returned from a function transform the exception thrown from a function extend the basic function behavior completely override a function depending on specific conditions (e.g., for caching purposes)","title":"Interceptors - (AOP) technique"},{"location":"overview/interceptors/#basic","text":"Each interceptor implements the intercept() method, which takes two arguments. The first one is the ExecutionContext instance (exactly the same object as for guards ) and next_interceptor awaitable function that executes the next interceptor in the execution chain. import typing as t from abc import ABC , abstractmethod from ellar.common import IExecutionContext class EllarInterceptor ( ABC ): @abstractmethod async def intercept ( self , context : IExecutionContext , next_interceptor : t . Callable [ ... , t . Coroutine ] ) -> t . Any : \"\"\"implementation comes here\"\"\" Note intercept function of interceptor class is an asynchronous function.","title":"Basic"},{"location":"overview/interceptors/#execution-context","text":"The ExecutionContext adds several new helper methods that provide additional details about the current execution process. These details can be helpful in building more generic interceptors that can work across a broad set of controllers, methods, and execution contexts. Learn more about ExecutionContext here .","title":"Execution context"},{"location":"overview/interceptors/#next-interceptor-handler","text":"The second argument, next_interceptor , in intercept of EllarInterceptor class is used to invoke the route handler method at some point in your interceptor. If you don't call the next_interceptor method in your implementation of the intercept() method, the route handler method won't be executed at all. This approach means that the intercept() method effectively wraps the request/response cycle. As a result, you may implement custom logic both before and after the execution of the final route handler. It's clear that you can write code in your intercept() method that executes before calling next_interceptor() , but how do you affect what happens afterward? depending on the nature of the data returned by next_interceptor() , further manipulation can be done before final response to the client. Using Aspect Oriented Programming terminology, the invocation of the route handler (i.e., calling next_interceptor() ) is called a Pointcut, indicating that it's the point at which our additional logic is inserted. Consider, for example, an incoming POST /car request. This request is destined for the create() handler defined inside the CarController . If an interceptor which does not call the next_interceptor() method is called anywhere along the way, the create() method won't be executed. Once next_interceptor() is called, the create() handler will be triggered. And once the response is returned, additional operations can be performed on the data returned, and a final result returned to the client.","title":"Next Interceptor Handler"},{"location":"overview/interceptors/#aspect-interception","text":"The first use case we'll look at is to use an interceptor to log user interaction (e.g., storing user calls, asynchronously dispatching events or calculating a timestamp). We show a simple LoggingInterceptor below: import typing as t import logging import time from ellar.common import EllarInterceptor , IExecutionContext from ellar.di import injectable logger = logging . getLogger ( 'ellar' ) @injectable () class LoggingInterceptor ( EllarInterceptor ): async def intercept ( self , context : IExecutionContext , next_interceptor : t . Callable [ ... , t . Coroutine ] ) -> t . Any : logger . info ( 'Before Route Handler Execution...' ) start_time = time . time () res = await next_interceptor () logger . info ( f 'After Route Handler Execution.... { time . time () - start_time } s' ) return res Hint Interceptors, like controllers, providers, guards, and so on, can inject dependencies through their constructor .","title":"Aspect interception"},{"location":"overview/interceptors/#binding-interceptors","text":"In order to set up the interceptor, we use the @UseInterceptors() decorator imported from the ellar.common package. Like guards , interceptors can be controller-scoped, method-scoped, or global-scoped. from ellar.common import UseInterceptors , Controller @UseInterceptors ( LoggingInterceptor ) @Controller () class CarController : ... Note that we passed the LoggingInterceptor type (instead of an instance), leaving responsibility for instantiation to the framework and enabling dependency injection. As with guards, we can also pass an in-place instance: from ellar.common import UseInterceptors , Controller @UseInterceptors ( LoggingInterceptor ()) @Controller () class CarController : ... As mentioned, the construction above attaches the interceptor to every handler declared by this controller. If we want to restrict the interceptor's scope to a single method, we simply apply the decorator at the method level. In order to set up a global interceptor, we use the use_global_interceptors() method of the Ellar application instance: from ellar.core import AppFactory app = AppFactory . create_from_app_module ( ApplicationModule ) app . use_global_interceptors ( LoggingInterceptor ()) # OR # app.use_global_interceptors(LoggingInterceptor)","title":"Binding interceptors"},{"location":"overview/interceptors/#exception-handling","text":"You can also handle exception through on the process of request/response cycle before it gets handled by system exception handlers. class CustomException ( Exception ): pass @injectable class InterceptCustomException ( EllarInterceptor ): async def intercept ( self , context : IExecutionContext , next_interceptor : t . Callable [ ... , t . Coroutine ] ) -> t . Any : try : return await next_interceptor () except CustomException as cex : res = context . switch_to_http_connection () . get_response () res . status_code = 400 return { \"message\" : str ( cex )}","title":"Exception Handling"},{"location":"overview/middleware/","text":"Middlewares \u00b6 Middlewares are functions that are called during requests before hitting a specific route handler. Middleware functions can modify request and response objects during the HTTP or WebSocket connection. Ellar Middlewares follows the Starlette ASGI Middleware contract. The middlewares are set up in a pipeline fashion that creates a chain of request-response cycles. During request, each ASGI Middleware must call another ASGI app passed to it during the middlewares instantiation and await its response. Info An ASGI type is any callable that takes scope , receive and send as arguments def app ( scope , receive , send ): pass # ASGI Middleware Interface import typing as t from starlette.types import ASGIApp , Receive , Scope , Send class EllarASGIMiddlewareStructure : def __init__ ( self , app : ASGIApp , ** other_options : t . Any ): self . app = app self . options = other_options async def __call__ ( self , scope : Scope , receive : Receive , send : Send ): await self . app ( scope , receive , send ) Actions that can be performed by middleware functions: Execute any code Make changes to request and response objects End the request-response cycle if need be Each middleware class or function must call app or call_next respectively else the request will be left without response Application Middleware \u00b6 Ellar applies some ASGI middleware necessary for resource protection, error handling, and context management. They include: CORSMiddleware : - 'Cross-Origin-Resources-Sharing' - Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. TrustedHostMiddleware : - Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. RequestServiceProviderMiddleware : - This inherits from ServerErrorMiddleware . It provides DI context during request and also ensures that application exceptions may return a custom 500 page, or display an application traceback in DEBUG mode. RequestVersioningMiddleware : This computes resource versioning info from request object based on configured resource versioning scheme at the application level. ExceptionMiddleware : - Adds exception handlers, so that some common exception raised with the application can be associated with handler functions. For example raising HTTPException(status_code=404) within an endpoint will end up rendering a custom 404 page. SessionMiddleware : controls session state using the session strategy configured in the application. IdentityMiddleware : controls all registered authentication schemes and provides user identity to all request Applying Middleware \u00b6 Middleware can be applied through the application config - MIDDLEWARES variable. Let's apply some middleware in our previous project. At the project root level, open config.py . Then apply the GZipMiddleware middleware as shown below. # project_name/config.py import typing as t from ellar.core.middleware import Middleware , GZipMiddleware ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] Hint This is how to apply any ASGI middlewares such as GZipMiddleware , EllarASGIMiddlewareStructure , and others available in the Starlette library. Dependency Injection \u00b6 In section above, we saw how middleware are registered to the application. But what if the middleware class depends on other services, how then should we configure it? The Middleware does all the work. For example, lets modify the GZipMiddleware class and make it depend on Config service. from ellar.core import Config from ellar.core.middleware import GZipMiddleware , Middleware from ellar.common.types import ASGIApp class CustomGZipMiddleware ( GZipMiddleware ): def __init__ ( self , app : ASGIApp , config : Config , minimum_size : int = 500 , compresslevel : int = 9 ): super () . __init__ ( app , minimum_size , compresslevel ) self . _config = config ## And in Config.py ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : list [ Middleware ] = [ Middleware ( CustomGZipMiddleware , minimum_size = 1000 ) ] In the example above, Middleware that wraps CustomGZipMiddleware with ensure dependent classes in CustomGZipMiddleware are resolved when instantiating CustomGZipMiddleware object. As you see, the config value was not provided but will be injected during runtime. Starlette Middlewares \u00b6 Let's explore other Starlette middlewares and other third party ASGI Middlewares GZipMiddleware \u00b6 Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. # project_name/config.py import typing as t from ellar.core.middleware import Middleware , GZipMiddleware ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 . The middleware won't GZip responses that already have a Content-Encoding set, to prevent them from being encoded twice. HTTPSRedirectMiddleware \u00b6 Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. # project_name/config.py import typing as t from ellar.core.middleware import Middleware , HTTPSRedirectMiddleware ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( HTTPSRedirectMiddleware ) ] TrustedHostMiddleware \u00b6 This middleware is already part of ellar application middlewares. The middleware takes an argument allowed_host which can be configured in the configuration class. # project_name/config.py import typing as t ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares ALLOWED_HOSTS : t . List [ str ] = [ 'example.com' , '*.example.com' ] ALLOWED_HOSTS - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent. CORSMiddleware \u00b6 Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. Since CORSMiddleware is part of default application middleware, let's see how to configure CORS arguments in ellar application. # project_name/config.py import typing as t ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares CORS_ALLOW_ORIGINS : t . List [ str ] = [ \"*\" ] CORS_ALLOW_METHODS : t . List [ str ] = [ \"*\" ] CORS_ALLOW_HEADERS : t . List [ str ] = [ \"*\" ] CORS_ALLOW_CREDENTIALS : bool = True CORS_ALLOW_ORIGIN_REGEX : t . Optional [ str ] = None CORS_EXPOSE_HEADERS : t . Sequence [ str ] = () CORS_MAX_AGE : int = 600 The following arguments are supported: CORS_ALLOW_ORIGINS - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. CORS_ALLOW_ORIGIN_REGEX - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . CORS_ALLOW_METHODS - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. CORS_ALLOW_HEADERS - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. CORS_ALLOW_CREDENTIALS - Indicate that cookies should be supported for cross-origin requests. Defaults to False . CORS_EXPOSE_HEADERS - Indicate any response headers that should be made accessible to the browser. Defaults to [] . CORS_MAX_AGE - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600 . CORS preflight requests \u00b6 These are any OPTIONS request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes. The middleware responds to two particular types of HTTP request Simple requests \u00b6 Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response. Other Middlewares \u00b6 There are many other ASGI middlewares. For example: Sentry Uvicorn's ProxyHeadersMiddleware MessagePack To see other available middlewares check Starlette's Middleware docs and the ASGI Awesome List . Technical Details Most of the available middlewares come directly from Starlette. Ellar provides few required for its basic functionalities","title":"Middlewares"},{"location":"overview/middleware/#middlewares","text":"Middlewares are functions that are called during requests before hitting a specific route handler. Middleware functions can modify request and response objects during the HTTP or WebSocket connection. Ellar Middlewares follows the Starlette ASGI Middleware contract. The middlewares are set up in a pipeline fashion that creates a chain of request-response cycles. During request, each ASGI Middleware must call another ASGI app passed to it during the middlewares instantiation and await its response. Info An ASGI type is any callable that takes scope , receive and send as arguments def app ( scope , receive , send ): pass # ASGI Middleware Interface import typing as t from starlette.types import ASGIApp , Receive , Scope , Send class EllarASGIMiddlewareStructure : def __init__ ( self , app : ASGIApp , ** other_options : t . Any ): self . app = app self . options = other_options async def __call__ ( self , scope : Scope , receive : Receive , send : Send ): await self . app ( scope , receive , send ) Actions that can be performed by middleware functions: Execute any code Make changes to request and response objects End the request-response cycle if need be Each middleware class or function must call app or call_next respectively else the request will be left without response","title":"Middlewares"},{"location":"overview/middleware/#application-middleware","text":"Ellar applies some ASGI middleware necessary for resource protection, error handling, and context management. They include: CORSMiddleware : - 'Cross-Origin-Resources-Sharing' - Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. TrustedHostMiddleware : - Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. RequestServiceProviderMiddleware : - This inherits from ServerErrorMiddleware . It provides DI context during request and also ensures that application exceptions may return a custom 500 page, or display an application traceback in DEBUG mode. RequestVersioningMiddleware : This computes resource versioning info from request object based on configured resource versioning scheme at the application level. ExceptionMiddleware : - Adds exception handlers, so that some common exception raised with the application can be associated with handler functions. For example raising HTTPException(status_code=404) within an endpoint will end up rendering a custom 404 page. SessionMiddleware : controls session state using the session strategy configured in the application. IdentityMiddleware : controls all registered authentication schemes and provides user identity to all request","title":"Application Middleware"},{"location":"overview/middleware/#applying-middleware","text":"Middleware can be applied through the application config - MIDDLEWARES variable. Let's apply some middleware in our previous project. At the project root level, open config.py . Then apply the GZipMiddleware middleware as shown below. # project_name/config.py import typing as t from ellar.core.middleware import Middleware , GZipMiddleware ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] Hint This is how to apply any ASGI middlewares such as GZipMiddleware , EllarASGIMiddlewareStructure , and others available in the Starlette library.","title":"Applying Middleware"},{"location":"overview/middleware/#dependency-injection","text":"In section above, we saw how middleware are registered to the application. But what if the middleware class depends on other services, how then should we configure it? The Middleware does all the work. For example, lets modify the GZipMiddleware class and make it depend on Config service. from ellar.core import Config from ellar.core.middleware import GZipMiddleware , Middleware from ellar.common.types import ASGIApp class CustomGZipMiddleware ( GZipMiddleware ): def __init__ ( self , app : ASGIApp , config : Config , minimum_size : int = 500 , compresslevel : int = 9 ): super () . __init__ ( app , minimum_size , compresslevel ) self . _config = config ## And in Config.py ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : list [ Middleware ] = [ Middleware ( CustomGZipMiddleware , minimum_size = 1000 ) ] In the example above, Middleware that wraps CustomGZipMiddleware with ensure dependent classes in CustomGZipMiddleware are resolved when instantiating CustomGZipMiddleware object. As you see, the config value was not provided but will be injected during runtime.","title":"Dependency Injection"},{"location":"overview/middleware/#starlette-middlewares","text":"Let's explore other Starlette middlewares and other third party ASGI Middlewares","title":"Starlette Middlewares"},{"location":"overview/middleware/#gzipmiddleware","text":"Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. # project_name/config.py import typing as t from ellar.core.middleware import Middleware , GZipMiddleware ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( GZipMiddleware , minimum_size = 1000 ) ] The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 . The middleware won't GZip responses that already have a Content-Encoding set, to prevent them from being encoded twice.","title":"GZipMiddleware"},{"location":"overview/middleware/#httpsredirectmiddleware","text":"Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. # project_name/config.py import typing as t from ellar.core.middleware import Middleware , HTTPSRedirectMiddleware ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( HTTPSRedirectMiddleware ) ]","title":"HTTPSRedirectMiddleware"},{"location":"overview/middleware/#trustedhostmiddleware","text":"This middleware is already part of ellar application middlewares. The middleware takes an argument allowed_host which can be configured in the configuration class. # project_name/config.py import typing as t ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares ALLOWED_HOSTS : t . List [ str ] = [ 'example.com' , '*.example.com' ] ALLOWED_HOSTS - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent.","title":"TrustedHostMiddleware"},{"location":"overview/middleware/#corsmiddleware","text":"Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. Since CORSMiddleware is part of default application middleware, let's see how to configure CORS arguments in ellar application. # project_name/config.py import typing as t ... class DevelopmentConfig ( BaseConfig ): DEBUG : bool = True # Application middlewares CORS_ALLOW_ORIGINS : t . List [ str ] = [ \"*\" ] CORS_ALLOW_METHODS : t . List [ str ] = [ \"*\" ] CORS_ALLOW_HEADERS : t . List [ str ] = [ \"*\" ] CORS_ALLOW_CREDENTIALS : bool = True CORS_ALLOW_ORIGIN_REGEX : t . Optional [ str ] = None CORS_EXPOSE_HEADERS : t . Sequence [ str ] = () CORS_MAX_AGE : int = 600 The following arguments are supported: CORS_ALLOW_ORIGINS - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. CORS_ALLOW_ORIGIN_REGEX - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . CORS_ALLOW_METHODS - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. CORS_ALLOW_HEADERS - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. CORS_ALLOW_CREDENTIALS - Indicate that cookies should be supported for cross-origin requests. Defaults to False . CORS_EXPOSE_HEADERS - Indicate any response headers that should be made accessible to the browser. Defaults to [] . CORS_MAX_AGE - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600 .","title":"CORSMiddleware"},{"location":"overview/middleware/#cors-preflight-requests","text":"These are any OPTIONS request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes. The middleware responds to two particular types of HTTP request","title":"CORS preflight requests"},{"location":"overview/middleware/#simple-requests","text":"Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.","title":"Simple requests"},{"location":"overview/middleware/#other-middlewares","text":"There are many other ASGI middlewares. For example: Sentry Uvicorn's ProxyHeadersMiddleware MessagePack To see other available middlewares check Starlette's Middleware docs and the ASGI Awesome List . Technical Details Most of the available middlewares come directly from Starlette. Ellar provides few required for its basic functionalities","title":"Other Middlewares"},{"location":"overview/module-router/","text":"Module Router \u00b6 ModuleRouter allows you to define your route handlers as standalone functions, providing an alternative to using classes. This can be beneficial for python developers who prefer using functions. It is important to note that using ModuleRouter does not limit your access to other features provided by Ellar. Usage \u00b6 The Ellar CLI tool generates a routers.py file in every create-module scaffold command. This file contains a quick guide on how to use the ModuleRouter class. Let's use the routers.py created in our previous project. And create two route functions, addition and subtraction # project_name/apps/car/routers.py \"\"\" Define endpoints routes in python function fashion example: my_router = ModuleRouter(\"/cats\", tag=\"Cats\", description=\"Cats Resource description\") @my_router.get('/') def index(request: Request): return {'detail': 'Welcome to Cats Resource'} \"\"\" from ellar.common import ModuleRouter math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/add' ) def addition ( a : int , b : int ): return a + b @math_router . get ( '/subtract' ) def subtraction ( a : int , b : int ): return a - b In the example above, we created math_router with a prefix /math and a OPENAPI tag 'math'. Then we added two routes addition(a:int, b:int) and subtraction(a:int, b:int) . Each route takes two query parameters, 'a' and 'b' which are declared as int type. These functions handle the query parameters and return the result of the mathematical operation. Next, we have to make the math_router visible to the application Registering Module Router \u00b6 Like controllers, ModuleRouters also need to be registered to their root module in order to be used in a web application. In the example provided above, the math_router would be registered under the project_name/apps/car/module.py file. This registration process typically involves importing the math_router and then adding it to the list of routers in the module.py file. This allows the router to be recognized by the application and its routes to be available to handle requests. from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .controllers import CarController from .routers import math_router @Module ( controllers = [ CarController ], providers = [], routers = [ math_router ], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass Accessing Other Request Object \u00b6 In functional route handle, we can access request object and response object through custom decorators or type annotation as shown below. By Type Annotation \u00b6 Let's inject request and response object in addition route handler function from our previous example from ellar.core import Request from ellar.common import ModuleRouter , Response math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/add' ) def addition ( request : Request , res : Response , a : int , b : int ): res . headers [ 'x-operation' ] = 'Addition' return dict ( is_request_object = isinstance ( request , Request ), is_response_object = isinstance ( res , Response ), operation_result = a + b ) By Custom decorators \u00b6 You can also achieve the same result by using custom decorator. from ellar.core import Request from ellar.common import ModuleRouter , Req , Res , Response math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/add' ) def addition ( * , request = Req (), res = Res (), a : int , b : int ): res . headers [ 'x-operation' ] = 'Addition' return dict ( is_request_object = isinstance ( request , Request ), is_response_object = isinstance ( res , Response ), operation_result = a + b ) Inject Services \u00b6 We can also inject service providers just like controller routes using the Provide function. from ellar.core import Config from ellar.common import ModuleRouter , Provide , Response math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/subtract' ) def subtraction ( a : int , b : int , res : Response , config = Provide ( Config )): res . headers [ 'x-operation' ] = 'Subtraction' return dict ( is_config = isinstance ( config , Config ), operation_result = a - b )","title":"Module Router"},{"location":"overview/module-router/#module-router","text":"ModuleRouter allows you to define your route handlers as standalone functions, providing an alternative to using classes. This can be beneficial for python developers who prefer using functions. It is important to note that using ModuleRouter does not limit your access to other features provided by Ellar.","title":"Module Router"},{"location":"overview/module-router/#usage","text":"The Ellar CLI tool generates a routers.py file in every create-module scaffold command. This file contains a quick guide on how to use the ModuleRouter class. Let's use the routers.py created in our previous project. And create two route functions, addition and subtraction # project_name/apps/car/routers.py \"\"\" Define endpoints routes in python function fashion example: my_router = ModuleRouter(\"/cats\", tag=\"Cats\", description=\"Cats Resource description\") @my_router.get('/') def index(request: Request): return {'detail': 'Welcome to Cats Resource'} \"\"\" from ellar.common import ModuleRouter math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/add' ) def addition ( a : int , b : int ): return a + b @math_router . get ( '/subtract' ) def subtraction ( a : int , b : int ): return a - b In the example above, we created math_router with a prefix /math and a OPENAPI tag 'math'. Then we added two routes addition(a:int, b:int) and subtraction(a:int, b:int) . Each route takes two query parameters, 'a' and 'b' which are declared as int type. These functions handle the query parameters and return the result of the mathematical operation. Next, we have to make the math_router visible to the application","title":"Usage"},{"location":"overview/module-router/#registering-module-router","text":"Like controllers, ModuleRouters also need to be registered to their root module in order to be used in a web application. In the example provided above, the math_router would be registered under the project_name/apps/car/module.py file. This registration process typically involves importing the math_router and then adding it to the list of routers in the module.py file. This allows the router to be recognized by the application and its routes to be available to handle requests. from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .controllers import CarController from .routers import math_router @Module ( controllers = [ CarController ], providers = [], routers = [ math_router ], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass","title":"Registering Module Router"},{"location":"overview/module-router/#accessing-other-request-object","text":"In functional route handle, we can access request object and response object through custom decorators or type annotation as shown below.","title":"Accessing Other Request Object"},{"location":"overview/module-router/#by-type-annotation","text":"Let's inject request and response object in addition route handler function from our previous example from ellar.core import Request from ellar.common import ModuleRouter , Response math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/add' ) def addition ( request : Request , res : Response , a : int , b : int ): res . headers [ 'x-operation' ] = 'Addition' return dict ( is_request_object = isinstance ( request , Request ), is_response_object = isinstance ( res , Response ), operation_result = a + b )","title":"By Type Annotation"},{"location":"overview/module-router/#by-custom-decorators","text":"You can also achieve the same result by using custom decorator. from ellar.core import Request from ellar.common import ModuleRouter , Req , Res , Response math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/add' ) def addition ( * , request = Req (), res = Res (), a : int , b : int ): res . headers [ 'x-operation' ] = 'Addition' return dict ( is_request_object = isinstance ( request , Request ), is_response_object = isinstance ( res , Response ), operation_result = a + b )","title":"By Custom decorators"},{"location":"overview/module-router/#inject-services","text":"We can also inject service providers just like controller routes using the Provide function. from ellar.core import Config from ellar.common import ModuleRouter , Provide , Response math_router = ModuleRouter ( '/math' , tag = 'Math' ) @math_router . get ( '/subtract' ) def subtraction ( a : int , b : int , res : Response , config = Provide ( Config )): res . headers [ 'x-operation' ] = 'Subtraction' return dict ( is_config = isinstance ( config , Config ), operation_result = a - b )","title":"Inject Services"},{"location":"overview/modules/","text":"Modules \u00b6 A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that exports a Module data and defines the module structure. The best way to organize your components is to build your projects as Modules . The ApplicationModule is the entry-point/root module to building the application module tree - the internal data structure used to resolve module and provider relationships and dependencies. Thus, the architecture resulting from most applications will include multiple modules with closely related functionality . Feature modules \u00b6 Building an application as a group of feature modules bundled together helps to manage complexity, have a maintainable, extendable, and testable code base, and encourage development using SOLID principles. A typical example of a feature module is the car project. The CarModule wraps all the services and controller that manages the car resource which makes it easy to maintain, extend, and testable. # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .services import CarRepository from .controllers import CarController @Module ( controllers = [ CarController ], providers = [ CarRepository ], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass Module Parameters \u00b6 Let's create a Module and take a quick overview of its parameters. from ellar.common import Module from ellar.core import ModuleBase @Module ( name = '' , modules = [], providers = [], controllers = [], routers = [], commands = [], base_directory = None , static_folder = 'static' , template_folder = 'templates' ) class BookModule ( ModuleBase ): pass name name of the module - it's irrelevant at the moment. modules List of Module dependencies providers the providers that will be instantiated by the Ellar injector and that may be shared at least across this module controllers the set of controllers defined in this module which have to be instantiated routers the set of ModuleRouter defined in this module commands the set of EllarTyper or command decorated functions base_directory root directory for this module to read static_folder and template_folder . Default is the root folder of the Module Class static_folder defines the static folder for this module - default: static template_folder defines the template folder for this module - default: templates Additional Module Configurations \u00b6 Module Events \u00b6 Every registered Module receives two event calls during its instantiation and when the application is ready. from ellar.common import Module from ellar.core import ModuleBase , Config , App @Module () class ModuleEventSample ( ModuleBase ): @classmethod def before_init ( cls , config : Config ) -> None : \"\"\"Called before creating Module object\"\"\" def application_ready ( self , app : App ) -> None : \"\"\"Called when application is ready - this is similar to @on_startup event\"\"\" before_init receives current app Config as a parameter and application_ready function receives App instance as parameter. Module Exceptions \u00b6 Custom exception handlers can be registered through modules. from ellar.common import Module , exception_handler , JSONResponse , Response , IHostContext from ellar.core import ModuleBase @Module () class ModuleExceptionSample ( ModuleBase ): @exception_handler ( 404 ) def exception_404_handler ( cls , context : IHostContext , exc : Exception ) -> Response : return JSONResponse ( dict ( detail = \"Resource not found.\" )) exception_404_handler will be register to the application at runtime during ModuleExceptionSample computation. Module Templating Filters \u00b6 We can also define Jinja2 templating filters in project Modules or any @Module() module. The defined filters are be passed down to Jinja2 environment instance alongside the template_folder value when creating TemplateLoader . from ellar.common import Module , template_global , template_filter from ellar.core import ModuleBase @Module () class ModuleTemplateFilterSample ( ModuleBase ): @template_filter () def double_filter ( cls , n ): return n * 2 @template_global () def double_global ( cls , n ): return n * 2 @template_filter ( name = \"dec_filter\" ) def double_filter_dec ( cls , n ): return n * 2 Dependency Injection \u00b6 A module class can inject providers as well (e.g., for configuration purposes): For example, from our sample project, the can inject Config to the CarModule # project_name/apps/car/module.py from ellar.common import Module from ellar.core import Config , ModuleBase from ellar.di import Container from .services import CarRepository from .controllers import CarController @Module ( controllers = [ CarController ], providers = [ CarRepository ], ) class CarModule ( ModuleBase ): def __init__ ( self , config : Config ): self . config = config def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass Module Middleware \u00b6 Middlewares functions can be defined at Module level with @middleware() function decorator. For example: from ellar.common import Module , middleware , IHostContext , PlainTextResponse from ellar.core import ModuleBase @Module () class ModuleMiddlewareSample ( ModuleBase ): @middleware () async def my_middleware_function_1 ( cls , context : IHostContext , call_next ): request = context . switch_to_http_connection () . get_request () # for http response only request . state . my_middleware_function_1 = True await call_next () @middleware () async def my_middleware_function_2 ( cls , context : IHostContext , call_next ): if context . get_type () == 'websocket' : websocket = context . switch_to_websocket () . get_client () websocket . state . my_middleware_function_2 = True await call_next () @middleware () async def my_middleware_function_3 ( cls , context : IHostContext , call_next ): connection = context . switch_to_http_connection () . get_client () # for http response only if connection . headers [ 'somekey' ]: # response = context.get_response() -> use the `response` to add extra definitions to things you want to see on return PlainTextResponse ( 'Header is not allowed.' ) await call_next () Things to note: middleware functions must be async . middleware functions can return a response or modify a response returned middleware functions must call call_next and await its actions as shown above. Injector Module \u00b6 EllarInjector is based on a python library injector . Both share similar Module features with few distinct features. As an added support, you can create or reuse modules from injector Modules. Info This type of module is used to configure injector bindings and providers for dependency injection purposes. from ellar.core import ModuleBase from ellar.di import Container from injector import provider class Name ( str ): pass class Description ( str ): pass class ExampleModule ( ModuleBase ): def register_services ( self , container : Container ) -> None : container . bind ( Name , to = 'Sherlock' ) @provider def describe ( self , name : Name ) -> Description : return Description ( ' %s is a man of astounding insight' % name ) The ExampleModule has registered Description and Name type to the injector and can be resolved respectively if required by any object. Read more on injector module use cases - Here .","title":"Modules"},{"location":"overview/modules/#modules","text":"A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that exports a Module data and defines the module structure. The best way to organize your components is to build your projects as Modules . The ApplicationModule is the entry-point/root module to building the application module tree - the internal data structure used to resolve module and provider relationships and dependencies. Thus, the architecture resulting from most applications will include multiple modules with closely related functionality .","title":"Modules"},{"location":"overview/modules/#feature-modules","text":"Building an application as a group of feature modules bundled together helps to manage complexity, have a maintainable, extendable, and testable code base, and encourage development using SOLID principles. A typical example of a feature module is the car project. The CarModule wraps all the services and controller that manages the car resource which makes it easy to maintain, extend, and testable. # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .services import CarRepository from .controllers import CarController @Module ( controllers = [ CarController ], providers = [ CarRepository ], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass","title":"Feature modules"},{"location":"overview/modules/#module-parameters","text":"Let's create a Module and take a quick overview of its parameters. from ellar.common import Module from ellar.core import ModuleBase @Module ( name = '' , modules = [], providers = [], controllers = [], routers = [], commands = [], base_directory = None , static_folder = 'static' , template_folder = 'templates' ) class BookModule ( ModuleBase ): pass name name of the module - it's irrelevant at the moment. modules List of Module dependencies providers the providers that will be instantiated by the Ellar injector and that may be shared at least across this module controllers the set of controllers defined in this module which have to be instantiated routers the set of ModuleRouter defined in this module commands the set of EllarTyper or command decorated functions base_directory root directory for this module to read static_folder and template_folder . Default is the root folder of the Module Class static_folder defines the static folder for this module - default: static template_folder defines the template folder for this module - default: templates","title":"Module Parameters"},{"location":"overview/modules/#additional-module-configurations","text":"","title":"Additional Module Configurations"},{"location":"overview/modules/#module-events","text":"Every registered Module receives two event calls during its instantiation and when the application is ready. from ellar.common import Module from ellar.core import ModuleBase , Config , App @Module () class ModuleEventSample ( ModuleBase ): @classmethod def before_init ( cls , config : Config ) -> None : \"\"\"Called before creating Module object\"\"\" def application_ready ( self , app : App ) -> None : \"\"\"Called when application is ready - this is similar to @on_startup event\"\"\" before_init receives current app Config as a parameter and application_ready function receives App instance as parameter.","title":"Module Events"},{"location":"overview/modules/#module-exceptions","text":"Custom exception handlers can be registered through modules. from ellar.common import Module , exception_handler , JSONResponse , Response , IHostContext from ellar.core import ModuleBase @Module () class ModuleExceptionSample ( ModuleBase ): @exception_handler ( 404 ) def exception_404_handler ( cls , context : IHostContext , exc : Exception ) -> Response : return JSONResponse ( dict ( detail = \"Resource not found.\" )) exception_404_handler will be register to the application at runtime during ModuleExceptionSample computation.","title":"Module Exceptions"},{"location":"overview/modules/#module-templating-filters","text":"We can also define Jinja2 templating filters in project Modules or any @Module() module. The defined filters are be passed down to Jinja2 environment instance alongside the template_folder value when creating TemplateLoader . from ellar.common import Module , template_global , template_filter from ellar.core import ModuleBase @Module () class ModuleTemplateFilterSample ( ModuleBase ): @template_filter () def double_filter ( cls , n ): return n * 2 @template_global () def double_global ( cls , n ): return n * 2 @template_filter ( name = \"dec_filter\" ) def double_filter_dec ( cls , n ): return n * 2","title":"Module Templating Filters"},{"location":"overview/modules/#dependency-injection","text":"A module class can inject providers as well (e.g., for configuration purposes): For example, from our sample project, the can inject Config to the CarModule # project_name/apps/car/module.py from ellar.common import Module from ellar.core import Config , ModuleBase from ellar.di import Container from .services import CarRepository from .controllers import CarController @Module ( controllers = [ CarController ], providers = [ CarRepository ], ) class CarModule ( ModuleBase ): def __init__ ( self , config : Config ): self . config = config def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass","title":"Dependency Injection"},{"location":"overview/modules/#module-middleware","text":"Middlewares functions can be defined at Module level with @middleware() function decorator. For example: from ellar.common import Module , middleware , IHostContext , PlainTextResponse from ellar.core import ModuleBase @Module () class ModuleMiddlewareSample ( ModuleBase ): @middleware () async def my_middleware_function_1 ( cls , context : IHostContext , call_next ): request = context . switch_to_http_connection () . get_request () # for http response only request . state . my_middleware_function_1 = True await call_next () @middleware () async def my_middleware_function_2 ( cls , context : IHostContext , call_next ): if context . get_type () == 'websocket' : websocket = context . switch_to_websocket () . get_client () websocket . state . my_middleware_function_2 = True await call_next () @middleware () async def my_middleware_function_3 ( cls , context : IHostContext , call_next ): connection = context . switch_to_http_connection () . get_client () # for http response only if connection . headers [ 'somekey' ]: # response = context.get_response() -> use the `response` to add extra definitions to things you want to see on return PlainTextResponse ( 'Header is not allowed.' ) await call_next () Things to note: middleware functions must be async . middleware functions can return a response or modify a response returned middleware functions must call call_next and await its actions as shown above.","title":"Module Middleware"},{"location":"overview/modules/#injector-module","text":"EllarInjector is based on a python library injector . Both share similar Module features with few distinct features. As an added support, you can create or reuse modules from injector Modules. Info This type of module is used to configure injector bindings and providers for dependency injection purposes. from ellar.core import ModuleBase from ellar.di import Container from injector import provider class Name ( str ): pass class Description ( str ): pass class ExampleModule ( ModuleBase ): def register_services ( self , container : Container ) -> None : container . bind ( Name , to = 'Sherlock' ) @provider def describe ( self , name : Name ) -> Description : return Description ( ' %s is a man of astounding insight' % name ) The ExampleModule has registered Description and Name type to the injector and can be resolved respectively if required by any object. Read more on injector module use cases - Here .","title":"Injector Module"},{"location":"overview/providers/","text":"Providers \u00b6 A provider is any class or object that is injectable as a dependency to another class when creating an instance of that class. Providers are like services, repositories services, factories, etc., classes that manage complex tasks. These providers can be made available to a controller, a route handler, or to another provider as a dependency. This concept is commonly known as Dependency Injection In Ellar, you can easily create a provider/injectable class by decorating that class with the @injectable() mark and stating the scope. from ellar.di import injectable , singleton_scope @injectable ( scope = singleton_scope ) class UserRepository : pass We have created a UserRepository provider that will help manage the loading and saving of user data to the database. Let's add this service to a controller. from ellar.di import injectable , singleton_scope from ellar.common import Controller , ControllerBase @injectable ( scope = singleton_scope ) class UserRepository : pass @Controller () class UserController ( ControllerBase ): def __init__ ( self , user_repo : UserRepository ) -> None : self . user_repo = user_repo Let's refactor our CarController and move some actions to a service. # project_name/apps/car/services.py import typing as t from ellar.di import injectable , singleton_scope from .schemas import CreateCarSerializer , CarSerializer @injectable ( scope = singleton_scope ) class CarRepository : def __init__ ( self ): self . _cars : t . List [ CarSerializer ] = [] def create_car ( self , data : CreateCarSerializer ) -> dict : data = CarSerializer ( id = len ( self . _cars ) + 1 , ** data . dict ()) self . _cars . append ( data ) return data . dict () def get_all ( self ) -> t . List [ CarSerializer ]: return self . _cars We have successfully created a CarRepository with a singleton scope. Let's wire it up to CarController . And rewrite some route handles. # project_name/apps/car/controllers.py from ellar.common import Body , Controller , get , post , Query , ControllerBase from .schemas import CreateCarSerializer , CarListFilter from .services import CarRepository @Controller ( '/car' ) class CarController ( ControllerBase ): def __init__ ( self , repo : CarRepository ): self . repo = repo @post () async def create ( self , payload : CreateCarSerializer = Body ()): result = self . repo . create_car ( payload ) result . update ( message = 'This action adds a new car' ) return result @get () async def get_all ( self , query : CarListFilter = Query ()): res = dict ( cars = self . repo . get_all (), message = f 'This action returns all cars at limit= { query . limit } , offset= { query . offset } ' ) return res ... We have defined CarRepository as a dependency to CarController and Ellar will resolve the CarRepository instance when creating the CarController instance. Info Every class dependency should be defined in the class constructor as a type annotation or Ellar won't be aware of the dependencies required for an object instantiation. Provider Registration \u00b6 To get this working, we need to expose the CarRepository to the CarModule module just like we did for the CarController . # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .services import CarRepository from .controllers import CarController @Module ( controllers = [ CarController ], providers = [ CarRepository ], routers = [], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass Other ways of registering a Provider \u00b6 There are two ways we can register/configure providers in EllarInjector IoC. ProviderConfig : \u00b6 With ProviderConfig , we can register a base_type against a concrete_type OR register a base_type against a value type. For example: # main.py from ellar.common import Module from ellar.core import ModuleBase , Config from ellar.di import ProviderConfig , injectable , EllarInjector from ellar.core.modules.ref import create_module_ref_factor injector = EllarInjector ( auto_bind = False ) class IFoo : pass class IFooB : pass @injectable class AFooClass ( IFoo , IFooB ): pass a_foo_instance = AFooClass () @Module ( providers = [ ProviderConfig ( IFoo , use_class = AFooClass ), ProviderConfig ( IFooB , use_value = a_foo_instance ) ] ) class AModule ( ModuleBase ): def __init__ ( self , ifoo : IFoo , ifoo_b : IFooB ): self . ifoo = ifoo self . ifoo_b = ifoo_b def validate_provider_config (): module_ref = create_module_ref_factor ( AModule , container = injector . container , config = Config (), ) module_ref . run_module_register_services () a_module_instance : AModule = injector . get ( AModule ) assert isinstance ( a_module_instance . ifoo , AFooClass ) assert isinstance ( a_module_instance . ifoo_b , AFooClass ) assert a_module_instance . ifoo_b == a_foo_instance if __name__ == \"__main__\" : validate_provider_config () In above example, we used ProviderConfig as a value type as in the case of IFooB type and as a concrete type as in the case of IFoo type. register_providers : \u00b6 We can also achieve the same by overriding register_providers in any Module class. For example: # main.py from ellar.common import Module from ellar.core import ModuleBase , Config from ellar.di import Container , EllarInjector , injectable from ellar.core.modules.ref import create_module_ref_factor injector = EllarInjector ( auto_bind = False ) class IFoo : pass class IFooB : pass @injectable # default scope=singleton_scope class AFooClass ( IFoo , IFooB ): pass a_foo_instance = AFooClass () @Module () class AModule ( ModuleBase ): def register_services ( self , container : Container ) -> None : container . register_singleton ( IFoo , AFooClass ) container . register ( IFooB , a_foo_instance ) def validate_register_services (): module_ref = create_module_ref_factor ( AModule , container = injector . container , config = Config (), ) module_ref . run_module_register_services () ifoo_b = injector . get ( IFooB ) ifoo = injector . get ( IFoo ) assert isinstance ( ifoo_b , AFooClass ) assert isinstance ( ifoo , AFooClass ) assert ifoo_b == a_foo_instance if __name__ == \"__main__\" : validate_register_services ()","title":"Providers"},{"location":"overview/providers/#providers","text":"A provider is any class or object that is injectable as a dependency to another class when creating an instance of that class. Providers are like services, repositories services, factories, etc., classes that manage complex tasks. These providers can be made available to a controller, a route handler, or to another provider as a dependency. This concept is commonly known as Dependency Injection In Ellar, you can easily create a provider/injectable class by decorating that class with the @injectable() mark and stating the scope. from ellar.di import injectable , singleton_scope @injectable ( scope = singleton_scope ) class UserRepository : pass We have created a UserRepository provider that will help manage the loading and saving of user data to the database. Let's add this service to a controller. from ellar.di import injectable , singleton_scope from ellar.common import Controller , ControllerBase @injectable ( scope = singleton_scope ) class UserRepository : pass @Controller () class UserController ( ControllerBase ): def __init__ ( self , user_repo : UserRepository ) -> None : self . user_repo = user_repo Let's refactor our CarController and move some actions to a service. # project_name/apps/car/services.py import typing as t from ellar.di import injectable , singleton_scope from .schemas import CreateCarSerializer , CarSerializer @injectable ( scope = singleton_scope ) class CarRepository : def __init__ ( self ): self . _cars : t . List [ CarSerializer ] = [] def create_car ( self , data : CreateCarSerializer ) -> dict : data = CarSerializer ( id = len ( self . _cars ) + 1 , ** data . dict ()) self . _cars . append ( data ) return data . dict () def get_all ( self ) -> t . List [ CarSerializer ]: return self . _cars We have successfully created a CarRepository with a singleton scope. Let's wire it up to CarController . And rewrite some route handles. # project_name/apps/car/controllers.py from ellar.common import Body , Controller , get , post , Query , ControllerBase from .schemas import CreateCarSerializer , CarListFilter from .services import CarRepository @Controller ( '/car' ) class CarController ( ControllerBase ): def __init__ ( self , repo : CarRepository ): self . repo = repo @post () async def create ( self , payload : CreateCarSerializer = Body ()): result = self . repo . create_car ( payload ) result . update ( message = 'This action adds a new car' ) return result @get () async def get_all ( self , query : CarListFilter = Query ()): res = dict ( cars = self . repo . get_all (), message = f 'This action returns all cars at limit= { query . limit } , offset= { query . offset } ' ) return res ... We have defined CarRepository as a dependency to CarController and Ellar will resolve the CarRepository instance when creating the CarController instance. Info Every class dependency should be defined in the class constructor as a type annotation or Ellar won't be aware of the dependencies required for an object instantiation.","title":"Providers"},{"location":"overview/providers/#provider-registration","text":"To get this working, we need to expose the CarRepository to the CarModule module just like we did for the CarController . # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .services import CarRepository from .controllers import CarController @Module ( controllers = [ CarController ], providers = [ CarRepository ], routers = [], ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass","title":"Provider Registration"},{"location":"overview/providers/#other-ways-of-registering-a-provider","text":"There are two ways we can register/configure providers in EllarInjector IoC.","title":"Other ways of registering a Provider"},{"location":"overview/providers/#providerconfig","text":"With ProviderConfig , we can register a base_type against a concrete_type OR register a base_type against a value type. For example: # main.py from ellar.common import Module from ellar.core import ModuleBase , Config from ellar.di import ProviderConfig , injectable , EllarInjector from ellar.core.modules.ref import create_module_ref_factor injector = EllarInjector ( auto_bind = False ) class IFoo : pass class IFooB : pass @injectable class AFooClass ( IFoo , IFooB ): pass a_foo_instance = AFooClass () @Module ( providers = [ ProviderConfig ( IFoo , use_class = AFooClass ), ProviderConfig ( IFooB , use_value = a_foo_instance ) ] ) class AModule ( ModuleBase ): def __init__ ( self , ifoo : IFoo , ifoo_b : IFooB ): self . ifoo = ifoo self . ifoo_b = ifoo_b def validate_provider_config (): module_ref = create_module_ref_factor ( AModule , container = injector . container , config = Config (), ) module_ref . run_module_register_services () a_module_instance : AModule = injector . get ( AModule ) assert isinstance ( a_module_instance . ifoo , AFooClass ) assert isinstance ( a_module_instance . ifoo_b , AFooClass ) assert a_module_instance . ifoo_b == a_foo_instance if __name__ == \"__main__\" : validate_provider_config () In above example, we used ProviderConfig as a value type as in the case of IFooB type and as a concrete type as in the case of IFoo type.","title":"ProviderConfig:"},{"location":"overview/providers/#register_providers","text":"We can also achieve the same by overriding register_providers in any Module class. For example: # main.py from ellar.common import Module from ellar.core import ModuleBase , Config from ellar.di import Container , EllarInjector , injectable from ellar.core.modules.ref import create_module_ref_factor injector = EllarInjector ( auto_bind = False ) class IFoo : pass class IFooB : pass @injectable # default scope=singleton_scope class AFooClass ( IFoo , IFooB ): pass a_foo_instance = AFooClass () @Module () class AModule ( ModuleBase ): def register_services ( self , container : Container ) -> None : container . register_singleton ( IFoo , AFooClass ) container . register ( IFooB , a_foo_instance ) def validate_register_services (): module_ref = create_module_ref_factor ( AModule , container = injector . container , config = Config (), ) module_ref . run_module_register_services () ifoo_b = injector . get ( IFooB ) ifoo = injector . get ( IFoo ) assert isinstance ( ifoo_b , AFooClass ) assert isinstance ( ifoo , AFooClass ) assert ifoo_b == a_foo_instance if __name__ == \"__main__\" : validate_register_services ()","title":"register_providers:"},{"location":"overview/step-one/","text":"Step One \u00b6 You will learn the core fundamentals of Ellar with this set of articles. We are going to build a basic CRUD application with features that cover a lot of ground at an introductory level. Library Dependencies \u00b6 Ellar core depends on: python >= 3.7 Starlette Injector Quick Step \u00b6 Using the Ellar CLI, you can easily set up a new project by running the following commands in your OS terminal: $( venv ) pip install ellar-cli $( venv ) ellar new project-name The new command will create a project-name project directory with other necessary files needed for the Ellar CLI tool to properly manage your project. Also, some boilerplate files are populated and installed in a new project_name to get structure to your project. project-name/ \u251c\u2500 project_name/ \u2502 \u251c\u2500 core/ \u2502 \u251c\u2500 domain/ \u2502 \u251c\u2500 config.py \u2502 \u251c\u2500 root_module.py \u2502 \u251c\u2500 server.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 pyproject.toml \u251c\u2500 README.md A brief overview of generated core files: pyproject.toml Python project metadata store. README.md Project Description and documentation. project_name.core Core/business logic folder. project_name.domain Domain logic folder. project_name.config Application configuration file project_name.root_module The root module of the application project_name.server The entry file of the application which uses the core function AppFactory to create an application instance. In project_name.server , we create the application instance using the AppFactory.create_from_app_module function. # project_name/server.py import os from ellar.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"project_name.config:DevelopmentConfig\" ), ) There are two ways to create an Ellar application using the AppFactory , create_from_app_module and create_app . Both provides all necessary parameter for creating Ellar application Run your project \u00b6 Ellar runs UVICORN - ASGI Server under the hood. $( venv ) cd project-name $( venv ) ellar runserver --reload --reload is to watch for file changes INFO: Will watch for changes in these directories: [ '/home/user/working-directory' ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) INFO: Started reloader process [ 2934815 ] using WatchFiles INFO: APP SETTINGS MODULE: project_name.config:DevelopmentConfig INFO: Started server process [ 2934818 ] INFO: Waiting for application startup. INFO: Application startup complete. Now go to http://127.0.0.1:8000 For more info on Ellar CLI, click here To run the application with a different configuration, In project_name/config , Add a ProductionConfig ... class ProductionConfig ( BaseConfig ): DEBUG : bool = False Next, export ProductionConfig string import to the environment with ELLAR_CONFIG_MODULE as key. $( venv ) export ELLAR_CONFIG_MODULE = 'project_name.config:ProductionConfig' $( venv ) ellar runserver That will start up the application using ProductionConfig INFO: APP SETTINGS MODULE: project_name.config:ProductionConfig INFO: Started server process [ 2934818 ] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) One last thing, before we move to the next page, we need to create an app module . Lets add a car module/app to our project: $( venv ) ellar create-module car apps/ The result of this CLI command is stored in project-name/project_name/apps apps/ \u251c\u2500 car/ \u2502 \u251c\u2500 tests/ \u2502 \u2502 \u251c\u2500 test_controllers.py \u2502 \u2502 \u251c\u2500 test_routers.py \u2502 \u2502 \u251c\u2500 test_services.py \u2502 \u251c\u2500 controllers.py \u2502 \u251c\u2500 module.py \u2502 \u251c\u2500 schemas.py \u2502 \u251c\u2500 services.py \u2502 \u251c\u2500 __init__.py Brief overview of the generated files: car.controllers A basic controller with an index route. car.module.py car module/app Module metadata definition. car.services.py For Car module service declarations. car.schemas.py Data-transfer-object or Serializers declarations. car.tests/ testing directory for the car module. To finish up with the created car module, we need to register it to the project_name.root_module.py # project_name/root_module.py ... from .apps.cars.module import CarModule @Module ( modules = [ HomeModule , CarModule ]) class ApplicationModule ( ModuleBase ): @exception_handler ( 404 ) def exception_404_handler ( cls , request : Request , exc : Exception ) -> Response : return JSONResponse ( dict ( detail = \"Resource not found.\" )) That's it. Goto your browser and visit: http://localhost:8000/car/ { \"detail\" : \"Welcome Car Resource\" } Enabling OpenAPI Docs \u00b6 To set up OPENAPI documentation, we need to go back to the project folder. In the server.py then add the below. # project_name/server.py import os from ellar.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.openapi import OpenAPIDocumentModule , OpenAPIDocumentBuilder , SwaggerDocumentGenerator from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"project_name.config:DevelopmentConfig\" ), ) document_builder = OpenAPIDocumentBuilder () document_builder . set_title ( 'Project Name API' ) \\ . set_version ( '1.0.0' ) \\ . set_contact ( name = 'Eadwin' , url = 'https://www.yahoo.com' , email = 'eadwin@gmail.com' ) \\ . set_license ( 'MIT Licence' , url = 'https://www.google.com' ) document = document_builder . build_document ( application ) module_config = OpenAPIDocumentModule . setup ( document_generator = SwaggerDocumentGenerator (), document = document , guards = [] ) application . install_module ( module_config ) Goto your browser and visit: http://localhost:8000/docs/","title":"Step One"},{"location":"overview/step-one/#step-one","text":"You will learn the core fundamentals of Ellar with this set of articles. We are going to build a basic CRUD application with features that cover a lot of ground at an introductory level.","title":"Step One"},{"location":"overview/step-one/#library-dependencies","text":"Ellar core depends on: python >= 3.7 Starlette Injector","title":"Library Dependencies"},{"location":"overview/step-one/#quick-step","text":"Using the Ellar CLI, you can easily set up a new project by running the following commands in your OS terminal: $( venv ) pip install ellar-cli $( venv ) ellar new project-name The new command will create a project-name project directory with other necessary files needed for the Ellar CLI tool to properly manage your project. Also, some boilerplate files are populated and installed in a new project_name to get structure to your project. project-name/ \u251c\u2500 project_name/ \u2502 \u251c\u2500 core/ \u2502 \u251c\u2500 domain/ \u2502 \u251c\u2500 config.py \u2502 \u251c\u2500 root_module.py \u2502 \u251c\u2500 server.py \u2502 \u251c\u2500 __init__.py \u251c\u2500 tests/ \u2502 \u251c\u2500 __init__.py \u251c\u2500 pyproject.toml \u251c\u2500 README.md A brief overview of generated core files: pyproject.toml Python project metadata store. README.md Project Description and documentation. project_name.core Core/business logic folder. project_name.domain Domain logic folder. project_name.config Application configuration file project_name.root_module The root module of the application project_name.server The entry file of the application which uses the core function AppFactory to create an application instance. In project_name.server , we create the application instance using the AppFactory.create_from_app_module function. # project_name/server.py import os from ellar.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"project_name.config:DevelopmentConfig\" ), ) There are two ways to create an Ellar application using the AppFactory , create_from_app_module and create_app . Both provides all necessary parameter for creating Ellar application","title":"Quick Step"},{"location":"overview/step-one/#run-your-project","text":"Ellar runs UVICORN - ASGI Server under the hood. $( venv ) cd project-name $( venv ) ellar runserver --reload --reload is to watch for file changes INFO: Will watch for changes in these directories: [ '/home/user/working-directory' ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) INFO: Started reloader process [ 2934815 ] using WatchFiles INFO: APP SETTINGS MODULE: project_name.config:DevelopmentConfig INFO: Started server process [ 2934818 ] INFO: Waiting for application startup. INFO: Application startup complete. Now go to http://127.0.0.1:8000 For more info on Ellar CLI, click here To run the application with a different configuration, In project_name/config , Add a ProductionConfig ... class ProductionConfig ( BaseConfig ): DEBUG : bool = False Next, export ProductionConfig string import to the environment with ELLAR_CONFIG_MODULE as key. $( venv ) export ELLAR_CONFIG_MODULE = 'project_name.config:ProductionConfig' $( venv ) ellar runserver That will start up the application using ProductionConfig INFO: APP SETTINGS MODULE: project_name.config:ProductionConfig INFO: Started server process [ 2934818 ] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) One last thing, before we move to the next page, we need to create an app module . Lets add a car module/app to our project: $( venv ) ellar create-module car apps/ The result of this CLI command is stored in project-name/project_name/apps apps/ \u251c\u2500 car/ \u2502 \u251c\u2500 tests/ \u2502 \u2502 \u251c\u2500 test_controllers.py \u2502 \u2502 \u251c\u2500 test_routers.py \u2502 \u2502 \u251c\u2500 test_services.py \u2502 \u251c\u2500 controllers.py \u2502 \u251c\u2500 module.py \u2502 \u251c\u2500 schemas.py \u2502 \u251c\u2500 services.py \u2502 \u251c\u2500 __init__.py Brief overview of the generated files: car.controllers A basic controller with an index route. car.module.py car module/app Module metadata definition. car.services.py For Car module service declarations. car.schemas.py Data-transfer-object or Serializers declarations. car.tests/ testing directory for the car module. To finish up with the created car module, we need to register it to the project_name.root_module.py # project_name/root_module.py ... from .apps.cars.module import CarModule @Module ( modules = [ HomeModule , CarModule ]) class ApplicationModule ( ModuleBase ): @exception_handler ( 404 ) def exception_404_handler ( cls , request : Request , exc : Exception ) -> Response : return JSONResponse ( dict ( detail = \"Resource not found.\" )) That's it. Goto your browser and visit: http://localhost:8000/car/ { \"detail\" : \"Welcome Car Resource\" }","title":"Run your project"},{"location":"overview/step-one/#enabling-openapi-docs","text":"To set up OPENAPI documentation, we need to go back to the project folder. In the server.py then add the below. # project_name/server.py import os from ellar.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.openapi import OpenAPIDocumentModule , OpenAPIDocumentBuilder , SwaggerDocumentGenerator from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"project_name.config:DevelopmentConfig\" ), ) document_builder = OpenAPIDocumentBuilder () document_builder . set_title ( 'Project Name API' ) \\ . set_version ( '1.0.0' ) \\ . set_contact ( name = 'Eadwin' , url = 'https://www.yahoo.com' , email = 'eadwin@gmail.com' ) \\ . set_license ( 'MIT Licence' , url = 'https://www.google.com' ) document = document_builder . build_document ( application ) module_config = OpenAPIDocumentModule . setup ( document_generator = SwaggerDocumentGenerator (), document = document , guards = [] ) application . install_module ( module_config ) Goto your browser and visit: http://localhost:8000/docs/","title":"Enabling OpenAPI Docs"},{"location":"security/authentication/","text":"Coming Soon \u00b6","title":"Authentication"},{"location":"security/authentication/#coming-soon","text":"","title":"Coming Soon"},{"location":"security/authorization/","text":"Coming Soon \u00b6","title":"Authorization"},{"location":"security/authorization/#coming-soon","text":"","title":"Coming Soon"},{"location":"security/csrf/","text":"CSRF or XSRF \u00b6 CSRF or XSRF is a security vulnerability and attack method in web applications. It involves tricking a user's browser into sending unauthorized requests to a website where the user is authenticated, allowing attackers to perform actions on behalf of the user. Available ASGI CSRF Middlewares \u00b6 Piccolo CSRF Middleware Starlette CSRF These middlewares can be configured as every other asgi middleware as shown in middleware docs to work in Ellar For example, using Starlette CSRF Middleware # config.py import typing as t from ellar.core.middleware import Middleware from starlette_csrf import CSRFMiddleware class Development ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( CSRFMiddleware , secret = \"__CHANGE_ME__\" , cookie_name = 'csrftoken' , safe_methods = { \"GET\" , \"HEAD\" , \"OPTIONS\" , \"TRACE\" } ) ]","title":"CSRF Protection"},{"location":"security/csrf/#csrf-or-xsrf","text":"CSRF or XSRF is a security vulnerability and attack method in web applications. It involves tricking a user's browser into sending unauthorized requests to a website where the user is authenticated, allowing attackers to perform actions on behalf of the user.","title":"CSRF or XSRF"},{"location":"security/csrf/#available-asgi-csrf-middlewares","text":"Piccolo CSRF Middleware Starlette CSRF These middlewares can be configured as every other asgi middleware as shown in middleware docs to work in Ellar For example, using Starlette CSRF Middleware # config.py import typing as t from ellar.core.middleware import Middleware from starlette_csrf import CSRFMiddleware class Development ( BaseConfig ): DEBUG : bool = True # Application middlewares MIDDLEWARE : t . Sequence [ Middleware ] = [ Middleware ( CSRFMiddleware , secret = \"__CHANGE_ME__\" , cookie_name = 'csrftoken' , safe_methods = { \"GET\" , \"HEAD\" , \"OPTIONS\" , \"TRACE\" } ) ]","title":"Available ASGI CSRF Middlewares"},{"location":"security/sessions/","text":"Coming Soon \u00b6","title":"Sessions"},{"location":"security/sessions/#coming-soon","text":"","title":"Coming Soon"},{"location":"security/throttling/","text":"Rate Limiting \u00b6 A common technique to protect applications from brute-force attacks is rate-limiting. To get started, you'll need to install the ellar-throttler package. $( venv ) pip install ellar-throttler ThrottlerModule \u00b6 The ThrottlerModule is the main entry point for this package, and can be used in a synchronous or asynchronous manner. All the needs to be passed is the ttl , the time to live in seconds for the request tracker, and the limit , or how many times an endpoint can be hit before returning a 429 status code. from ellar.common import Module from ellar_throttler import ThrottlerModule @Module ( modules = [ ThrottlerModule . setup ( ttl = 60 , limit = 10 ) ]) class ApplicationModule : pass The above would mean that 10 requests from the same IP can be made to a single endpoint in 1 minute. from ellar.common import Module from ellar_throttler import ThrottlerModule , ThrottlerGuard from ellar.core import Config , ModuleSetup , DynamicModule def throttler_module_factory ( module : ThrottlerModule , config : Config ) -> DynamicModule : return module . setup ( ttl = config [ 'THROTTLE_TTL' ], limit = config [ 'THROTTLE_LIMIT' ]) @Module ( modules = [ ModuleSetup ( ThrottlerModule , inject = [ Config ], factory = throttler_module_factory ) ]) class ApplicationModule : pass # server.py application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [ ThrottlerGuard ] ) The above is also a valid configuration for ThrottleModule registration if you want to work with config. If you add the ThrottlerGuard to your application global_guards , then all the incoming requests will be throttled by default. This can also be omitted in favor of @UseGuards(ThrottlerGuard) . The global guard check can be skipped using the @skip_throttle() decorator mentioned later. Example with @UseGuards(ThrottlerGuard) # project_name/controller.py from ellar.common import Controller , UseGuards from ellar_throttler import throttle , ThrottlerGuard @Controller () class AppController : @UseGuards ( ThrottlerGuard ) @throttle ( limit = 5 , ttl = 30 ) def normal ( self ): pass ThrottlerModule Configuration Options: \u00b6 ttl : the number of seconds that each request will last in storage limit : the maximum number of requests within the TTL limit storage : the storage setting for how to keep track of the requests. see throttler storage Decorators \u00b6 @throttle() \u00b6 @throttle(*, limit: int = 20, ttl: int = 60) This decorator will set THROTTLER_LIMIT and THROTTLER_TTL metadata on the route, for retrieval from the Reflector class. It can be applied to controllers and routes. @skip_throttle() \u00b6 @skip_throttle(skip: bool = True) This decorator can be used to skip a route or a class or to negate the skipping of a route in a class that is skipped. # project_name/controller.py from ellar.common import Controller , UseGuards from ellar_throttler import ThrottlerGuard , skip_throttle @skip_throttle () @Controller () @UseGuards ( ThrottlerGuard ) class AppController : def do_skip ( self ): pass @skip_throttle ( skip = False ) def dont_skip ( self ): pass In the above controller, dont_skip would be counted against and rate-limited while do_skip would not be limited in any way. ThrottlerStorage \u00b6 Interface to define the methods to handle the details when it comes to keeping track of the requests. Currently, the key is seen as an MD5 hash of the IP the class name and the function name , to ensure that no unsafe characters are used. The interface looks like this: import typing as t from abc import ABC , abstractmethod class IThrottlerStorage ( ABC ): @property @abstractmethod def storage ( self ) -> t . Dict [ str , ThrottlerStorageOption ]: \"\"\" The internal storage with all the request records. The key is a hashed key based on the current context and IP. :return: \"\"\" @abstractmethod async def increment ( self , key : str , ttl : int ) -> ThrottlerStorageRecord : \"\"\" Increment the amount of requests for a given record. The record will automatically be removed from the storage once its TTL has been reached. :param key: :param ttl: :return: \"\"\" So long as the Storage service implements this interface, it should be usable by the ThrottlerGuard . ThrottlerStorageService \u00b6 ThrottlerStorageService extends IThrottlerStorage which defines the methods to handle the details when it comes to keeping track of the requests. By default, ThrottlerModule uses ThrottlerStorageService when storage option is not provided. CacheThrottlerStorageService \u00b6 CacheThrottlerStorageService uses the default cache that is set up in the CacheModule to track throttling. It depends on ICacheService which provided by CacheModule . A quick example of how to set up ThrottlerModule with CacheThrottlerStorageService : from ellar.common import Module from ellar_throttler import ThrottlerModule , CacheThrottlerStorageService from ellar.cache import CacheModule from ellar.cache.backends.local_cache import LocalMemCacheBackend @Module ( modules = [ ThrottlerModule . setup ( ttl = 60 , limit = 10 , storage = CacheThrottlerStorageService ), CacheModule . setup ( default = LocalMemCacheBackend ( key_prefix = 'local' )) ]) class ApplicationModule : pass Proxies \u00b6 If you are working with multiple proxies, you can override the get_tracker() method to pull the value from the header or install ProxyHeadersMiddleware # throttler_behind_proxy.guard.py from ellar_throttler import ThrottlerGuard from ellar.di import injectable from ellar.core.connection import HTTPConnection @injectable () class ThrottlerBehindProxyGuard ( ThrottlerGuard ): def get_tracker ( self , connection : HTTPConnection ) -> str : return connection . client . host # individualize IP extraction to meet your own needs # project_name/controller.py from .throttler_behind_proxy import ThrottlerBehindProxyGuard @Controller ( '' ) @UseGuards ( ThrottlerBehindProxyGuard ) class AppController : pass Working with WebSockets \u00b6 To work with Websockets you can extend the ThrottlerGuard and override the handle_request method with the code below: from ellar_throttler import ThrottlerGuard from ellar.di import injectable from ellar.common import IExecutionContext from ellar_throttler import ThrottledException @injectable () class WsThrottleGuard ( ThrottlerGuard ): async def handle_request ( self , context : IExecutionContext , limit : int , ttl : int ) -> bool : websocket_client = context . switch_to_websocket () . get_client () host = websocket_client . client . host key = self . generate_key ( context , host ) result = await self . storage_service . increment ( key , ttl ) # Throw an error when the user reached their limit. if result . total_hits > limit : raise ThrottledException ( wait = result . time_to_expire ) return True","title":"Rate Limiting"},{"location":"security/throttling/#rate-limiting","text":"A common technique to protect applications from brute-force attacks is rate-limiting. To get started, you'll need to install the ellar-throttler package. $( venv ) pip install ellar-throttler","title":"Rate Limiting"},{"location":"security/throttling/#throttlermodule","text":"The ThrottlerModule is the main entry point for this package, and can be used in a synchronous or asynchronous manner. All the needs to be passed is the ttl , the time to live in seconds for the request tracker, and the limit , or how many times an endpoint can be hit before returning a 429 status code. from ellar.common import Module from ellar_throttler import ThrottlerModule @Module ( modules = [ ThrottlerModule . setup ( ttl = 60 , limit = 10 ) ]) class ApplicationModule : pass The above would mean that 10 requests from the same IP can be made to a single endpoint in 1 minute. from ellar.common import Module from ellar_throttler import ThrottlerModule , ThrottlerGuard from ellar.core import Config , ModuleSetup , DynamicModule def throttler_module_factory ( module : ThrottlerModule , config : Config ) -> DynamicModule : return module . setup ( ttl = config [ 'THROTTLE_TTL' ], limit = config [ 'THROTTLE_LIMIT' ]) @Module ( modules = [ ModuleSetup ( ThrottlerModule , inject = [ Config ], factory = throttler_module_factory ) ]) class ApplicationModule : pass # server.py application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [ ThrottlerGuard ] ) The above is also a valid configuration for ThrottleModule registration if you want to work with config. If you add the ThrottlerGuard to your application global_guards , then all the incoming requests will be throttled by default. This can also be omitted in favor of @UseGuards(ThrottlerGuard) . The global guard check can be skipped using the @skip_throttle() decorator mentioned later. Example with @UseGuards(ThrottlerGuard) # project_name/controller.py from ellar.common import Controller , UseGuards from ellar_throttler import throttle , ThrottlerGuard @Controller () class AppController : @UseGuards ( ThrottlerGuard ) @throttle ( limit = 5 , ttl = 30 ) def normal ( self ): pass","title":"ThrottlerModule"},{"location":"security/throttling/#throttlermodule-configuration-options","text":"ttl : the number of seconds that each request will last in storage limit : the maximum number of requests within the TTL limit storage : the storage setting for how to keep track of the requests. see throttler storage","title":"ThrottlerModule Configuration Options:"},{"location":"security/throttling/#decorators","text":"","title":"Decorators"},{"location":"security/throttling/#throttle","text":"@throttle(*, limit: int = 20, ttl: int = 60) This decorator will set THROTTLER_LIMIT and THROTTLER_TTL metadata on the route, for retrieval from the Reflector class. It can be applied to controllers and routes.","title":"@throttle()"},{"location":"security/throttling/#skip_throttle","text":"@skip_throttle(skip: bool = True) This decorator can be used to skip a route or a class or to negate the skipping of a route in a class that is skipped. # project_name/controller.py from ellar.common import Controller , UseGuards from ellar_throttler import ThrottlerGuard , skip_throttle @skip_throttle () @Controller () @UseGuards ( ThrottlerGuard ) class AppController : def do_skip ( self ): pass @skip_throttle ( skip = False ) def dont_skip ( self ): pass In the above controller, dont_skip would be counted against and rate-limited while do_skip would not be limited in any way.","title":"@skip_throttle()"},{"location":"security/throttling/#throttlerstorage","text":"Interface to define the methods to handle the details when it comes to keeping track of the requests. Currently, the key is seen as an MD5 hash of the IP the class name and the function name , to ensure that no unsafe characters are used. The interface looks like this: import typing as t from abc import ABC , abstractmethod class IThrottlerStorage ( ABC ): @property @abstractmethod def storage ( self ) -> t . Dict [ str , ThrottlerStorageOption ]: \"\"\" The internal storage with all the request records. The key is a hashed key based on the current context and IP. :return: \"\"\" @abstractmethod async def increment ( self , key : str , ttl : int ) -> ThrottlerStorageRecord : \"\"\" Increment the amount of requests for a given record. The record will automatically be removed from the storage once its TTL has been reached. :param key: :param ttl: :return: \"\"\" So long as the Storage service implements this interface, it should be usable by the ThrottlerGuard .","title":"ThrottlerStorage"},{"location":"security/throttling/#throttlerstorageservice","text":"ThrottlerStorageService extends IThrottlerStorage which defines the methods to handle the details when it comes to keeping track of the requests. By default, ThrottlerModule uses ThrottlerStorageService when storage option is not provided.","title":"ThrottlerStorageService"},{"location":"security/throttling/#cachethrottlerstorageservice","text":"CacheThrottlerStorageService uses the default cache that is set up in the CacheModule to track throttling. It depends on ICacheService which provided by CacheModule . A quick example of how to set up ThrottlerModule with CacheThrottlerStorageService : from ellar.common import Module from ellar_throttler import ThrottlerModule , CacheThrottlerStorageService from ellar.cache import CacheModule from ellar.cache.backends.local_cache import LocalMemCacheBackend @Module ( modules = [ ThrottlerModule . setup ( ttl = 60 , limit = 10 , storage = CacheThrottlerStorageService ), CacheModule . setup ( default = LocalMemCacheBackend ( key_prefix = 'local' )) ]) class ApplicationModule : pass","title":"CacheThrottlerStorageService"},{"location":"security/throttling/#proxies","text":"If you are working with multiple proxies, you can override the get_tracker() method to pull the value from the header or install ProxyHeadersMiddleware # throttler_behind_proxy.guard.py from ellar_throttler import ThrottlerGuard from ellar.di import injectable from ellar.core.connection import HTTPConnection @injectable () class ThrottlerBehindProxyGuard ( ThrottlerGuard ): def get_tracker ( self , connection : HTTPConnection ) -> str : return connection . client . host # individualize IP extraction to meet your own needs # project_name/controller.py from .throttler_behind_proxy import ThrottlerBehindProxyGuard @Controller ( '' ) @UseGuards ( ThrottlerBehindProxyGuard ) class AppController : pass","title":"Proxies"},{"location":"security/throttling/#working-with-websockets","text":"To work with Websockets you can extend the ThrottlerGuard and override the handle_request method with the code below: from ellar_throttler import ThrottlerGuard from ellar.di import injectable from ellar.common import IExecutionContext from ellar_throttler import ThrottledException @injectable () class WsThrottleGuard ( ThrottlerGuard ): async def handle_request ( self , context : IExecutionContext , limit : int , ttl : int ) -> bool : websocket_client = context . switch_to_websocket () . get_client () host = websocket_client . client . host key = self . generate_key ( context , host ) result = await self . storage_service . increment ( key , ttl ) # Throw an error when the user reached their limit. if result . total_hits > limit : raise ThrottledException ( wait = result . time_to_expire ) return True","title":"Working with WebSockets"},{"location":"techniques/background-task/","text":"Background Tasks \u00b6 Background tasks are tasks attached to a response and processed after a response has been sent to the client. An example of this kind of task could be email notifications sent after performing an action. Adding BackgroundTask \u00b6 In Ellar, you can access the response object and set a background parameter. from starlette.background import BackgroundTask from ellar.common import ModuleRouter , get , Res router = ModuleRouter ( '/background-test' ) async def send_welcome_email ( email ): print ( f 'Send Welcome Email Task Called with { email } ' ) @router . post ( '/signup' ) def sign_up ( username : str , password : str , email : str , res = Res ()): res . background = BackgroundTask ( send_welcome_email , email = email ) return { 'status' : 'Signup successful' } In above construct, we created BackgroundTask around send_welcome_email function and passed to it some *args/**kwargs required to invoke the wrapped function. After the response has been sent to the client, the background function[ send_welcome_email ] will be called and there will be a print on the server log. Using BackgroundTasks \u00b6 BackgroundTasks is another class from Starlette useful for adding multiple background tasks to a response. Unlike the previous construct, BackgroundTasks can be injected into your route function by type annotation. For example: from starlette.background import BackgroundTasks from ellar.common import ModuleRouter router = ModuleRouter ( '/background-test' ) def another_background_task ( parameter ): print ( f 'Another Background task called with \" { parameter } \"' ) async def send_welcome_email ( email ): print ( f 'Send Welcome Email Task Called with \" { email } \"' ) @router . post ( '/signup' ) def sign_up ( username : str , password : str , email : str , tasks : BackgroundTasks ): tasks . add_task ( send_welcome_email , email = email ) tasks . add_task ( another_background_task , 'another_background_task parameter' ) return { 'status' : 'Signup successful' } During request response cycle, BackgroundTasks will be resolved made available to the route handler function. Hint The tasks are executed in order. In case one of the tasks raises an exception, the following tasks will not get the opportunity to be executed.","title":"Background Tasks"},{"location":"techniques/background-task/#background-tasks","text":"Background tasks are tasks attached to a response and processed after a response has been sent to the client. An example of this kind of task could be email notifications sent after performing an action.","title":"Background Tasks"},{"location":"techniques/background-task/#adding-backgroundtask","text":"In Ellar, you can access the response object and set a background parameter. from starlette.background import BackgroundTask from ellar.common import ModuleRouter , get , Res router = ModuleRouter ( '/background-test' ) async def send_welcome_email ( email ): print ( f 'Send Welcome Email Task Called with { email } ' ) @router . post ( '/signup' ) def sign_up ( username : str , password : str , email : str , res = Res ()): res . background = BackgroundTask ( send_welcome_email , email = email ) return { 'status' : 'Signup successful' } In above construct, we created BackgroundTask around send_welcome_email function and passed to it some *args/**kwargs required to invoke the wrapped function. After the response has been sent to the client, the background function[ send_welcome_email ] will be called and there will be a print on the server log.","title":"Adding BackgroundTask"},{"location":"techniques/background-task/#using-backgroundtasks","text":"BackgroundTasks is another class from Starlette useful for adding multiple background tasks to a response. Unlike the previous construct, BackgroundTasks can be injected into your route function by type annotation. For example: from starlette.background import BackgroundTasks from ellar.common import ModuleRouter router = ModuleRouter ( '/background-test' ) def another_background_task ( parameter ): print ( f 'Another Background task called with \" { parameter } \"' ) async def send_welcome_email ( email ): print ( f 'Send Welcome Email Task Called with \" { email } \"' ) @router . post ( '/signup' ) def sign_up ( username : str , password : str , email : str , tasks : BackgroundTasks ): tasks . add_task ( send_welcome_email , email = email ) tasks . add_task ( another_background_task , 'another_background_task parameter' ) return { 'status' : 'Signup successful' } During request response cycle, BackgroundTasks will be resolved made available to the route handler function. Hint The tasks are executed in order. In case one of the tasks raises an exception, the following tasks will not get the opportunity to be executed.","title":"Using BackgroundTasks"},{"location":"techniques/caching/","text":"Caching \u00b6 Caching refers to the process of storing frequently accessed data in a temporary storage area called a cache , in order to speed up access to that data in the future. In computing, caching is used to optimize the performance of applications and systems by reducing the time it takes to retrieve data from slower or more distant storage. By caching data in a faster, more local storage location, the system can quickly retrieve the data without needing to go all the way to the original source of the data. In Ellar, we provided several cache backends interface that interacts with different cache types to assist in cache endpoint responses or other relevant data. Setting up the cache \u00b6 It's very simple to set up cache in Ellar but the crucial part is picking the cache type that is suitable for your application because some cache type behave differently and perform better and faster than others. To set up cache, we need to use CacheModule . CacheModule provides two methods, CacheModule.register_setup and CacheModule.setup , for setting up cache in ellar applications. CacheModule Register Setup CacheModule Setup This setup method requires you to defined CACHES variable containing key value pairs of cache backends in config.py file. for example: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.local_cache import LocalMemCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : LocalMemCacheBackend ( ttl = 300 , key_prefix = 'local' , version = 1 ) } After that you register CacheModule to application modules # project_name/root_module.py from ellar.cache import CacheModule from ellar.common import Module @Module ( modules = [ CacheModule . register_setup ()]) class ApplicationModule : pass The register_setup will read CACHES from application config and setup the CacheService appropriately. The setup method requires direct definition of cache backend on the CacheModule setup function. for example: # project_name/root_module.py from ellar.cache import CacheModule from ellar.cache.backends.local_cache import LocalMemCacheBackend from ellar.common import Module @Module ( modules = [ CacheModule . setup ( default = LocalMemCacheBackend ( ttl = 300 , key_prefix = 'default' , version = 1 ), local = LocalMemCacheBackend ( key_prefix = 'local' ), others = LocalMemCacheBackend ( key_prefix = 'others' ), ) ]) class ApplicationModule : pass In CacheModule. setup , the default parameter must be provided and other cache backends will be defined as keyword-arguments just like local and others incase you want to set up more than one cache backend. Memcached \u00b6 Memcached is an entirely memory-based cache server, originally developed to handle high loads at LiveJournal.com and subsequently open-sourced by Danga Interactive. Memcached runs as a daemon and is allotted a specified amount of RAM. All it does is provide a fast interface for adding, retrieving and deleting data in the cache. All data is stored directly in memory. After installing Memcached itself, you\u2019ll need to install a Memcached binding. There are several Python Memcached bindings available; Ellar supports are pylibmc and pymemcache For an example, lets assume you have a Memcached is running on localhost (127.0.0.1) port 11211, using the pymemcache or pylibmc binding: pymemcache pylibmc # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '127.0.0.1:11211' ]) } # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pylib_cache import PyLibMCCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyLibMCCacheBackend ( servers = [ '127.0.0.1:11211' ]) } If Memcached is available through a local Unix socket file /tmp/memcached.sock using the pymemcache or pylibmc binding: pymemcache pylibmc # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '/tmp/memcached.sock' ]) } # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pylib_cache import PyLibMCCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyLibMCCacheBackend ( servers = [ '/tmp/memcached.sock' ]) } if your Memcached is its ability to share a cache over multiple servers, then you can config that too Lets assume the cache is shared over Memcached instances running on IP address 172.19.26.240 and 172.19.26.242, both on port 11211 or different ports pymemcache pylibmc # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '172.19.26.240:11211' , '172.19.26.242:11212' , '172.19.26.244:11213' , ]) } # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pylib_cache import PyLibMCCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyLibMCCacheBackend ( servers = [ '172.19.26.240:11211' , '172.19.26.242:11212' , '172.19.26.244:11213' , ]) } For pymemcache , we provided some default configuration during initialization shown below: import pymemcache _options = { 'allow_unicode_keys' : True , 'default_noreply' : False , 'serde' : pymemcache . serde . pickle_serde , } These can be changed by setting the desired value in options parameter during initialization. For example: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '172.19.26.240:11211' , '172.19.26.242:11212' , '172.19.26.244:11213' , ], options = { 'default_noreply' : True }) } Redis \u00b6 Redis is a high-performance, in-memory database that is commonly used for caching data. To get started with Redis, you will need to have a Redis server running on either your local machine or a remote server. Once you have set up the Redis server, you will need to install the Redis Python client library to be able to communicate with Redis from your Python code. To use redis in Ellar, you need to import RedisCacheBackend from ellar.cache.backend.redis . Let's assume after setting up your redis server and it's running on localhost (127.0.0.1) port 6379: Redis Redis - with username and password Redis - multiple server # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://127.0.0.1:6379' ]) } Often Redis servers are protected with authentication. In order to supply a username and password as follows: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://username:password@127.0.0.1:6379' ]) } If you have multiple Redis servers set up in the replication mode, you can specify the servers either as a semicolon or comma delimited string, or as a list. While using multiple servers, write operations are performed on the first server (leader). Read operations are performed on the other servers (replicas) chosen at random: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://127.0.0.1:6379' , # leader 'redis://127.0.0.1:6378' , # read-replica 1 'redis://127.0.0.1:6377' , # read-replica 2 ]) } Local-memory caching \u00b6 The local memory cache is the default caching mechanism used by Ellar, and it is automatically used if you do not specify a different caching backend in your config.py file. This cache stores cached data in memory, which provides fast access to cached data, and is ideal if you don't have the resources or capabilities to set up a separate caching server like Memcached. Its also thread-safe. Local Memory Cache # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.local_cache import LocalMemCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : LocalMemCacheBackend () } Custom Cache Backend \u00b6 You can create you own version of the cache backend. All you need is to inherit for ellar. for example: # project_name/cache_backend.py from ellar.cache.model import BaseCacheBackend class CustomCacheBackend ( BaseCacheBackend ): pass Then, in config.py # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from .cache_backend import CustomCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : CustomCacheBackend () } Cache Arguments \u00b6 You can customize the behavior of each caching backend in Django by passing additional arguments when you configure the cache. The valid arguments that can be passed to each backend are as follows: TIMEOUT : The default timeout, in seconds, to use for the cache. This argument defaults to 300 seconds (5 minutes). You can set TIMEOUT to None so that, by default, cache keys never expire. A value of 0 causes keys to immediately expire OPTIONS : Any options that should be passed to the cache backend. The list of valid options will vary with each backend. KEY_PREFIX : A string that will be automatically prepended to all cache keys. VERSION : The default version number for cache keys. # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '127.0.0.1:11211' ], options = { 'default_noreply' : True }, ttl = 300 , version = 1 , key_prefix = 'project_name' ) } Setting up More than One Cache Backend \u00b6 To set up multiple cache backends in Django, you can add additional entries to the CACHES variable in your config.py file. The default cache backend is typically defined first, followed by any additional cache backends you want to configure. Here's an example CACHES setting that defines two cache backends: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend from ellar.cache.backends.local_cache import LocalMemCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://127.0.0.1:6379' ], key_prefix = 'project_name' ), 'secondary' : LocalMemCacheBackend ( ttl = 300 , key_prefix = 'project_name' , version = 1 ) } CacheService (ICacheService) \u00b6 Ellar does not provide cache backends directly, but instead offers a caching service that manages all the configured cache backends in your application. The CacheService class serves as a wrapper for these cache backends and provides a uniform interface for interacting with them. The CacheService class can be injected into your application's code as a dependency, allowing you to use it throughout your application without the need for direct instantiation. This approach promotes a more modular and extensible design, as well as better testability of your code. The CacheService class provides methods like: class CacheService(ICacheService) : get (key: str, version: str = None, backend: str = None) : gets key value from a specified cache backend. get_async (key: str, version: str = None, backend: str = None) : asynchronous version of get action set (key: str, value: t.Any, ttl: t.Union[float, int] = None, version: str = None,backend: str = None) : sets value to a key to a specified cache backend. set_async (key: str, value: t.Any, ttl: t.Union[float, int] = None, version: str = None,backend: str = None) : asynchronous version of set action delete (key: str, version: str = None, backend: str = None) : deletes a key from a specified cache backend. delete_async (key: str, version: str = None, backend: str = None) : asynchronous version of delete action has_key (key: str, version: str = None, backend: str = None) : checks if a key exist in a specified backend has_key_async (key: str, version: str = None, backend: str = None) : asynchronous version of has_key action touch (key: str, ttl: t.Union[float, int] = None, version: str = None, backend: str = None) : sets a new expiration for a key touch_async (key: str, ttl: t.Union[float, int] = None, version: str = None, backend: str = None) : asynchronous version of touch action incr (key: str, delta: int = 1, version: str = None, backend: str = None) : increments a value for a key by delta incr_async (key: str, delta: int = 1, version: str = None, backend: str = None) : asynchronous version of incr action decr (key: str, delta: int = 1, version: str = None, backend: str = None) : decrement a value for a key by delta decr_async (key: str, delta: int = 1, version: str = None, backend: str = None) : asynchronous version of decr action Note If backend=None , default backend configuration is used. These methods are available for each of the configured cache backends and can be used interchangeably with any backend. Injecting CacheService \u00b6 CacheService is a core service registered in EllarInjector and can be injected as every other service. For example, lets make CacheService available in our route function. Synchronous Route Function Asynchronous Route Function from ellar.common import get , Provide from ellar.cache import ICacheService ... @get ( '/cache-test' ) def my_route_function ( self , cache_service : ICacheService = Provide ()): cached_value = cache_service . get ( \"my-key\" ) if cached_value : return cached_value processed_value = 'some-value' cache_service . set ( 'my-key' , processed_value , timeout = 300 ) # for 5mins return processed_value from ellar.common import get , Provide from ellar.cache import ICacheService ... @get ( '/cache-test' ) async def my_route_function ( self , cache_service : ICacheService = Provide ()): cached_value = await cache_service . get_async ( \"my-key\" ) if cached_value : return cached_value processed_value = 'some-value' await cache_service . set_async ( 'my-key' , processed_value , timeout = 300 ) # for 5mins return processed_value Using Cache Decorator \u00b6 Ellar provides a cache decorator that can be used to cache the responses of route functions. The cache decorator can be applied to a route function to automatically cache its response data for a specified amount of time. The cache decorator takes the following arguments: ttl (time to live): the amount of time (in seconds) for which the response data should be cached. key_prefix (optional): a string that is used to prefix the cache key, allowing for easy differentiation between different cache items. version (optional): a string that is used to version the cache key, allowing for cache invalidation when the data schema changes. backend (optional): the name of the cache backend to use for storing the cached data. By default, the default cache backend is used. make_key_callback (optional): a callback function that can be used to generate a custom cache key. This function takes an IExecutionContext instance (which contains information about the request context) and key prefix, and should return the custom cache key to use. Info Cache Decorator can also be applied to any controller class. When this is done, all the routes response of that controller will be cached We can rewrite the above example using cache decorator: Synchronous Route Function Asynchronous Route Function from ellar.common import get from ellar.cache import Cache ... @get ( '/cache-test' ) @Cache ( ttl = 300 , version = 'v1' , key_prefix = 'project_name' ) def my_route_function ( self ): processed_value = 'some-value' return processed_value from ellar.common import get from ellar.cache import Cache ... @get ( '/cache-test' ) @Cache ( ttl = 300 , version = 'v1' , key_prefix = 'project_name' ) async def my_route_function ( self ): processed_value = 'some-value' return processed_value Adding Custom key gen function for cache Decorator \u00b6 By default, the cache decorator combines the route function's URL and the specified key_prefix value to generate the cache key used to store the response data. However, you can customize this behavior by providing a make_key_callback function to the cache decorator. The make_key_callback function takes an ExecutionContext instance (which contains information about the request context) and the key_prefix value as input, and should return the custom cache key to use. Here's an example of how to use a custom make_key_callback function with the cache decorator: Synchronous Route Function Asynchronous Route Function from ellar.common import get from ellar.cache import Cache from ellar.core import ExecutionContext from ellar.common.helper import get_name def make_key_function ( ctx : ExecutionContext , key_prefix : str ) -> str : function_name = get_name ( ctx . get_handler ()) return \" %s : %s : %s \" % ( function_name , key_prefix , ctx . switch_to_http_connection () . get_client () . url ) ... @get ( \"/my_endpoint\" ) @Cache ( ttl = 60 , make_key_callback = make_key_function ) def my_endpoint ( self ): # Code to generate response data here processed_value = 'some-value' return processed_value ... from ellar.common import get from ellar.cache import Cache from ellar.core import ExecutionContext from ellar.common.helper import get_name def make_key_function ( ctx : ExecutionContext , key_prefix : str ) -> str : function_name = get_name ( ctx . get_handler ()) return \" %s : %s : %s \" % ( function_name , key_prefix , ctx . switch_to_http_connection () . get_client () . url ) ... @get ( \"/my_endpoint\" ) @Cache ( ttl = 60 , make_key_callback = make_key_function ) async def my_endpoint ( self ): # Code to generate response data here processed_value = 'some-value' return processed_value ... In this example, the cache decorator is applied to the my_endpoint route function, with a custom make_key_callback function specified. The make_key_callback function uses the get_name helper function to extract the name of the route function, and combines it with the key_prefix value and the request URL to generate the cache key.","title":"Caching"},{"location":"techniques/caching/#caching","text":"Caching refers to the process of storing frequently accessed data in a temporary storage area called a cache , in order to speed up access to that data in the future. In computing, caching is used to optimize the performance of applications and systems by reducing the time it takes to retrieve data from slower or more distant storage. By caching data in a faster, more local storage location, the system can quickly retrieve the data without needing to go all the way to the original source of the data. In Ellar, we provided several cache backends interface that interacts with different cache types to assist in cache endpoint responses or other relevant data.","title":"Caching"},{"location":"techniques/caching/#setting-up-the-cache","text":"It's very simple to set up cache in Ellar but the crucial part is picking the cache type that is suitable for your application because some cache type behave differently and perform better and faster than others. To set up cache, we need to use CacheModule . CacheModule provides two methods, CacheModule.register_setup and CacheModule.setup , for setting up cache in ellar applications. CacheModule Register Setup CacheModule Setup This setup method requires you to defined CACHES variable containing key value pairs of cache backends in config.py file. for example: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.local_cache import LocalMemCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : LocalMemCacheBackend ( ttl = 300 , key_prefix = 'local' , version = 1 ) } After that you register CacheModule to application modules # project_name/root_module.py from ellar.cache import CacheModule from ellar.common import Module @Module ( modules = [ CacheModule . register_setup ()]) class ApplicationModule : pass The register_setup will read CACHES from application config and setup the CacheService appropriately. The setup method requires direct definition of cache backend on the CacheModule setup function. for example: # project_name/root_module.py from ellar.cache import CacheModule from ellar.cache.backends.local_cache import LocalMemCacheBackend from ellar.common import Module @Module ( modules = [ CacheModule . setup ( default = LocalMemCacheBackend ( ttl = 300 , key_prefix = 'default' , version = 1 ), local = LocalMemCacheBackend ( key_prefix = 'local' ), others = LocalMemCacheBackend ( key_prefix = 'others' ), ) ]) class ApplicationModule : pass In CacheModule. setup , the default parameter must be provided and other cache backends will be defined as keyword-arguments just like local and others incase you want to set up more than one cache backend.","title":"Setting up the cache"},{"location":"techniques/caching/#memcached","text":"Memcached is an entirely memory-based cache server, originally developed to handle high loads at LiveJournal.com and subsequently open-sourced by Danga Interactive. Memcached runs as a daemon and is allotted a specified amount of RAM. All it does is provide a fast interface for adding, retrieving and deleting data in the cache. All data is stored directly in memory. After installing Memcached itself, you\u2019ll need to install a Memcached binding. There are several Python Memcached bindings available; Ellar supports are pylibmc and pymemcache For an example, lets assume you have a Memcached is running on localhost (127.0.0.1) port 11211, using the pymemcache or pylibmc binding: pymemcache pylibmc # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '127.0.0.1:11211' ]) } # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pylib_cache import PyLibMCCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyLibMCCacheBackend ( servers = [ '127.0.0.1:11211' ]) } If Memcached is available through a local Unix socket file /tmp/memcached.sock using the pymemcache or pylibmc binding: pymemcache pylibmc # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '/tmp/memcached.sock' ]) } # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pylib_cache import PyLibMCCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyLibMCCacheBackend ( servers = [ '/tmp/memcached.sock' ]) } if your Memcached is its ability to share a cache over multiple servers, then you can config that too Lets assume the cache is shared over Memcached instances running on IP address 172.19.26.240 and 172.19.26.242, both on port 11211 or different ports pymemcache pylibmc # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '172.19.26.240:11211' , '172.19.26.242:11212' , '172.19.26.244:11213' , ]) } # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pylib_cache import PyLibMCCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyLibMCCacheBackend ( servers = [ '172.19.26.240:11211' , '172.19.26.242:11212' , '172.19.26.244:11213' , ]) } For pymemcache , we provided some default configuration during initialization shown below: import pymemcache _options = { 'allow_unicode_keys' : True , 'default_noreply' : False , 'serde' : pymemcache . serde . pickle_serde , } These can be changed by setting the desired value in options parameter during initialization. For example: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '172.19.26.240:11211' , '172.19.26.242:11212' , '172.19.26.244:11213' , ], options = { 'default_noreply' : True }) }","title":"Memcached"},{"location":"techniques/caching/#redis","text":"Redis is a high-performance, in-memory database that is commonly used for caching data. To get started with Redis, you will need to have a Redis server running on either your local machine or a remote server. Once you have set up the Redis server, you will need to install the Redis Python client library to be able to communicate with Redis from your Python code. To use redis in Ellar, you need to import RedisCacheBackend from ellar.cache.backend.redis . Let's assume after setting up your redis server and it's running on localhost (127.0.0.1) port 6379: Redis Redis - with username and password Redis - multiple server # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://127.0.0.1:6379' ]) } Often Redis servers are protected with authentication. In order to supply a username and password as follows: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://username:password@127.0.0.1:6379' ]) } If you have multiple Redis servers set up in the replication mode, you can specify the servers either as a semicolon or comma delimited string, or as a list. While using multiple servers, write operations are performed on the first server (leader). Read operations are performed on the other servers (replicas) chosen at random: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://127.0.0.1:6379' , # leader 'redis://127.0.0.1:6378' , # read-replica 1 'redis://127.0.0.1:6377' , # read-replica 2 ]) }","title":"Redis"},{"location":"techniques/caching/#local-memory-caching","text":"The local memory cache is the default caching mechanism used by Ellar, and it is automatically used if you do not specify a different caching backend in your config.py file. This cache stores cached data in memory, which provides fast access to cached data, and is ideal if you don't have the resources or capabilities to set up a separate caching server like Memcached. Its also thread-safe. Local Memory Cache # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.local_cache import LocalMemCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : LocalMemCacheBackend () }","title":"Local-memory caching"},{"location":"techniques/caching/#custom-cache-backend","text":"You can create you own version of the cache backend. All you need is to inherit for ellar. for example: # project_name/cache_backend.py from ellar.cache.model import BaseCacheBackend class CustomCacheBackend ( BaseCacheBackend ): pass Then, in config.py # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from .cache_backend import CustomCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : CustomCacheBackend () }","title":"Custom Cache Backend"},{"location":"techniques/caching/#cache-arguments","text":"You can customize the behavior of each caching backend in Django by passing additional arguments when you configure the cache. The valid arguments that can be passed to each backend are as follows: TIMEOUT : The default timeout, in seconds, to use for the cache. This argument defaults to 300 seconds (5 minutes). You can set TIMEOUT to None so that, by default, cache keys never expire. A value of 0 causes keys to immediately expire OPTIONS : Any options that should be passed to the cache backend. The list of valid options will vary with each backend. KEY_PREFIX : A string that will be automatically prepended to all cache keys. VERSION : The default version number for cache keys. # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : PyMemcacheCacheBackend ( servers = [ '127.0.0.1:11211' ], options = { 'default_noreply' : True }, ttl = 300 , version = 1 , key_prefix = 'project_name' ) }","title":"Cache Arguments"},{"location":"techniques/caching/#setting-up-more-than-one-cache-backend","text":"To set up multiple cache backends in Django, you can add additional entries to the CACHES variable in your config.py file. The default cache backend is typically defined first, followed by any additional cache backends you want to configure. Here's an example CACHES setting that defines two cache backends: # project_name/config.py from ellar.core import ConfigDefaultTypesMixin from ellar.cache.backends.redis import RedisCacheBackend from ellar.cache.backends.local_cache import LocalMemCacheBackend class DevelopmentConfig ( ConfigDefaultTypesMixin ): CACHES = { 'default' : RedisCacheBackend ( servers = [ 'redis://127.0.0.1:6379' ], key_prefix = 'project_name' ), 'secondary' : LocalMemCacheBackend ( ttl = 300 , key_prefix = 'project_name' , version = 1 ) }","title":"Setting up More than One Cache Backend"},{"location":"techniques/caching/#cacheservice-icacheservice","text":"Ellar does not provide cache backends directly, but instead offers a caching service that manages all the configured cache backends in your application. The CacheService class serves as a wrapper for these cache backends and provides a uniform interface for interacting with them. The CacheService class can be injected into your application's code as a dependency, allowing you to use it throughout your application without the need for direct instantiation. This approach promotes a more modular and extensible design, as well as better testability of your code. The CacheService class provides methods like: class CacheService(ICacheService) : get (key: str, version: str = None, backend: str = None) : gets key value from a specified cache backend. get_async (key: str, version: str = None, backend: str = None) : asynchronous version of get action set (key: str, value: t.Any, ttl: t.Union[float, int] = None, version: str = None,backend: str = None) : sets value to a key to a specified cache backend. set_async (key: str, value: t.Any, ttl: t.Union[float, int] = None, version: str = None,backend: str = None) : asynchronous version of set action delete (key: str, version: str = None, backend: str = None) : deletes a key from a specified cache backend. delete_async (key: str, version: str = None, backend: str = None) : asynchronous version of delete action has_key (key: str, version: str = None, backend: str = None) : checks if a key exist in a specified backend has_key_async (key: str, version: str = None, backend: str = None) : asynchronous version of has_key action touch (key: str, ttl: t.Union[float, int] = None, version: str = None, backend: str = None) : sets a new expiration for a key touch_async (key: str, ttl: t.Union[float, int] = None, version: str = None, backend: str = None) : asynchronous version of touch action incr (key: str, delta: int = 1, version: str = None, backend: str = None) : increments a value for a key by delta incr_async (key: str, delta: int = 1, version: str = None, backend: str = None) : asynchronous version of incr action decr (key: str, delta: int = 1, version: str = None, backend: str = None) : decrement a value for a key by delta decr_async (key: str, delta: int = 1, version: str = None, backend: str = None) : asynchronous version of decr action Note If backend=None , default backend configuration is used. These methods are available for each of the configured cache backends and can be used interchangeably with any backend.","title":"CacheService (ICacheService)"},{"location":"techniques/caching/#injecting-cacheservice","text":"CacheService is a core service registered in EllarInjector and can be injected as every other service. For example, lets make CacheService available in our route function. Synchronous Route Function Asynchronous Route Function from ellar.common import get , Provide from ellar.cache import ICacheService ... @get ( '/cache-test' ) def my_route_function ( self , cache_service : ICacheService = Provide ()): cached_value = cache_service . get ( \"my-key\" ) if cached_value : return cached_value processed_value = 'some-value' cache_service . set ( 'my-key' , processed_value , timeout = 300 ) # for 5mins return processed_value from ellar.common import get , Provide from ellar.cache import ICacheService ... @get ( '/cache-test' ) async def my_route_function ( self , cache_service : ICacheService = Provide ()): cached_value = await cache_service . get_async ( \"my-key\" ) if cached_value : return cached_value processed_value = 'some-value' await cache_service . set_async ( 'my-key' , processed_value , timeout = 300 ) # for 5mins return processed_value","title":"Injecting CacheService"},{"location":"techniques/caching/#using-cache-decorator","text":"Ellar provides a cache decorator that can be used to cache the responses of route functions. The cache decorator can be applied to a route function to automatically cache its response data for a specified amount of time. The cache decorator takes the following arguments: ttl (time to live): the amount of time (in seconds) for which the response data should be cached. key_prefix (optional): a string that is used to prefix the cache key, allowing for easy differentiation between different cache items. version (optional): a string that is used to version the cache key, allowing for cache invalidation when the data schema changes. backend (optional): the name of the cache backend to use for storing the cached data. By default, the default cache backend is used. make_key_callback (optional): a callback function that can be used to generate a custom cache key. This function takes an IExecutionContext instance (which contains information about the request context) and key prefix, and should return the custom cache key to use. Info Cache Decorator can also be applied to any controller class. When this is done, all the routes response of that controller will be cached We can rewrite the above example using cache decorator: Synchronous Route Function Asynchronous Route Function from ellar.common import get from ellar.cache import Cache ... @get ( '/cache-test' ) @Cache ( ttl = 300 , version = 'v1' , key_prefix = 'project_name' ) def my_route_function ( self ): processed_value = 'some-value' return processed_value from ellar.common import get from ellar.cache import Cache ... @get ( '/cache-test' ) @Cache ( ttl = 300 , version = 'v1' , key_prefix = 'project_name' ) async def my_route_function ( self ): processed_value = 'some-value' return processed_value","title":"Using Cache Decorator"},{"location":"techniques/caching/#adding-custom-key-gen-function-for-cache-decorator","text":"By default, the cache decorator combines the route function's URL and the specified key_prefix value to generate the cache key used to store the response data. However, you can customize this behavior by providing a make_key_callback function to the cache decorator. The make_key_callback function takes an ExecutionContext instance (which contains information about the request context) and the key_prefix value as input, and should return the custom cache key to use. Here's an example of how to use a custom make_key_callback function with the cache decorator: Synchronous Route Function Asynchronous Route Function from ellar.common import get from ellar.cache import Cache from ellar.core import ExecutionContext from ellar.common.helper import get_name def make_key_function ( ctx : ExecutionContext , key_prefix : str ) -> str : function_name = get_name ( ctx . get_handler ()) return \" %s : %s : %s \" % ( function_name , key_prefix , ctx . switch_to_http_connection () . get_client () . url ) ... @get ( \"/my_endpoint\" ) @Cache ( ttl = 60 , make_key_callback = make_key_function ) def my_endpoint ( self ): # Code to generate response data here processed_value = 'some-value' return processed_value ... from ellar.common import get from ellar.cache import Cache from ellar.core import ExecutionContext from ellar.common.helper import get_name def make_key_function ( ctx : ExecutionContext , key_prefix : str ) -> str : function_name = get_name ( ctx . get_handler ()) return \" %s : %s : %s \" % ( function_name , key_prefix , ctx . switch_to_http_connection () . get_client () . url ) ... @get ( \"/my_endpoint\" ) @Cache ( ttl = 60 , make_key_callback = make_key_function ) async def my_endpoint ( self ): # Code to generate response data here processed_value = 'some-value' return processed_value ... In this example, the cache decorator is applied to the my_endpoint route function, with a custom make_key_callback function specified. The make_key_callback function uses the get_name helper function to extract the name of the route function, and combines it with the key_prefix value and the request URL to generate the cache key.","title":"Adding Custom key gen function for cache Decorator"},{"location":"techniques/configurations/","text":"Application Configurations \u00b6 The config.py file contains all the configuration necessary in bootstrapping ellar application. Lets in this section go through the different configuration available. Configuration Variables \u00b6 SECRET_KEY \u00b6 Default: ' ' (Empty string) A secret key is a unique and unpredictable value. ellar new project command automatically adds a randomly-generated SECRET_KEY to each new project. DEBUG \u00b6 Default: False A boolean that turns on/off debug mode. Never deploy a site into production with DEBUG turned on . One of the main features of debug mode is the display of detailed error pages. If your app raises an exception when DEBUG is True , Ellar will display a detailed traceback. If DEBUG is False , you also need to properly set the ALLOWED_HOSTS setting. Failing to do so will result in all requests being returned as \u201cBad Request (400)\u201d . INJECTOR_AUTO_BIND \u00b6 Default: False A boolean that turns on/off injector auto_bind property. When turned on, injector can automatically bind to missing types as singleton at the point of resolving object dependencies. And when turned off, missing types will raise an UnsatisfiedRequirement exception. DEFAULT_JSON_CLASS \u00b6 Default: JSONResponse - ( starlette.common.JSONResponse ) DEFAULT_JSON_CLASS is used when sending JSON response to the client. There are other options for JSON available in Ellar: UJSONResponse ( ellar.common.UJSONResponse ): renders JSON response using ujson . ORJSONResponse ( ellar.common.ORJSONResponse ): renders JSON response using orjson . JINJA_TEMPLATES_OPTIONS \u00b6 Default: {} Default is an empty dictionary object. It defines options used when creating Jinja2 Environment for templating. Different keys available: block_start_string (str) \u2013 block_end_string (str) \u2013 variable_start_string (str) \u2013 variable_end_string (str) \u2013 comment_start_string (str) \u2013 comment_end_string (str) \u2013 line_statement_prefix (Optional[str]) \u2013 line_comment_prefix (Optional[str]) \u2013 trim_blocks (bool) \u2013 lstrip_blocks (bool) \u2013 newline_sequence (te.Literal['\\n', '\\r\\n', '\\r']) \u2013 keep_trailing_newline (bool) \u2013 extensions (Sequence[Union[str, Type[Extension]]]) \u2013 optimized (bool) \u2013 undefined (Type[jinja2.runtime.Undefined]) \u2013 finalize (Optional[Callable[[...], Any]]) \u2013 autoescape (Union[bool, Callable[[Optional[str]], bool]]) \u2013 loader (Optional[BaseLoader]) \u2013 cache_size (int) \u2013 auto_reload (bool) \u2013 bytecode_cache (Optional[BytecodeCache]) \u2013 enable_async (bool) Info Check Jinja2 environment option for more information. VERSIONING_SCHEME \u00b6 Default: DefaultAPIVersioning() VERSIONING_SCHEME defined the versioning scheme for the application. The DefaultAPIVersioning is placeHolder object for versioning scheme. Other Options includes: UrlPathAPIVersioning - for url versioning. eg https://example.com/v1 or https://example.com/v2 HostNameAPIVersioning - for host versioning. eg https://v1.example.com or https://v2.example.com HeaderAPIVersioning - for request header versioning. eg Accept: application/json; version=1.0 QueryParameterAPIVersioning - for request query versioning. eg /something/?version=0.1 REDIRECT_SLASHES \u00b6 Default: False A boolean that turns on/off router redirect_slashes property. When REDIRECT_SLASHES is turned on, the Application Router creates a redirect with a / to complete a URL path. This only happens when the URL was not found but may exist when / is appended to the URL. For example, a route to the user profile goes like this http://localhost:8000/user/profile/ . If a path like this is passed http://localhost:8000/user/profile , it will be redirected to http://localhost:8000/user/profile automatically. This approach may be complex depending on the application size because ApplicationRouter has to loop through its routes twice. When REDIRECT_SLASHES is turned off, URL paths have to be an exact match, or a 404 exception is raised. STATIC_FOLDER_PACKAGES \u00b6 Default: [] It is used to apply static files that exist in installed python package. For example: STATIC_FOLDER_PACKAGES = [( 'boostrap4' , 'statics' )] 'boostrap4' is the package, and 'statics' is the static folder. STATIC_DIRECTORIES \u00b6 Default: [] It is used to apply static files that project level For example: STATIC_DIRECTORIES = [ 'project_name/staticfiles' , 'project_name/path/to/static/files' ] MIDDLEWARE \u00b6 Default: [] MIDDLEWARE defines a list of user-defined ASGI Middleware to be applied to the application alongside default application middleware. EXCEPTION_HANDLERS \u00b6 Default: [] It defines a list of IExceptionHandler objects used in handling custom exceptions or any exception. STATIC_MOUNT_PATH \u00b6 Default: /static It configures the root path to get to static files. eg http://localhost:8000/static/stylesheet.css . And if for instance STATIC_MOUNT_PATH = '/my-static' , then the route becomes http://localhost:8000/my-static/stylesheet.css SERIALIZER_CUSTOM_ENCODER \u00b6 Default: ENCODERS_BY_TYPE ( pydantic.json.ENCODERS_BY_TYPE ) SERIALIZER_CUSTOM_ENCODER is a key-value pair of type and function. Default is a pydantic JSON encode type. It is used when serializing objects to JSON format. DEFAULT_NOT_FOUND_HANDLER \u00b6 Default: not_found ( not_found(scope: TScope, receive: TReceive, send: TSend) ) Default is an ASGI function. DEFAULT_NOT_FOUND_HANDLER is used by the application router as a callback function to a resource not found. from ellar.common.types import TScope , TReceive , TSend from starlette.exceptions import HTTPException as StarletteHTTPException from starlette.websockets import WebSocketClose from ellar.common import PlainTextResponse async def _not_found ( scope : TScope , receive : TReceive , send : TSend ) -> None : if scope [ \"type\" ] == \"websocket\" : websocket_close = WebSocketClose () await websocket_close ( scope , receive , send ) return # If we're running inside a starlette application then raise an # exception, so that the configurable exception handler can deal with # returning the response. For plain ASGI apps, just return the response. if \"app\" in scope : raise StarletteHTTPException ( status_code = 404 ) else : response = PlainTextResponse ( \"Not Found\" , status_code = 404 ) await response ( scope , receive , send ) DEFAULT_LIFESPAN_HANDLER \u00b6 Default: None DEFAULT_LIFESPAN_HANDLER is a function that returns AsyncContextManager used to manage startup and shutdown together instead of having a separate handler for startup and shutdown events. import contextlib from ellar.core import App , ConfigDefaultTypesMixin @contextlib . asynccontextmanager async def lifespan ( app : App ): async with some_async_resource (): yield class BaseConfig ( ConfigDefaultTypesMixin ): DEFAULT_LIFESPAN_HANDLER = lifespan Consider using anyio.create_task_group() for managing asynchronous tasks. CORS_ALLOW_ORIGINS \u00b6 Default: [] A list of origins that should be permitted to make cross-origin requests. e.g. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. CORS_ALLOW_METHODS: t.List[str] \u00b6 Default: [\"GET\"] A list of HTTP methods that should be allowed for cross-origin requests. You can use ['*'] to allow all standard methods. CORS_ALLOW_HEADERS : \u00b6 Default: [] A list of HTTP request headers that should be supported for cross-origin requests. You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. CORS_ALLOW_CREDENTIALS \u00b6 Default: False Indicate that cookies should be supported for cross-origin requests. CORS_ALLOW_ORIGIN_REGEX : \u00b6 Default: None A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . CORS_EXPOSE_HEADERS : \u00b6 Default: None Indicate any response headers that should be made accessible to the browser. CORS_MAX_AGE: \u00b6 Defaults: 600 Sets a maximum time in seconds for browsers to cache CORS responses. ALLOWED_HOSTS \u00b6 Default: [\"*\"] A list of domain names that should be allowed as hostnames in TrustedHostMiddleware . Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. REDIRECT_HOST \u00b6 Default: True Indicates whether to append www. when redirecting host in TrustedHostMiddleware Configuration with prefix \u00b6 Ellar configuration module also support loading of its configurations with appended prefix. for instance, we can have a file my_settings.py with some ellar's configurations set to it with some prefix API_ as shown below. # my_settings.py API_DEBUG = True API_SECRET_KEY = \"your-secret-key-changed\" API_INJECTOR_AUTO_BIND = True API_JINJA_TEMPLATES_OPTIONS = { \"auto_reload\" : True } OTHER_XYZ_CONFIGS_1 = 'whatever' OTHER_XYZ_CONFIGS_2 = 'whatever2' To apply these configurations without having to load everything, you have to provide the prefix to be used to load configurations that belongs to ellar. For example, from ellar.core.factory import AppFactory from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = dict ( config_module = 'project_name:my_settings' , config_prefix = 'api_' , )) In the above construct, we used a dict object to define the configuration module( 'project_name:my_settings' ) and prefix api_ . This will be applied to the configuration instance when the application is ready. Defining Configurations directly \u00b6 During application bootstrapping with AppFactory , you can define app configurations directly under config_module as a dict object as some below. from ellar.core.factory import AppFactory from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = dict ( SECRET_KEY = \"your-secret-key-changed\" , INJECTOR_AUTO_BIND = True , MIDDLEWARE = [], EXCEPTION_HANDLERS = [] ))","title":"Configuration"},{"location":"techniques/configurations/#application-configurations","text":"The config.py file contains all the configuration necessary in bootstrapping ellar application. Lets in this section go through the different configuration available.","title":"Application Configurations"},{"location":"techniques/configurations/#configuration-variables","text":"","title":"Configuration Variables"},{"location":"techniques/configurations/#secret_key","text":"Default: ' ' (Empty string) A secret key is a unique and unpredictable value. ellar new project command automatically adds a randomly-generated SECRET_KEY to each new project.","title":"SECRET_KEY"},{"location":"techniques/configurations/#debug","text":"Default: False A boolean that turns on/off debug mode. Never deploy a site into production with DEBUG turned on . One of the main features of debug mode is the display of detailed error pages. If your app raises an exception when DEBUG is True , Ellar will display a detailed traceback. If DEBUG is False , you also need to properly set the ALLOWED_HOSTS setting. Failing to do so will result in all requests being returned as \u201cBad Request (400)\u201d .","title":"DEBUG"},{"location":"techniques/configurations/#injector_auto_bind","text":"Default: False A boolean that turns on/off injector auto_bind property. When turned on, injector can automatically bind to missing types as singleton at the point of resolving object dependencies. And when turned off, missing types will raise an UnsatisfiedRequirement exception.","title":"INJECTOR_AUTO_BIND"},{"location":"techniques/configurations/#default_json_class","text":"Default: JSONResponse - ( starlette.common.JSONResponse ) DEFAULT_JSON_CLASS is used when sending JSON response to the client. There are other options for JSON available in Ellar: UJSONResponse ( ellar.common.UJSONResponse ): renders JSON response using ujson . ORJSONResponse ( ellar.common.ORJSONResponse ): renders JSON response using orjson .","title":"DEFAULT_JSON_CLASS"},{"location":"techniques/configurations/#jinja_templates_options","text":"Default: {} Default is an empty dictionary object. It defines options used when creating Jinja2 Environment for templating. Different keys available: block_start_string (str) \u2013 block_end_string (str) \u2013 variable_start_string (str) \u2013 variable_end_string (str) \u2013 comment_start_string (str) \u2013 comment_end_string (str) \u2013 line_statement_prefix (Optional[str]) \u2013 line_comment_prefix (Optional[str]) \u2013 trim_blocks (bool) \u2013 lstrip_blocks (bool) \u2013 newline_sequence (te.Literal['\\n', '\\r\\n', '\\r']) \u2013 keep_trailing_newline (bool) \u2013 extensions (Sequence[Union[str, Type[Extension]]]) \u2013 optimized (bool) \u2013 undefined (Type[jinja2.runtime.Undefined]) \u2013 finalize (Optional[Callable[[...], Any]]) \u2013 autoescape (Union[bool, Callable[[Optional[str]], bool]]) \u2013 loader (Optional[BaseLoader]) \u2013 cache_size (int) \u2013 auto_reload (bool) \u2013 bytecode_cache (Optional[BytecodeCache]) \u2013 enable_async (bool) Info Check Jinja2 environment option for more information.","title":"JINJA_TEMPLATES_OPTIONS"},{"location":"techniques/configurations/#versioning_scheme","text":"Default: DefaultAPIVersioning() VERSIONING_SCHEME defined the versioning scheme for the application. The DefaultAPIVersioning is placeHolder object for versioning scheme. Other Options includes: UrlPathAPIVersioning - for url versioning. eg https://example.com/v1 or https://example.com/v2 HostNameAPIVersioning - for host versioning. eg https://v1.example.com or https://v2.example.com HeaderAPIVersioning - for request header versioning. eg Accept: application/json; version=1.0 QueryParameterAPIVersioning - for request query versioning. eg /something/?version=0.1","title":"VERSIONING_SCHEME"},{"location":"techniques/configurations/#redirect_slashes","text":"Default: False A boolean that turns on/off router redirect_slashes property. When REDIRECT_SLASHES is turned on, the Application Router creates a redirect with a / to complete a URL path. This only happens when the URL was not found but may exist when / is appended to the URL. For example, a route to the user profile goes like this http://localhost:8000/user/profile/ . If a path like this is passed http://localhost:8000/user/profile , it will be redirected to http://localhost:8000/user/profile automatically. This approach may be complex depending on the application size because ApplicationRouter has to loop through its routes twice. When REDIRECT_SLASHES is turned off, URL paths have to be an exact match, or a 404 exception is raised.","title":"REDIRECT_SLASHES"},{"location":"techniques/configurations/#static_folder_packages","text":"Default: [] It is used to apply static files that exist in installed python package. For example: STATIC_FOLDER_PACKAGES = [( 'boostrap4' , 'statics' )] 'boostrap4' is the package, and 'statics' is the static folder.","title":"STATIC_FOLDER_PACKAGES"},{"location":"techniques/configurations/#static_directories","text":"Default: [] It is used to apply static files that project level For example: STATIC_DIRECTORIES = [ 'project_name/staticfiles' , 'project_name/path/to/static/files' ]","title":"STATIC_DIRECTORIES"},{"location":"techniques/configurations/#middleware","text":"Default: [] MIDDLEWARE defines a list of user-defined ASGI Middleware to be applied to the application alongside default application middleware.","title":"MIDDLEWARE"},{"location":"techniques/configurations/#exception_handlers","text":"Default: [] It defines a list of IExceptionHandler objects used in handling custom exceptions or any exception.","title":"EXCEPTION_HANDLERS"},{"location":"techniques/configurations/#static_mount_path","text":"Default: /static It configures the root path to get to static files. eg http://localhost:8000/static/stylesheet.css . And if for instance STATIC_MOUNT_PATH = '/my-static' , then the route becomes http://localhost:8000/my-static/stylesheet.css","title":"STATIC_MOUNT_PATH"},{"location":"techniques/configurations/#serializer_custom_encoder","text":"Default: ENCODERS_BY_TYPE ( pydantic.json.ENCODERS_BY_TYPE ) SERIALIZER_CUSTOM_ENCODER is a key-value pair of type and function. Default is a pydantic JSON encode type. It is used when serializing objects to JSON format.","title":"SERIALIZER_CUSTOM_ENCODER"},{"location":"techniques/configurations/#default_not_found_handler","text":"Default: not_found ( not_found(scope: TScope, receive: TReceive, send: TSend) ) Default is an ASGI function. DEFAULT_NOT_FOUND_HANDLER is used by the application router as a callback function to a resource not found. from ellar.common.types import TScope , TReceive , TSend from starlette.exceptions import HTTPException as StarletteHTTPException from starlette.websockets import WebSocketClose from ellar.common import PlainTextResponse async def _not_found ( scope : TScope , receive : TReceive , send : TSend ) -> None : if scope [ \"type\" ] == \"websocket\" : websocket_close = WebSocketClose () await websocket_close ( scope , receive , send ) return # If we're running inside a starlette application then raise an # exception, so that the configurable exception handler can deal with # returning the response. For plain ASGI apps, just return the response. if \"app\" in scope : raise StarletteHTTPException ( status_code = 404 ) else : response = PlainTextResponse ( \"Not Found\" , status_code = 404 ) await response ( scope , receive , send )","title":"DEFAULT_NOT_FOUND_HANDLER"},{"location":"techniques/configurations/#default_lifespan_handler","text":"Default: None DEFAULT_LIFESPAN_HANDLER is a function that returns AsyncContextManager used to manage startup and shutdown together instead of having a separate handler for startup and shutdown events. import contextlib from ellar.core import App , ConfigDefaultTypesMixin @contextlib . asynccontextmanager async def lifespan ( app : App ): async with some_async_resource (): yield class BaseConfig ( ConfigDefaultTypesMixin ): DEFAULT_LIFESPAN_HANDLER = lifespan Consider using anyio.create_task_group() for managing asynchronous tasks.","title":"DEFAULT_LIFESPAN_HANDLER"},{"location":"techniques/configurations/#cors_allow_origins","text":"Default: [] A list of origins that should be permitted to make cross-origin requests. e.g. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin.","title":"CORS_ALLOW_ORIGINS"},{"location":"techniques/configurations/#cors_allow_methods-tliststr","text":"Default: [\"GET\"] A list of HTTP methods that should be allowed for cross-origin requests. You can use ['*'] to allow all standard methods.","title":"CORS_ALLOW_METHODS: t.List[str]"},{"location":"techniques/configurations/#cors_allow_headers","text":"Default: [] A list of HTTP request headers that should be supported for cross-origin requests. You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests.","title":"CORS_ALLOW_HEADERS:"},{"location":"techniques/configurations/#cors_allow_credentials","text":"Default: False Indicate that cookies should be supported for cross-origin requests.","title":"CORS_ALLOW_CREDENTIALS"},{"location":"techniques/configurations/#cors_allow_origin_regex","text":"Default: None A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' .","title":"CORS_ALLOW_ORIGIN_REGEX:"},{"location":"techniques/configurations/#cors_expose_headers","text":"Default: None Indicate any response headers that should be made accessible to the browser.","title":"CORS_EXPOSE_HEADERS:"},{"location":"techniques/configurations/#cors_max_age","text":"Defaults: 600 Sets a maximum time in seconds for browsers to cache CORS responses.","title":"CORS_MAX_AGE:"},{"location":"techniques/configurations/#allowed_hosts","text":"Default: [\"*\"] A list of domain names that should be allowed as hostnames in TrustedHostMiddleware . Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware.","title":"ALLOWED_HOSTS"},{"location":"techniques/configurations/#redirect_host","text":"Default: True Indicates whether to append www. when redirecting host in TrustedHostMiddleware","title":"REDIRECT_HOST"},{"location":"techniques/configurations/#configuration-with-prefix","text":"Ellar configuration module also support loading of its configurations with appended prefix. for instance, we can have a file my_settings.py with some ellar's configurations set to it with some prefix API_ as shown below. # my_settings.py API_DEBUG = True API_SECRET_KEY = \"your-secret-key-changed\" API_INJECTOR_AUTO_BIND = True API_JINJA_TEMPLATES_OPTIONS = { \"auto_reload\" : True } OTHER_XYZ_CONFIGS_1 = 'whatever' OTHER_XYZ_CONFIGS_2 = 'whatever2' To apply these configurations without having to load everything, you have to provide the prefix to be used to load configurations that belongs to ellar. For example, from ellar.core.factory import AppFactory from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = dict ( config_module = 'project_name:my_settings' , config_prefix = 'api_' , )) In the above construct, we used a dict object to define the configuration module( 'project_name:my_settings' ) and prefix api_ . This will be applied to the configuration instance when the application is ready.","title":"Configuration with prefix"},{"location":"techniques/configurations/#defining-configurations-directly","text":"During application bootstrapping with AppFactory , you can define app configurations directly under config_module as a dict object as some below. from ellar.core.factory import AppFactory from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = dict ( SECRET_KEY = \"your-secret-key-changed\" , INJECTOR_AUTO_BIND = True , MIDDLEWARE = [], EXCEPTION_HANDLERS = [] ))","title":"Defining Configurations directly"},{"location":"techniques/mount/","text":"Mount \u00b6 In Starlette, Mount is used to mount sub-routes and ASGI apps or WSGI apps. The same is applicable in Ellar. Let's see how to mount sub-routes in ellar from starlette.routing import Mount from ellar.common.routing import RouteOperation from ellar.common import Req def users ( request = Req ()): return \"List of users\" def user ( username : str , request = Req ()): return f \"Users Profile of { username } \" mount = Mount ( path = '/users' , routes = [ RouteOperation ( path = '/' , endpoint = users , methods = [ 'GET' , 'POST' ], response = { 200 : str }), RouteOperation ( path = '/ {username} ' , endpoint = user , methods = [ 'GET' , 'POST' ], response = { 200 : str }) ] ) In the construct above, we have created a starlette-like example of Mount with a base path /users and with two endpoints, / to get list of users and /username to a users profile. Mount with Ellar \u00b6 Now, we have a mount instance for the previous code construct, to get it to work in ellar, we need to register it to a Module . For example, from ellar.common import Module from .path_to_mount import mount @Module ( routers = [ mount ]) class ApplicationModule : pass Applying Middleware to Mount \u00b6 Just like in every other ASGI app, middlewares can be added to Mount during its instantiation. For example, ... from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware mount = Mount ( path = '/users' , routes = [ RouteOperation ( path = '/' , endpoint = users , methods = [ 'GET' , 'POST' ], response = { 200 : str }), RouteOperation ( path = '/ {username} ' , endpoint = user , methods = [ 'GET' , 'POST' ], response = { 200 : str }) ], middleware = [ Middleware ( GZipMiddleware )] ) Checkout this documentation from starlette on some conditions to using middleware on Mount","title":"Mount"},{"location":"techniques/mount/#mount","text":"In Starlette, Mount is used to mount sub-routes and ASGI apps or WSGI apps. The same is applicable in Ellar. Let's see how to mount sub-routes in ellar from starlette.routing import Mount from ellar.common.routing import RouteOperation from ellar.common import Req def users ( request = Req ()): return \"List of users\" def user ( username : str , request = Req ()): return f \"Users Profile of { username } \" mount = Mount ( path = '/users' , routes = [ RouteOperation ( path = '/' , endpoint = users , methods = [ 'GET' , 'POST' ], response = { 200 : str }), RouteOperation ( path = '/ {username} ' , endpoint = user , methods = [ 'GET' , 'POST' ], response = { 200 : str }) ] ) In the construct above, we have created a starlette-like example of Mount with a base path /users and with two endpoints, / to get list of users and /username to a users profile.","title":"Mount"},{"location":"techniques/mount/#mount-with-ellar","text":"Now, we have a mount instance for the previous code construct, to get it to work in ellar, we need to register it to a Module . For example, from ellar.common import Module from .path_to_mount import mount @Module ( routers = [ mount ]) class ApplicationModule : pass","title":"Mount with Ellar"},{"location":"techniques/mount/#applying-middleware-to-mount","text":"Just like in every other ASGI app, middlewares can be added to Mount during its instantiation. For example, ... from starlette.middleware import Middleware from starlette.middleware.gzip import GZipMiddleware mount = Mount ( path = '/users' , routes = [ RouteOperation ( path = '/' , endpoint = users , methods = [ 'GET' , 'POST' ], response = { 200 : str }), RouteOperation ( path = '/ {username} ' , endpoint = user , methods = [ 'GET' , 'POST' ], response = { 200 : str }) ], middleware = [ Middleware ( GZipMiddleware )] ) Checkout this documentation from starlette on some conditions to using middleware on Mount","title":"Applying Middleware to Mount"},{"location":"techniques/response-model/","text":"Response Models \u00b6 Each route handler has key-value pair of status codes and a response model. This response model holds information on the type of response to be returned. # project_name/apps/items/controllers.py from ellar.common import Controller , get , Serializer , ControllerBase class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = UserSchema ) def me ( self ): return dict ( username = 'Ellar' , email = 'ellar@example.com' ) During route response computation, the me route handler response will evaluate to a JSONResponseModel with UserSchema as content validation schema. The resulting route responses will be: from ellar.common import Serializer from ellar.common.responses.models import JSONResponseModel class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None response = { 200 : JSONResponseModel ( model_field_or_schema = UserSchema )} For documentation purposes, we can apply some description to the returned response @get ( \"/me\" , response = ( UserSchema , 'User Schema Response' )) def me ( self ): return dict ( username = 'Ellar' , email = 'ellar@example.com' ) This will be translated to: response = { 200 : JSONResponseModel ( model_field_or_schema = UserSchema , description = 'User Schema Response' )} Info Each route handler has its own ResponseModel computation and validation. If there is no response definition, Ellar default the route handler model to EmptyAPIResponseModel . Override Response Type \u00b6 When you use a Response class as response, a ResponseModel is used and the response_type is replaced with applied response class. For example: # project_name/apps/items/controllers.py from ellar.common import Controller , get , ControllerBase , PlainTextResponse , Serializer class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = { 200 : PlainTextResponse , 201 : UserSchema }) def me ( self ): return \"some text response.\" This will be translated to: from ellar.common.responses.models import ResponseModel , JSONResponseModel from ellar.common import PlainTextResponse response = { 200 : ResponseModel ( response_type = PlainTextResponse ), 201 : JSONResponseModel ( model_field_or_schema = UserSchema )} Response Model Properties \u00b6 All response model follows IResponseModel contract. import typing as t from pydantic.fields import ModelField from ellar.common import IExecutionContext , Response class IResponseModel : media_type : str description : str get_model_field : t . Callable [ ... , t . Optional [ t . Union [ ModelField , t . Any ]]] create_response : t . Callable [[ IExecutionContext , t . Any ], Response ] Properties Overview: media_type : Read from response media type. Required description : For documentation purpose. Default: Success Response . Optional get_model_field : returns response schema if any. Optional create_response : returns a response for the client. Optional There is also a BaseResponseModel concrete class for more generic implementation. And its adds extra properties for configuration purposes. They include: response_type : Response classes eg. JSONResponse, PlainResponse, HTMLResponse. etc. Default: Response . Required model_field_or_schema : Optional property. For return data validation. Default: None Optional Different Response Models \u00b6 Let's see different ResponseModel available in Ellar and how you can create one too. ResponseModel \u00b6 Response model that manages rendering of other response types. Location: ellar.common.responses.models.ResponseModel response_type: Response model_field_or_schema: None media_type: text/plain JSONResponseModel \u00b6 Response model that manages JSON response. Location: ellar.common.responses.models.json.JSONResponseModel response_type: JSONResponse OR config.DEFAULT_JSON_CLASS model_field_or_schema: Required media_type: application/json HTMLResponseModel \u00b6 Response model that manages HTML templating response. see @render decorator. Location: ellar.common.responses.models.html.HTMLResponseModel response_type: TemplateResponse model_field_or_schema: None media_type: text/html FileResponseModel \u00b6 Response model that manages FILE response. see @file decorator. Location: ellar.common.responses.models.file.FileResponseModel response_type: FileResponse model_field_or_schema: None media_type: Required StreamingResponseModel \u00b6 Response model that manages STREAMING response. see @file decorator. Location: ellar.common.responses.models.file.StreamingResponseModel response_type: StreamingResponse model_field_or_schema: None media_type: Required EmptyAPIResponseModel \u00b6 Default ResponseModel applied when no response is defined. Location: ellar.common.responses.models.json.EmptyAPIResponseModel response_type: JSONResponse OR config.DEFAULT_JSON_CLASS model_field_or_schema: dict media_type: application/json Custom Response Model \u00b6 Lets create a new JSON response model. # project_name/apps/items/controllers.py import typing as t from ellar.common import Controller , get , ControllerBase , JSONResponse from ellar.common.responses.models import ResponseModel from dataclasses import dataclass @dataclass class NoteSchema : id : t . Union [ int , None ] text : str completed : bool class JsonApiResponse ( JSONResponse ): media_type = \"application/vnd.api+json\" class JsonApiResponseModel ( ResponseModel ): response_type = JsonApiResponse model_field_or_schema = t . List [ NoteSchema ] default_description = 'Successful JsonAPI Response' @Controller class ItemsController ( ControllerBase ): @get ( \"/notes/\" , response = JsonApiResponseModel ()) def get_notes ( self ): return [ dict ( id = 1 , text = 'My Json Api Response 1' , completed = True ), dict ( id = 2 , text = 'My Json Api Response 2' , completed = True ), ]","title":"Response Model"},{"location":"techniques/response-model/#response-models","text":"Each route handler has key-value pair of status codes and a response model. This response model holds information on the type of response to be returned. # project_name/apps/items/controllers.py from ellar.common import Controller , get , Serializer , ControllerBase class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = UserSchema ) def me ( self ): return dict ( username = 'Ellar' , email = 'ellar@example.com' ) During route response computation, the me route handler response will evaluate to a JSONResponseModel with UserSchema as content validation schema. The resulting route responses will be: from ellar.common import Serializer from ellar.common.responses.models import JSONResponseModel class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None response = { 200 : JSONResponseModel ( model_field_or_schema = UserSchema )} For documentation purposes, we can apply some description to the returned response @get ( \"/me\" , response = ( UserSchema , 'User Schema Response' )) def me ( self ): return dict ( username = 'Ellar' , email = 'ellar@example.com' ) This will be translated to: response = { 200 : JSONResponseModel ( model_field_or_schema = UserSchema , description = 'User Schema Response' )} Info Each route handler has its own ResponseModel computation and validation. If there is no response definition, Ellar default the route handler model to EmptyAPIResponseModel .","title":"Response Models"},{"location":"techniques/response-model/#override-response-type","text":"When you use a Response class as response, a ResponseModel is used and the response_type is replaced with applied response class. For example: # project_name/apps/items/controllers.py from ellar.common import Controller , get , ControllerBase , PlainTextResponse , Serializer class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = { 200 : PlainTextResponse , 201 : UserSchema }) def me ( self ): return \"some text response.\" This will be translated to: from ellar.common.responses.models import ResponseModel , JSONResponseModel from ellar.common import PlainTextResponse response = { 200 : ResponseModel ( response_type = PlainTextResponse ), 201 : JSONResponseModel ( model_field_or_schema = UserSchema )}","title":"Override Response Type"},{"location":"techniques/response-model/#response-model-properties","text":"All response model follows IResponseModel contract. import typing as t from pydantic.fields import ModelField from ellar.common import IExecutionContext , Response class IResponseModel : media_type : str description : str get_model_field : t . Callable [ ... , t . Optional [ t . Union [ ModelField , t . Any ]]] create_response : t . Callable [[ IExecutionContext , t . Any ], Response ] Properties Overview: media_type : Read from response media type. Required description : For documentation purpose. Default: Success Response . Optional get_model_field : returns response schema if any. Optional create_response : returns a response for the client. Optional There is also a BaseResponseModel concrete class for more generic implementation. And its adds extra properties for configuration purposes. They include: response_type : Response classes eg. JSONResponse, PlainResponse, HTMLResponse. etc. Default: Response . Required model_field_or_schema : Optional property. For return data validation. Default: None Optional","title":"Response Model Properties"},{"location":"techniques/response-model/#different-response-models","text":"Let's see different ResponseModel available in Ellar and how you can create one too.","title":"Different Response Models"},{"location":"techniques/response-model/#responsemodel","text":"Response model that manages rendering of other response types. Location: ellar.common.responses.models.ResponseModel response_type: Response model_field_or_schema: None media_type: text/plain","title":"ResponseModel"},{"location":"techniques/response-model/#jsonresponsemodel","text":"Response model that manages JSON response. Location: ellar.common.responses.models.json.JSONResponseModel response_type: JSONResponse OR config.DEFAULT_JSON_CLASS model_field_or_schema: Required media_type: application/json","title":"JSONResponseModel"},{"location":"techniques/response-model/#htmlresponsemodel","text":"Response model that manages HTML templating response. see @render decorator. Location: ellar.common.responses.models.html.HTMLResponseModel response_type: TemplateResponse model_field_or_schema: None media_type: text/html","title":"HTMLResponseModel"},{"location":"techniques/response-model/#fileresponsemodel","text":"Response model that manages FILE response. see @file decorator. Location: ellar.common.responses.models.file.FileResponseModel response_type: FileResponse model_field_or_schema: None media_type: Required","title":"FileResponseModel"},{"location":"techniques/response-model/#streamingresponsemodel","text":"Response model that manages STREAMING response. see @file decorator. Location: ellar.common.responses.models.file.StreamingResponseModel response_type: StreamingResponse model_field_or_schema: None media_type: Required","title":"StreamingResponseModel"},{"location":"techniques/response-model/#emptyapiresponsemodel","text":"Default ResponseModel applied when no response is defined. Location: ellar.common.responses.models.json.EmptyAPIResponseModel response_type: JSONResponse OR config.DEFAULT_JSON_CLASS model_field_or_schema: dict media_type: application/json","title":"EmptyAPIResponseModel"},{"location":"techniques/response-model/#custom-response-model","text":"Lets create a new JSON response model. # project_name/apps/items/controllers.py import typing as t from ellar.common import Controller , get , ControllerBase , JSONResponse from ellar.common.responses.models import ResponseModel from dataclasses import dataclass @dataclass class NoteSchema : id : t . Union [ int , None ] text : str completed : bool class JsonApiResponse ( JSONResponse ): media_type = \"application/vnd.api+json\" class JsonApiResponseModel ( ResponseModel ): response_type = JsonApiResponse model_field_or_schema = t . List [ NoteSchema ] default_description = 'Successful JsonAPI Response' @Controller class ItemsController ( ControllerBase ): @get ( \"/notes/\" , response = JsonApiResponseModel ()) def get_notes ( self ): return [ dict ( id = 1 , text = 'My Json Api Response 1' , completed = True ), dict ( id = 2 , text = 'My Json Api Response 2' , completed = True ), ]","title":"Custom Response Model"},{"location":"techniques/serializers/","text":"Serializers \u00b6 The Serializer class in the Ellar, is a custom class based on pydantic models, which provides additional functionality specific to Ellar's requirements. To use Serializer in Ellar, you simply need to create a class that inherits from Serializer and define your data model using pydantic fields. Here's an example of how you could define a serializer class for a user model: from ellar.common import Serializer class UserSerializer ( Serializer ): name : str email : str age : int With this setup, you can use the UserSerializer class to validate incoming data and or serialize outgoing response data, ensuring that it matches the expected format before saving it to the database or returning it to the client. Handling Responses \u00b6 Let's see how we can use Serializer as a responses schema which will help us validate out data output and also provide documentation on route function response. The response schema is defined on the HTTP method decorator. For example: # project_name/apps/items/controllers.py from ellar.common import Controller , get , Serializer , ControllerBase # Define a User class with username, email, first_name, and last_name attributes class User : def __init__ ( self , username : str , email : str = None , first_name : str = None , last_name : str = None ) -> None : self . username = username self . email = email self . first_name = first_name self . last_name = last_name self . is_authenticated = False @property def full_name ( self ) -> str : assert self . first_name and self . last_name return f ' { self . first_name } { self . last_name } ' # Define a Serializer class to validate response data class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None # Create a fake user object current_user = User ( username = 'ellar' , email = 'ellar@example.com' , first_name = 'ellar' , last_name = 'asgi' ) # Define an endpoint that returns the fake user's information @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = UserSchema ) def me ( self ): return current_user This code sets up a User model and a UserSerializer class based on the Serializer class. The User model represents a user with a username , email , first_name , and last_name . The UserSerializer class is used to define the expected format of the response data in the /me endpoint. When the /me endpoint is called, it returns the current_user object as the response. The UserSerializer is then used to parse and validate the current_user object, converting it into a dictionary representation that can be easily serialized to JSON. The resulting dictionary is then passed to the JSONResponseModel for serialization to a JSON string and sending the response to the client. Using Dataclass as Response Schema \u00b6 We can utilize the dataclasses feature as a response schema by utilizing the DataclassSerializer a base class. For instance, we can convert the UserSchema to a dataclass by defining UserDataclass as follows: from dataclasses import dataclass from ellar.common import DataclassSerializer @dataclass class UserDataclass ( DataclassSerializer ): username : str email : str = None first_name : str = None last_name : str = None By replacing the UserSchema with UserDataclass , we can expect the same outcomes in the returned response, response validation, and documentation. Multiple Response Types \u00b6 The response parameter takes different shape. Let's see how to return a different response if the user is not authenticated. # project_name/apps/items/controllers.py from ellar.common import Controller , get , ControllerBase , Serializer class User : def __init__ ( self , username : str , email : str = None , first_name : str = None , last_name : str = None ) -> None : self . username = username self . email = email self . first_name = first_name self . last_name = last_name self . is_authenticated = False @property def full_name ( self ) -> str : assert self . first_name and self . last_name return f ' { self . first_name } { self . last_name } ' class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None class MessageSchema ( Serializer ): message : str current_user = User ( username = 'ellar' , email = 'ellar@example.com' , first_name = 'ellar' , last_name = 'asgi' ) @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = { 200 : UserSchema , 403 : MessageSchema }) def me ( self ): if not current_user . is_authenticated : return 403 , { \"message\" : \"Please sign in first\" } return current_user @get ( \"/login\" , response = MessageSchema ) def login ( self ): if current_user . is_authenticated : return dict ( message = f ' { current_user . full_name } already logged in.' ) current_user . is_authenticated = True return MessageSchema ( message = f ' { current_user . full_name } logged in successfully.' ) # the same as returning dict(message=f'{current_user.full_name} logged in successfully.') Here, the response parameter takes a KeyValuePair of the status and response Schema . Info Note that we returned a tuple of status code and response data ( 403, {\"message\": \"Please sign in first\"} ) to specify the response validation to use. Using Response Type/Object As Response \u00b6 You can use Response type to change the format of data returned from endpoint functions. # project_name/apps/items/controllers.py from ellar.common import Controller , get , ControllerBase , PlainTextResponse @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = PlainTextResponse ) def me ( self ): return \"some text response.\" Also, we can return response object from endpoint functions, and it will override initial response declared before. # project_name/apps/items/controllers.py from ellar.common import Controller , get , Serializer , ControllerBase , PlainTextResponse class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = UserSchema ) def me ( self ): return PlainTextResponse ( \"some text response.\" , status_code = 200 )","title":"Serializers"},{"location":"techniques/serializers/#serializers","text":"The Serializer class in the Ellar, is a custom class based on pydantic models, which provides additional functionality specific to Ellar's requirements. To use Serializer in Ellar, you simply need to create a class that inherits from Serializer and define your data model using pydantic fields. Here's an example of how you could define a serializer class for a user model: from ellar.common import Serializer class UserSerializer ( Serializer ): name : str email : str age : int With this setup, you can use the UserSerializer class to validate incoming data and or serialize outgoing response data, ensuring that it matches the expected format before saving it to the database or returning it to the client.","title":"Serializers"},{"location":"techniques/serializers/#handling-responses","text":"Let's see how we can use Serializer as a responses schema which will help us validate out data output and also provide documentation on route function response. The response schema is defined on the HTTP method decorator. For example: # project_name/apps/items/controllers.py from ellar.common import Controller , get , Serializer , ControllerBase # Define a User class with username, email, first_name, and last_name attributes class User : def __init__ ( self , username : str , email : str = None , first_name : str = None , last_name : str = None ) -> None : self . username = username self . email = email self . first_name = first_name self . last_name = last_name self . is_authenticated = False @property def full_name ( self ) -> str : assert self . first_name and self . last_name return f ' { self . first_name } { self . last_name } ' # Define a Serializer class to validate response data class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None # Create a fake user object current_user = User ( username = 'ellar' , email = 'ellar@example.com' , first_name = 'ellar' , last_name = 'asgi' ) # Define an endpoint that returns the fake user's information @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = UserSchema ) def me ( self ): return current_user This code sets up a User model and a UserSerializer class based on the Serializer class. The User model represents a user with a username , email , first_name , and last_name . The UserSerializer class is used to define the expected format of the response data in the /me endpoint. When the /me endpoint is called, it returns the current_user object as the response. The UserSerializer is then used to parse and validate the current_user object, converting it into a dictionary representation that can be easily serialized to JSON. The resulting dictionary is then passed to the JSONResponseModel for serialization to a JSON string and sending the response to the client.","title":"Handling Responses"},{"location":"techniques/serializers/#using-dataclass-as-response-schema","text":"We can utilize the dataclasses feature as a response schema by utilizing the DataclassSerializer a base class. For instance, we can convert the UserSchema to a dataclass by defining UserDataclass as follows: from dataclasses import dataclass from ellar.common import DataclassSerializer @dataclass class UserDataclass ( DataclassSerializer ): username : str email : str = None first_name : str = None last_name : str = None By replacing the UserSchema with UserDataclass , we can expect the same outcomes in the returned response, response validation, and documentation.","title":"Using Dataclass as Response Schema"},{"location":"techniques/serializers/#multiple-response-types","text":"The response parameter takes different shape. Let's see how to return a different response if the user is not authenticated. # project_name/apps/items/controllers.py from ellar.common import Controller , get , ControllerBase , Serializer class User : def __init__ ( self , username : str , email : str = None , first_name : str = None , last_name : str = None ) -> None : self . username = username self . email = email self . first_name = first_name self . last_name = last_name self . is_authenticated = False @property def full_name ( self ) -> str : assert self . first_name and self . last_name return f ' { self . first_name } { self . last_name } ' class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None class MessageSchema ( Serializer ): message : str current_user = User ( username = 'ellar' , email = 'ellar@example.com' , first_name = 'ellar' , last_name = 'asgi' ) @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = { 200 : UserSchema , 403 : MessageSchema }) def me ( self ): if not current_user . is_authenticated : return 403 , { \"message\" : \"Please sign in first\" } return current_user @get ( \"/login\" , response = MessageSchema ) def login ( self ): if current_user . is_authenticated : return dict ( message = f ' { current_user . full_name } already logged in.' ) current_user . is_authenticated = True return MessageSchema ( message = f ' { current_user . full_name } logged in successfully.' ) # the same as returning dict(message=f'{current_user.full_name} logged in successfully.') Here, the response parameter takes a KeyValuePair of the status and response Schema . Info Note that we returned a tuple of status code and response data ( 403, {\"message\": \"Please sign in first\"} ) to specify the response validation to use.","title":"Multiple Response Types"},{"location":"techniques/serializers/#using-response-typeobject-as-response","text":"You can use Response type to change the format of data returned from endpoint functions. # project_name/apps/items/controllers.py from ellar.common import Controller , get , ControllerBase , PlainTextResponse @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = PlainTextResponse ) def me ( self ): return \"some text response.\" Also, we can return response object from endpoint functions, and it will override initial response declared before. # project_name/apps/items/controllers.py from ellar.common import Controller , get , Serializer , ControllerBase , PlainTextResponse class UserSchema ( Serializer ): username : str email : str = None first_name : str = None last_name : str = None @Controller class ItemsController ( ControllerBase ): @get ( \"/me\" , response = UserSchema ) def me ( self ): return PlainTextResponse ( \"some text response.\" , status_code = 200 )","title":"Using Response Type/Object As Response"},{"location":"techniques/staticfiles/","text":"Static Files \u00b6 A static file is a type of file that does not change often and is not generated by a server-side script. Examples of static files include images, CSS and JavaScript files, audio and video files, and other types of media. Static files in Ellar are served using the StaticFiles ASGI class, which is an extension of the Starlette StaticFiles ASGI class. This class uses the static files specified in the application's modules and configuration . In addition, Ellar creates a route that mounts the static server at the /static path. The path can be modified by providing a new value for the STATIC_MOUNT_PATH configuration variable. Configuring static files \u00b6 In your config file, define STATIC_MOUNT_PATH , for example: class Config : STATIC_MOUNT_PATH = '/static' Store your static files in a folder called static in your module. For example my_module/static/my_module/example.jpg . In your templates, use the url_for with static and path parameter to build the URL for the given relative path using the configured in STATIC_DIRECTORIES , STATIC_FOLDER_PACKAGES or Module. < img src = \"{{url_for('static', path='my_module/example.jpg')}}\" alt = \"My image\" > OR, visit /static/my_app/example.jpg Static File in Modules \u00b6 Managing multiple sets of static files in larger projects can be challenging, but by organizing each set of static files within a specific module, it becomes easier to manage and maintain. This approach allows for clear organization and separation of static assets, making it more manageable in a large project. In our previous project, within the car module folder, we can create a following directories, my_static/car . Inside this folder my_static/car , we can create a file named example.txt . This allows us to keep all of the static files related to the car module organized in one location my_static . Next, we tell CarModule about our static folder. # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .controllers import CarController @Module ( controllers = [ CarController ], static_folder = 'my_static' ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass Other Static Configurations \u00b6 In addition to setting static directories within modules, it is also possible to manually specify additional static directories that are not located within a module by using the STATIC_FOLDER_PACKAGES and STATIC_DIRECTORIES variables in the application's configuration. These variables allow for even more flexibility in organizing and managing static files in a project. These directories will be served by the StaticFiles ASGI class along with the module-scoped static files. STATIC_DIRECTORIES \u00b6 STATIC_DIRECTORIES variable is a list of directories within the project that contain static files. These directories are not necessarily scoped to a specific module and can be used to serve static files from any location within the project. These directories can be added to the STATIC_DIRECTORIES list in the application's configuration. STATIC_DIRECTORIES = [ 'project_name/static-files' , 'project_name/path/to/static/files' ] STATIC_FOLDER_PACKAGES \u00b6 STATIC_FOLDER_PACKAGES variable is a list of tuples that contain python packages that hold some static files. These packages should have a static folder and the package name should be passed as tuple (package_name, package_path) , package_path is the relative path of static folder. STATIC_FOLDER_PACKAGES = [( 'bootstrap' , 'statics' ), ( 'package-name' , 'path/to/static/directory' )] Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. In HTML mode if 404.html file exists it will be shown as 404 response.","title":"Static Files"},{"location":"techniques/staticfiles/#static-files","text":"A static file is a type of file that does not change often and is not generated by a server-side script. Examples of static files include images, CSS and JavaScript files, audio and video files, and other types of media. Static files in Ellar are served using the StaticFiles ASGI class, which is an extension of the Starlette StaticFiles ASGI class. This class uses the static files specified in the application's modules and configuration . In addition, Ellar creates a route that mounts the static server at the /static path. The path can be modified by providing a new value for the STATIC_MOUNT_PATH configuration variable.","title":"Static Files"},{"location":"techniques/staticfiles/#configuring-static-files","text":"In your config file, define STATIC_MOUNT_PATH , for example: class Config : STATIC_MOUNT_PATH = '/static' Store your static files in a folder called static in your module. For example my_module/static/my_module/example.jpg . In your templates, use the url_for with static and path parameter to build the URL for the given relative path using the configured in STATIC_DIRECTORIES , STATIC_FOLDER_PACKAGES or Module. < img src = \"{{url_for('static', path='my_module/example.jpg')}}\" alt = \"My image\" > OR, visit /static/my_app/example.jpg","title":"Configuring static files"},{"location":"techniques/staticfiles/#static-file-in-modules","text":"Managing multiple sets of static files in larger projects can be challenging, but by organizing each set of static files within a specific module, it becomes easier to manage and maintain. This approach allows for clear organization and separation of static assets, making it more manageable in a large project. In our previous project, within the car module folder, we can create a following directories, my_static/car . Inside this folder my_static/car , we can create a file named example.txt . This allows us to keep all of the static files related to the car module organized in one location my_static . Next, we tell CarModule about our static folder. # project_name/apps/car/module.py from ellar.common import Module from ellar.core import ModuleBase from ellar.di import Container from .controllers import CarController @Module ( controllers = [ CarController ], static_folder = 'my_static' ) class CarModule ( ModuleBase ): def register_providers ( self , container : Container ) -> None : # for more complicated provider registrations # container.register_instance(...) pass","title":"Static File in Modules"},{"location":"techniques/staticfiles/#other-static-configurations","text":"In addition to setting static directories within modules, it is also possible to manually specify additional static directories that are not located within a module by using the STATIC_FOLDER_PACKAGES and STATIC_DIRECTORIES variables in the application's configuration. These variables allow for even more flexibility in organizing and managing static files in a project. These directories will be served by the StaticFiles ASGI class along with the module-scoped static files.","title":"Other Static Configurations"},{"location":"techniques/staticfiles/#static_directories","text":"STATIC_DIRECTORIES variable is a list of directories within the project that contain static files. These directories are not necessarily scoped to a specific module and can be used to serve static files from any location within the project. These directories can be added to the STATIC_DIRECTORIES list in the application's configuration. STATIC_DIRECTORIES = [ 'project_name/static-files' , 'project_name/path/to/static/files' ]","title":"STATIC_DIRECTORIES"},{"location":"techniques/staticfiles/#static_folder_packages","text":"STATIC_FOLDER_PACKAGES variable is a list of tuples that contain python packages that hold some static files. These packages should have a static folder and the package name should be passed as tuple (package_name, package_path) , package_path is the relative path of static folder. STATIC_FOLDER_PACKAGES = [( 'bootstrap' , 'statics' ), ( 'package-name' , 'path/to/static/directory' )] Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. In HTML mode if 404.html file exists it will be shown as 404 response.","title":"STATIC_FOLDER_PACKAGES"},{"location":"techniques/templating/","text":"HTML Templating with Jinja \u00b6 Jinja2 is a powerful template engine for Python. It can be used in web applications to separate static and dynamic content, making it easier to maintain and update the dynamic content. In Ellar, a Model-View-Controller (MVC) framework, Jinja2 templates are typically used in the View layer to render dynamic content, while the Model and Controller layers handle the data and logic of the application. Installation \u00b6 Jinja2 package is installed alongside with Ellar. Quick overview on jinja2 Usage \u00b6 A Jinja2 template is a plain text file that contains dynamic content, represented using Jinja2 syntax. Here's an example template that displays a list of items: < html > < body > < ul > {% for item in items %} < li > {{ item }} </ li > {% endfor %} </ ul > </ body > </ html > The {% for item in items %} and {% endfor % } tags define a loop that iterates over the items list and displays each item as a list item. The {{ item }} tag inserts the value of the item variable into the template. To render the template, you'll need to use the Jinja2 API in your view function. Here's an example of how you might do this: # main.py import uvicorn from jinja2 import Environment , FileSystemLoader from ellar.core import Request , AppFactory from ellar.common import ModuleRouter , HTMLResponse from pathlib import Path BASE_DIR = Path ( __file__ ) . parent router = ModuleRouter ( '/template-testing' ) # Also create a templates folder at the main.py root dir. And add template.html into it @router . get () def view_function ( request : Request ): # Load the template file env = Environment ( loader = FileSystemLoader ( 'templates' )) template = env . get_template ( 'template.html' ) # Render the template with some dynamic data items = [ 'apple' , 'banana' , 'cherry' ] rendered_template = template . render ( items = items ) # Return the rendered template as the response return HTMLResponse ( rendered_template ) app = AppFactory . create_app ( routers = [ router ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) # visit: http://127.0.0.1:5000/template-testing/ This example loads the template.html file from the templates directory, renders it with the items list, and returns the rendered template as the HTTP response to the request. This example also shows manual setup of using jinja2 in Ellar. Jinja2 usage in Ellar \u00b6 In Ellar, the @render decorator transforms the route handler response into a Templated Response via an HTMLResponseModel with a status code of 200. And the route handler is required to return a dictionary object which serves as the template's context. Additionally, each registered Module functions as a jinja2 TemplateLoader for loading templates, but only when a templates_folder is provided and exists. In Controller \u00b6 In Controllers, the @render decorator uses the decorated function name + controller name to generate a path to the template when creating HTMLResponseModel to handle the response For example: # main.py import uvicorn from ellar.common import render , Controller , get from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent @Controller () class TemplateExampleController : @get ( '/' ) @render () def index ( self ): return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( controllers = [ TemplateExampleController ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) # visit: http://127.0.0.1:5000/templateexample/ In this example, the @render decorator will create an HTMLResponseModel with a template path = templateexample/index.html . When the @render decorator is applied to a Controller class, it assumes this pattern of resolving the template part. This behavior can be overridden by providing the template_name parameter on the @render decorator. For example: # main.py import uvicorn from ellar.common import render , Controller , get from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent @Controller () class TemplateExampleController : @get ( '/' ) @render ( template_name = 'templateexample/list.html' ) async def index ( self ): return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( controllers = [ TemplateExampleController ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) # visit: http://127.0.0.1:5000/templateexample In ModuleRouter \u00b6 In ModuleRouter , @render decorators will enforce the template_name provision when creating HTMLResponseModel . Ellar does not assume the function name to be equivalent to the template name because it's a wide scope of guess. A quick example: # main.py import uvicorn from ellar.core import Request , AppFactory from ellar.common import ModuleRouter , render from pathlib import Path BASE_DIR = Path ( __file__ ) . parent router = ModuleRouter ( '/template-testing' ) @router . get () @render ( 'some-path/template-name.html' ) async def index ( request : Request ): return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( routers = [ router ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) Info Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead, we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.' - Starlette Recommendation Jinja2 Configurations \u00b6 If there are specific configurations you want to apply to your Jinja2 Environment, you can look at JINJA_TEMPLATE_OPTIONS configuration. Default Jinja Template Context \u00b6 Every jinja template in ellar receives two context, url_for , config , request object and other specific context defined to render a template. url_for is a utility function that helps to resolve path to files and url(reversing url) config is current application configuration object. request is current request object. Static Files In Template \u00b6 As stated above, you can resolve file paths to static files using url_for . For example: < head > < meta charset = \"UTF-8\" > < title > Welcome - Ellar ASGI Python Framework </ title > < link rel = \"shortcut icon\" type = \"image/x-icon\" href = \"{{ url_for('static', path='img/Icon.svg') }}\" /> < link rel = \"stylesheet\" href = \"{{ url_for('static', path='css/bootstrap.min.css') }}\" > </ head > The url_for takes path parameter, in the case of static files, to match the directory and filename to be resolved. This url_for('static', path='img/Icon.svg') will search for img/Icon.svg in all registered static folders. Reversing Controllers URLs \u00b6 It is common to need to generate URLs for specific routes, particularly when returning a redirect response. This can be achieved by using the request.url_for method in the request object, or in the case of templating, by using the url_for() function. The request.url_for method generates a URL based on the current request context, while in template {{url_for()}} function generates a URL based on the current routing configuration. Both of them will generate a URL for a specific route, allowing the server to redirect the client to the correct location. In controllers, urls are reversed by joining the controller_name and route handler name like so controller_name:function_name . For example: # main.py import uvicorn from ellar.common import render , Controller , get , Req from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent @Controller () class TemplateExampleController : @get ( '/' ) @render () async def index ( self , request = Req ()): assert request . url_for ( 'templateexample:index' ) == 'http://127.0.0.1:5000/templateexample/' return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( controllers = [ TemplateExampleController ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) Then in templates/templateexample/index.html add the follow: < html > < body > < a href = \"{{url_for('templateexample:index')}}\" > Index </ a > </ body > </ html > In the example mentioned, controller_name is combined with function_name to generate the url for the 'index' route. In the same example, URL parameters can also be passed as keyword arguments to the url_for function. For example: url_for('templateexample:index', parameter_a='value1', parameter_b='value2') This would generate a URL that includes the values of parameter_a and parameter_b as URL parameters, like this : example.com/index/value1/value2 For instance: @get ( '/ {parameter_a} / {parameter_b} ' ) @render () async def index ( self , parameter_a : str , request = Req ()): assert request . url_for ( 'templateexample:index' , parameter_a = 'ellar' ) == 'http://127.0.0.1:5000/templateexample/ellar' return { 'name' : 'Ellar Template' } In the example request.url_for('templateexample:index', parameter_a='ellar') , we can see that the parameter_a is used as a keyword argument to satisfy the dependency on the parameter_a parameter in the URL being generated. Info If the url_for function is called with a path that does not exist or with insufficient parameters to resolve an existing URL, it will raise a starlette.routing.NoMatchFound exception. Reversing Module Router URLs \u00b6 Just like in controller, we can also reverse URLs that belongs to ModuleRouter . # main.py import uvicorn from ellar.common import ModuleRouter , Req from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent router = ModuleRouter ( '/template-reversing' , name = 'users' ) @router . get ( '/ {user_id} ' ) def profile ( user_id : str , request = Req ()): profile_url = request . url_for ( 'users:profile' , user_id = user_id ) return profile_url app = AppFactory . create_app ( routers = [ router ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) In the example you mentioned, by adding name='users' to the router, it provides a unique way to reverse the routing pattern for the router. We can now use the name along with the route function name in the form of {name}:{function_name} to resolve the URL. As you can see in request.url_for('users:profile', user_id=user_id) the 'users:profile' is the string passed to the url_for method. This is using the name as \"users\" and the function name as \"profile\" to generate the url based on the routing configuration. The user_id parameter is passed as keyword argument which will be used to construct the URL based on the routing configuration, which should include a parameter for user_id However, If you don't provide a name on the router, you'll have to use only the function name to resolve the URL. For example, request.url_for('profile', user_id=user_id) . In this case, the routing configuration should have a route that match the function name 'profile' and have a parameter for user_id in the routing path. For example: router = ModuleRouter ( '/template-reversing' ) @router . get ( '/ {user_id} ' ) def profile ( user_id : str , request = Req ()): profile_url = request . url_for ( 'profile' , user_id = user_id ) return profile_url It's worth noting that providing a unique name to a router is useful if you have multiple routes with the same function name, or to make the URL reversing more readable or meaningful. Overriding Reversing URL Function Name \u00b6 You can override the function_name part of reversing the URL by providing a name on the route method decorator. Each route method has an optional name parameter, which, when set, is used in place of the function name when reversing the URL. For example, you could have the following code: router = ModuleRouter ( '/template-reversing' , name = 'users' ) @router . get ( \"/profile/ {user_id} \" , name = \"user_profile\" ) async def profile ( user_id : str , request = Req ()): profile_url = request . url_for ( 'users:user_profile' , user_id = user_id ) return profile_url In this case, when reversing the URL, you would use request.url_for('users:user_profile', user_id=user_id) which will generate http://127.0.0.1:5000/template-reversing/profile/value_of_user_id based on routing configuration. This allows for greater control and readability when reversing URLs, and makes it less prone to error if the function name of the route were to change in the future. Adding template filters and template globals. \u00b6 Jinja template filter and global functions can be defined at module level as shown here: Module Templating Filters","title":"Html"},{"location":"techniques/templating/#html-templating-with-jinja","text":"Jinja2 is a powerful template engine for Python. It can be used in web applications to separate static and dynamic content, making it easier to maintain and update the dynamic content. In Ellar, a Model-View-Controller (MVC) framework, Jinja2 templates are typically used in the View layer to render dynamic content, while the Model and Controller layers handle the data and logic of the application.","title":"HTML Templating with Jinja"},{"location":"techniques/templating/#installation","text":"Jinja2 package is installed alongside with Ellar.","title":"Installation"},{"location":"techniques/templating/#quick-overview-on-jinja2-usage","text":"A Jinja2 template is a plain text file that contains dynamic content, represented using Jinja2 syntax. Here's an example template that displays a list of items: < html > < body > < ul > {% for item in items %} < li > {{ item }} </ li > {% endfor %} </ ul > </ body > </ html > The {% for item in items %} and {% endfor % } tags define a loop that iterates over the items list and displays each item as a list item. The {{ item }} tag inserts the value of the item variable into the template. To render the template, you'll need to use the Jinja2 API in your view function. Here's an example of how you might do this: # main.py import uvicorn from jinja2 import Environment , FileSystemLoader from ellar.core import Request , AppFactory from ellar.common import ModuleRouter , HTMLResponse from pathlib import Path BASE_DIR = Path ( __file__ ) . parent router = ModuleRouter ( '/template-testing' ) # Also create a templates folder at the main.py root dir. And add template.html into it @router . get () def view_function ( request : Request ): # Load the template file env = Environment ( loader = FileSystemLoader ( 'templates' )) template = env . get_template ( 'template.html' ) # Render the template with some dynamic data items = [ 'apple' , 'banana' , 'cherry' ] rendered_template = template . render ( items = items ) # Return the rendered template as the response return HTMLResponse ( rendered_template ) app = AppFactory . create_app ( routers = [ router ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) # visit: http://127.0.0.1:5000/template-testing/ This example loads the template.html file from the templates directory, renders it with the items list, and returns the rendered template as the HTTP response to the request. This example also shows manual setup of using jinja2 in Ellar.","title":"Quick overview on jinja2 Usage"},{"location":"techniques/templating/#jinja2-usage-in-ellar","text":"In Ellar, the @render decorator transforms the route handler response into a Templated Response via an HTMLResponseModel with a status code of 200. And the route handler is required to return a dictionary object which serves as the template's context. Additionally, each registered Module functions as a jinja2 TemplateLoader for loading templates, but only when a templates_folder is provided and exists.","title":"Jinja2 usage in Ellar"},{"location":"techniques/templating/#in-controller","text":"In Controllers, the @render decorator uses the decorated function name + controller name to generate a path to the template when creating HTMLResponseModel to handle the response For example: # main.py import uvicorn from ellar.common import render , Controller , get from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent @Controller () class TemplateExampleController : @get ( '/' ) @render () def index ( self ): return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( controllers = [ TemplateExampleController ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) # visit: http://127.0.0.1:5000/templateexample/ In this example, the @render decorator will create an HTMLResponseModel with a template path = templateexample/index.html . When the @render decorator is applied to a Controller class, it assumes this pattern of resolving the template part. This behavior can be overridden by providing the template_name parameter on the @render decorator. For example: # main.py import uvicorn from ellar.common import render , Controller , get from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent @Controller () class TemplateExampleController : @get ( '/' ) @render ( template_name = 'templateexample/list.html' ) async def index ( self ): return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( controllers = [ TemplateExampleController ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) # visit: http://127.0.0.1:5000/templateexample","title":"In Controller"},{"location":"techniques/templating/#in-modulerouter","text":"In ModuleRouter , @render decorators will enforce the template_name provision when creating HTMLResponseModel . Ellar does not assume the function name to be equivalent to the template name because it's a wide scope of guess. A quick example: # main.py import uvicorn from ellar.core import Request , AppFactory from ellar.common import ModuleRouter , render from pathlib import Path BASE_DIR = Path ( __file__ ) . parent router = ModuleRouter ( '/template-testing' ) @router . get () @render ( 'some-path/template-name.html' ) async def index ( request : Request ): return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( routers = [ router ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) Info Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead, we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.' - Starlette Recommendation","title":"In ModuleRouter"},{"location":"techniques/templating/#jinja2-configurations","text":"If there are specific configurations you want to apply to your Jinja2 Environment, you can look at JINJA_TEMPLATE_OPTIONS configuration.","title":"Jinja2 Configurations"},{"location":"techniques/templating/#default-jinja-template-context","text":"Every jinja template in ellar receives two context, url_for , config , request object and other specific context defined to render a template. url_for is a utility function that helps to resolve path to files and url(reversing url) config is current application configuration object. request is current request object.","title":"Default Jinja Template Context"},{"location":"techniques/templating/#static-files-in-template","text":"As stated above, you can resolve file paths to static files using url_for . For example: < head > < meta charset = \"UTF-8\" > < title > Welcome - Ellar ASGI Python Framework </ title > < link rel = \"shortcut icon\" type = \"image/x-icon\" href = \"{{ url_for('static', path='img/Icon.svg') }}\" /> < link rel = \"stylesheet\" href = \"{{ url_for('static', path='css/bootstrap.min.css') }}\" > </ head > The url_for takes path parameter, in the case of static files, to match the directory and filename to be resolved. This url_for('static', path='img/Icon.svg') will search for img/Icon.svg in all registered static folders.","title":"Static Files In Template"},{"location":"techniques/templating/#reversing-controllers-urls","text":"It is common to need to generate URLs for specific routes, particularly when returning a redirect response. This can be achieved by using the request.url_for method in the request object, or in the case of templating, by using the url_for() function. The request.url_for method generates a URL based on the current request context, while in template {{url_for()}} function generates a URL based on the current routing configuration. Both of them will generate a URL for a specific route, allowing the server to redirect the client to the correct location. In controllers, urls are reversed by joining the controller_name and route handler name like so controller_name:function_name . For example: # main.py import uvicorn from ellar.common import render , Controller , get , Req from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent @Controller () class TemplateExampleController : @get ( '/' ) @render () async def index ( self , request = Req ()): assert request . url_for ( 'templateexample:index' ) == 'http://127.0.0.1:5000/templateexample/' return { 'name' : 'Ellar Template' } app = AppFactory . create_app ( controllers = [ TemplateExampleController ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) Then in templates/templateexample/index.html add the follow: < html > < body > < a href = \"{{url_for('templateexample:index')}}\" > Index </ a > </ body > </ html > In the example mentioned, controller_name is combined with function_name to generate the url for the 'index' route. In the same example, URL parameters can also be passed as keyword arguments to the url_for function. For example: url_for('templateexample:index', parameter_a='value1', parameter_b='value2') This would generate a URL that includes the values of parameter_a and parameter_b as URL parameters, like this : example.com/index/value1/value2 For instance: @get ( '/ {parameter_a} / {parameter_b} ' ) @render () async def index ( self , parameter_a : str , request = Req ()): assert request . url_for ( 'templateexample:index' , parameter_a = 'ellar' ) == 'http://127.0.0.1:5000/templateexample/ellar' return { 'name' : 'Ellar Template' } In the example request.url_for('templateexample:index', parameter_a='ellar') , we can see that the parameter_a is used as a keyword argument to satisfy the dependency on the parameter_a parameter in the URL being generated. Info If the url_for function is called with a path that does not exist or with insufficient parameters to resolve an existing URL, it will raise a starlette.routing.NoMatchFound exception.","title":"Reversing Controllers URLs"},{"location":"techniques/templating/#reversing-module-router-urls","text":"Just like in controller, we can also reverse URLs that belongs to ModuleRouter . # main.py import uvicorn from ellar.common import ModuleRouter , Req from ellar.core import AppFactory from pathlib import Path BASE_DIR = Path ( __file__ ) . parent router = ModuleRouter ( '/template-reversing' , name = 'users' ) @router . get ( '/ {user_id} ' ) def profile ( user_id : str , request = Req ()): profile_url = request . url_for ( 'users:profile' , user_id = user_id ) return profile_url app = AppFactory . create_app ( routers = [ router ], template_folder = 'templates' , base_directory = BASE_DIR ) if __name__ == \"__main__\" : uvicorn . run ( \"main:app\" , port = 5000 , log_level = \"info\" ) In the example you mentioned, by adding name='users' to the router, it provides a unique way to reverse the routing pattern for the router. We can now use the name along with the route function name in the form of {name}:{function_name} to resolve the URL. As you can see in request.url_for('users:profile', user_id=user_id) the 'users:profile' is the string passed to the url_for method. This is using the name as \"users\" and the function name as \"profile\" to generate the url based on the routing configuration. The user_id parameter is passed as keyword argument which will be used to construct the URL based on the routing configuration, which should include a parameter for user_id However, If you don't provide a name on the router, you'll have to use only the function name to resolve the URL. For example, request.url_for('profile', user_id=user_id) . In this case, the routing configuration should have a route that match the function name 'profile' and have a parameter for user_id in the routing path. For example: router = ModuleRouter ( '/template-reversing' ) @router . get ( '/ {user_id} ' ) def profile ( user_id : str , request = Req ()): profile_url = request . url_for ( 'profile' , user_id = user_id ) return profile_url It's worth noting that providing a unique name to a router is useful if you have multiple routes with the same function name, or to make the URL reversing more readable or meaningful.","title":"Reversing Module Router URLs"},{"location":"techniques/templating/#overriding-reversing-url-function-name","text":"You can override the function_name part of reversing the URL by providing a name on the route method decorator. Each route method has an optional name parameter, which, when set, is used in place of the function name when reversing the URL. For example, you could have the following code: router = ModuleRouter ( '/template-reversing' , name = 'users' ) @router . get ( \"/profile/ {user_id} \" , name = \"user_profile\" ) async def profile ( user_id : str , request = Req ()): profile_url = request . url_for ( 'users:user_profile' , user_id = user_id ) return profile_url In this case, when reversing the URL, you would use request.url_for('users:user_profile', user_id=user_id) which will generate http://127.0.0.1:5000/template-reversing/profile/value_of_user_id based on routing configuration. This allows for greater control and readability when reversing URLs, and makes it less prone to error if the function name of the route were to change in the future.","title":"Overriding Reversing URL Function Name"},{"location":"techniques/templating/#adding-template-filters-and-template-globals","text":"Jinja template filter and global functions can be defined at module level as shown here: Module Templating Filters","title":"Adding template filters and template globals."},{"location":"techniques/versioning/","text":"Versioning \u00b6 Versioning allows for the existence of multiple versions of controllers or individual routes within the same application, which can be useful when making changes that may break previous versions. This allows developers to support older versions of the application while still making necessary updates. There are 4 types of versioning that are supported: URL Versioning : The version will be passed within the URL of the request Header Versioning : A custom request header will specify the version Query Versioning : A custom request query will specify the version Host Versioning : The version will be part of the request client host URL Versioning \u00b6 This scheme requires the client to specify the version as part of the URL path. GET /v1/receipes/ HTTP/1.1 Host: example.com Accept: application/json To enable URL Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . URL , version_parameter = 'v' , default_version = None ) The URL path will be parsed with the provided version_parameter , v , to determine specified version. For example, https://example.com/v1/route , will resolve to version='1' and https://example.com/v3/route , will resolve to version='3' . If version is not specified in the URL, the default_version will be used. Which in this case is None . Header Versioning \u00b6 This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type. Here's an example HTTP request using accept header versioning style. GET /receipes/ HTTP/1.1 Host: example.com Accept: application/json; version=1 To enable Header Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . HEADER , header_parameter = 'accept' , version_parameter = 'version' , default_version = None ) During request handling, request header accept value will be parsed to read the version value. A header accept: application/json; version=2 will resolve to version='2' Using Custom Header \u00b6 We can also use a custom header asides accept . for example: GET /receipes/ HTTP/1.1 Host: example.com X-Custom-Header: version=2 And then we enable it with the code below: # project_name/server.py ... application . enable_versioning ( VersioningSchemes . HEADER , header_parameter = 'x-custom-header' , version_parameter = 'version_header' , default_version = None ) The header property, x-custom-header , will be the name of the header that will contain the version of the request. And the value follow the format [version_parameter]=version-number; , for example: headers={'x-custom-header': 'version_header=3'} will resolve to version='3' . Query Versioning \u00b6 This scheme is a simple style that includes the version as a query parameter in the URL. For example: GET /receipes?version=2 HTTP/1.1 Host: example.com Accept: application/json To enable Query Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . QUERY , version_parameter = 'version' , default_version = None ) Host Versioning \u00b6 The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL. For example the following is an HTTP request to the http://v1.example.com/receipes/ URL: GET /receipes/ HTTP/1.1 Host: v1.example.com Accept: application/json To enable Host Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . HOST , version_parameter = 'v' , default_version = None ) By default, this implementation expects the hostname to match this simple regular expression: ^([a-zA-Z0-9]+)\\.[a-zA-Z0-9]+\\.[a-zA-Z0-9]+$ Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname. The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case. Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions. Controller Versions \u00b6 A version can be applied to a controller by using Version decorator from ellar.common package. To add a version to a controller do the following: from ellar.common import Controller , Version @Controller ( '/example' ) @Version ( '1' ) class ExampleControllerV1 : pass Route Versions \u00b6 A version can be applied to an individual route. This version will override any other version that would effect the route, such as the Controller Version. To add a version to an individual route do the following: from ellar.common import Controller , Version , get @Controller ( '/example' ) class ExampleController : @Version ( '1' ) @get ( '/items' ) async def get_items_v1 ( self ): return 'This action returns all items for version 1' @get ( '/items' ) @Version ( '2' ) async def get_items_v2 ( self ): return 'This action returns all items for version 2' Multiple Versions \u00b6 Multiple versions can be applied to a controller or route. To use multiple versions, you would set the version to be an Array. To add multiple versions do the following: from ellar.common import Controller , Version , get @Controller ( '/example' ) @Version ( '1' , '2' ) class ExampleControllerV1AndV2 : @get ( '/items' ) async def get_items ( self ): return 'This action returns all items for version 1 & 2'","title":"Versioning"},{"location":"techniques/versioning/#versioning","text":"Versioning allows for the existence of multiple versions of controllers or individual routes within the same application, which can be useful when making changes that may break previous versions. This allows developers to support older versions of the application while still making necessary updates. There are 4 types of versioning that are supported: URL Versioning : The version will be passed within the URL of the request Header Versioning : A custom request header will specify the version Query Versioning : A custom request query will specify the version Host Versioning : The version will be part of the request client host","title":"Versioning"},{"location":"techniques/versioning/#url-versioning","text":"This scheme requires the client to specify the version as part of the URL path. GET /v1/receipes/ HTTP/1.1 Host: example.com Accept: application/json To enable URL Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . URL , version_parameter = 'v' , default_version = None ) The URL path will be parsed with the provided version_parameter , v , to determine specified version. For example, https://example.com/v1/route , will resolve to version='1' and https://example.com/v3/route , will resolve to version='3' . If version is not specified in the URL, the default_version will be used. Which in this case is None .","title":"URL Versioning"},{"location":"techniques/versioning/#header-versioning","text":"This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type. Here's an example HTTP request using accept header versioning style. GET /receipes/ HTTP/1.1 Host: example.com Accept: application/json; version=1 To enable Header Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . HEADER , header_parameter = 'accept' , version_parameter = 'version' , default_version = None ) During request handling, request header accept value will be parsed to read the version value. A header accept: application/json; version=2 will resolve to version='2'","title":"Header Versioning"},{"location":"techniques/versioning/#using-custom-header","text":"We can also use a custom header asides accept . for example: GET /receipes/ HTTP/1.1 Host: example.com X-Custom-Header: version=2 And then we enable it with the code below: # project_name/server.py ... application . enable_versioning ( VersioningSchemes . HEADER , header_parameter = 'x-custom-header' , version_parameter = 'version_header' , default_version = None ) The header property, x-custom-header , will be the name of the header that will contain the version of the request. And the value follow the format [version_parameter]=version-number; , for example: headers={'x-custom-header': 'version_header=3'} will resolve to version='3' .","title":"Using Custom Header"},{"location":"techniques/versioning/#query-versioning","text":"This scheme is a simple style that includes the version as a query parameter in the URL. For example: GET /receipes?version=2 HTTP/1.1 Host: example.com Accept: application/json To enable Query Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . QUERY , version_parameter = 'version' , default_version = None )","title":"Query Versioning"},{"location":"techniques/versioning/#host-versioning","text":"The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL. For example the following is an HTTP request to the http://v1.example.com/receipes/ URL: GET /receipes/ HTTP/1.1 Host: v1.example.com Accept: application/json To enable Host Versioning for your application, do the following: # project_name/server.py import os from ellar.common.constants import ELLAR_CONFIG_MODULE from ellar.core.factory import AppFactory from ellar.core.versioning import VersioningSchemes from .root_module import ApplicationModule application = AppFactory . create_from_app_module ( ApplicationModule , config_module = os . environ . get ( ELLAR_CONFIG_MODULE , \"dialerai.config:DevelopmentConfig\" ), global_guards = [] ) application . enable_versioning ( VersioningSchemes . HOST , version_parameter = 'v' , default_version = None ) By default, this implementation expects the hostname to match this simple regular expression: ^([a-zA-Z0-9]+)\\.[a-zA-Z0-9]+\\.[a-zA-Z0-9]+$ Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname. The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case. Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.","title":"Host Versioning"},{"location":"techniques/versioning/#controller-versions","text":"A version can be applied to a controller by using Version decorator from ellar.common package. To add a version to a controller do the following: from ellar.common import Controller , Version @Controller ( '/example' ) @Version ( '1' ) class ExampleControllerV1 : pass","title":"Controller Versions"},{"location":"techniques/versioning/#route-versions","text":"A version can be applied to an individual route. This version will override any other version that would effect the route, such as the Controller Version. To add a version to an individual route do the following: from ellar.common import Controller , Version , get @Controller ( '/example' ) class ExampleController : @Version ( '1' ) @get ( '/items' ) async def get_items_v1 ( self ): return 'This action returns all items for version 1' @get ( '/items' ) @Version ( '2' ) async def get_items_v2 ( self ): return 'This action returns all items for version 2'","title":"Route Versions"},{"location":"techniques/versioning/#multiple-versions","text":"Multiple versions can be applied to a controller or route. To use multiple versions, you would set the version to be an Array. To add multiple versions do the following: from ellar.common import Controller , Version , get @Controller ( '/example' ) @Version ( '1' , '2' ) class ExampleControllerV1AndV2 : @get ( '/items' ) async def get_items ( self ): return 'This action returns all items for version 1 & 2'","title":"Multiple Versions"},{"location":"techniques/validations/","text":"Input Validation Tutorial \u00b6 In this section, we are going to learn how inputs are parsed in the Ellar route handle functions. To get started, we need to create another module for this tutorial. Open the terminal, navigate to the root level of the project and run the command that scaffolds a new module to your project. $( venv ) ellar create-module items Next, goto project_name/root_module.py and add ItemsModule to list of modules. from ellar.common import Module , exception_handler , IExecutionContext , JSONResponse , Response from ellar.core import ModuleBase from ellar.samples.modules import HomeModule from .apps.car.module import CarModule from .apps.items.module import ItemsModule @Module ( modules = [ HomeModule , CarModule , ItemsModule ]) class ApplicationModule ( ModuleBase ): @exception_handler ( 404 ) def exception_404_handler ( cls , ctx : IExecutionContext , exc : Exception ) -> Response : return JSONResponse ( dict ( detail = \"Resource not found.\" )) With the server running: $( venv ) ellar runserver --reload visit http://localhost:8000/items/ , { \"detail\" : \"Welcome Items Resource\" } All code example will be done on the ItemController in project_name/apps/items/controllers.py . Please keep it open. Tutorial \u00b6 You are going to learn how to use the following route handler parameter: Path Query Header Cookie Body Form File","title":"Index"},{"location":"techniques/validations/#input-validation-tutorial","text":"In this section, we are going to learn how inputs are parsed in the Ellar route handle functions. To get started, we need to create another module for this tutorial. Open the terminal, navigate to the root level of the project and run the command that scaffolds a new module to your project. $( venv ) ellar create-module items Next, goto project_name/root_module.py and add ItemsModule to list of modules. from ellar.common import Module , exception_handler , IExecutionContext , JSONResponse , Response from ellar.core import ModuleBase from ellar.samples.modules import HomeModule from .apps.car.module import CarModule from .apps.items.module import ItemsModule @Module ( modules = [ HomeModule , CarModule , ItemsModule ]) class ApplicationModule ( ModuleBase ): @exception_handler ( 404 ) def exception_404_handler ( cls , ctx : IExecutionContext , exc : Exception ) -> Response : return JSONResponse ( dict ( detail = \"Resource not found.\" )) With the server running: $( venv ) ellar runserver --reload visit http://localhost:8000/items/ , { \"detail\" : \"Welcome Items Resource\" } All code example will be done on the ItemController in project_name/apps/items/controllers.py . Please keep it open.","title":"Input Validation Tutorial"},{"location":"techniques/validations/#tutorial","text":"You are going to learn how to use the following route handler parameter: Path Query Header Cookie Body Form File","title":"Tutorial"},{"location":"techniques/validations/body/","text":"Request Body \u00b6 Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Ellar Serializer . Info Under the hood Ellar uses Pydantic models with all their power and benefits. Import Serializer \u00b6 First, you need to import Serializer from ella.serializer : # project_name/apps/items/controllers.py from ellar.common import Serializer # class Item(Serializer): # name: str # description: str = None # price: float # quantity: int Create your data model \u00b6 Then you declare your data model as a class that inherits from Serializer . Use standard Python types for all the attributes: # project_name/apps/items/controllers.py from ellar.common import Serializer , ControllerBase , Controller , post class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Alexis\" , \"description\" : \"An optional description\" , \"price\" : 400.00 , \"quantity\" : 6 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Alexis\" , \"price\" : 200.00 , \"quantity\" : 12 } Declare it as a parameter \u00b6 To add it to your path operation , declare it the same way you declared the path and query parameters: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item ... and declare its type as the model you created, Item . Results \u00b6 With just that Python type declaration, Ellar will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and meaningful error, indicating exactly where and what the incorrect data was. Give you the received data in the parameter item . Because you declared it in the function to be of type Item , you will also have all the editor support (completion, etc.) for all the attributes and their types. Generate JSON Schema definitions for your models, and you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UI's . Automatic Docs \u00b6 The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: ... and they will be also used in the API docs inside each path operation that needs them: Request Body + Path parameters \u00b6 You can declare path parameters and body requests at the same time. Ellar will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Serializer should be taken from the request body . # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , put , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/items/ {item_id} \" ) def update ( self , item_id : int , item : Item ): return { \"item_id\" : item_id , \"item\" : item . dict ()} Request Body + Path + Query parameters \u00b6 You can also declare body , path and query parameters, all at the same time. Ellar will recognize each of them and take the data from the correct place. # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , put , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } The function parameters will be recognized as follows: If the parameter is also declared in the path , it will be used as a path parameter. If the parameter is of a singular type (like int , float , str , bool , etc.), it will be interpreted as a query parameter. If the parameter is declared to be of the type of Serializer (or Pydantic BaseModel ), it will be interpreted as a request body . Info In here, we have combined both Serializers and Controllers in one file. This is for the convenience of writing this documentation. It's advised to have all your serializers in schemas.py and then import them over to controllers.py if needed. Singular values in body \u00b6 The same way there is a Query and Path to define extra data for query and path parameters, Ellar provides an equivalent Body . For example, extending the previous model, you could decide that you want to have another key importance in the same body, besides the item and user . If you declare it as is, because it is a singular value, Ellar will assume that it is a query parameter. But you can instruct Ellar to treat it as another body key using Body: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Body , post , put , ControllerBase from pydantic import BaseModel class Item ( Serializer ): name : str description : str = None price : float quantity : int class User ( BaseModel ): username : str full_name : str @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } @put ( \"/ {item_id} /another\" ) async def update_another ( self , item_id : int , item : Item , user : User , importance : int = Body ()): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance } return results In this case, Ellar will expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 }, \"user\" : { \"username\" : \"dave\" , \"full_name\" : \"Dave Grohl\" }, \"importance\" : 5 } Multiple body params and query \u00b6 Of course, you can also declare additional query parameters whenever you need, additional to anybody parameters. As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a Query , you can just do: For example: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Body , post , put , ControllerBase from pydantic import BaseModel class Item ( Serializer ): name : str description : str = None price : float quantity : int class User ( BaseModel ): username : str full_name : str @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } @put ( \"/ {item_id} /another\" ) async def update_another ( self , item_id : int , item : Item , user : User , importance : int = Body (), q : str = None ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance , \"q\" : q } return results And you will have this: Info Body also has all the same extra validation and metadata parameters as Query , Path and others you will see later.","title":"Body"},{"location":"techniques/validations/body/#request-body","text":"Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Ellar Serializer . Info Under the hood Ellar uses Pydantic models with all their power and benefits.","title":"Request Body"},{"location":"techniques/validations/body/#import-serializer","text":"First, you need to import Serializer from ella.serializer : # project_name/apps/items/controllers.py from ellar.common import Serializer # class Item(Serializer): # name: str # description: str = None # price: float # quantity: int","title":"Import Serializer"},{"location":"techniques/validations/body/#create-your-data-model","text":"Then you declare your data model as a class that inherits from Serializer . Use standard Python types for all the attributes: # project_name/apps/items/controllers.py from ellar.common import Serializer , ControllerBase , Controller , post class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Alexis\" , \"description\" : \"An optional description\" , \"price\" : 400.00 , \"quantity\" : 6 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Alexis\" , \"price\" : 200.00 , \"quantity\" : 12 }","title":"Create your data model"},{"location":"techniques/validations/body/#declare-it-as-a-parameter","text":"To add it to your path operation , declare it the same way you declared the path and query parameters: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item ... and declare its type as the model you created, Item .","title":"Declare it as a parameter"},{"location":"techniques/validations/body/#results","text":"With just that Python type declaration, Ellar will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and meaningful error, indicating exactly where and what the incorrect data was. Give you the received data in the parameter item . Because you declared it in the function to be of type Item , you will also have all the editor support (completion, etc.) for all the attributes and their types. Generate JSON Schema definitions for your models, and you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UI's .","title":"Results"},{"location":"techniques/validations/body/#automatic-docs","text":"The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: ... and they will be also used in the API docs inside each path operation that needs them:","title":"Automatic Docs"},{"location":"techniques/validations/body/#request-body-path-parameters","text":"You can declare path parameters and body requests at the same time. Ellar will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Serializer should be taken from the request body . # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , put , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/items/ {item_id} \" ) def update ( self , item_id : int , item : Item ): return { \"item_id\" : item_id , \"item\" : item . dict ()}","title":"Request Body + Path parameters"},{"location":"techniques/validations/body/#request-body-path-query-parameters","text":"You can also declare body , path and query parameters, all at the same time. Ellar will recognize each of them and take the data from the correct place. # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , put , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } The function parameters will be recognized as follows: If the parameter is also declared in the path , it will be used as a path parameter. If the parameter is of a singular type (like int , float , str , bool , etc.), it will be interpreted as a query parameter. If the parameter is declared to be of the type of Serializer (or Pydantic BaseModel ), it will be interpreted as a request body . Info In here, we have combined both Serializers and Controllers in one file. This is for the convenience of writing this documentation. It's advised to have all your serializers in schemas.py and then import them over to controllers.py if needed.","title":"Request Body + Path + Query parameters"},{"location":"techniques/validations/body/#singular-values-in-body","text":"The same way there is a Query and Path to define extra data for query and path parameters, Ellar provides an equivalent Body . For example, extending the previous model, you could decide that you want to have another key importance in the same body, besides the item and user . If you declare it as is, because it is a singular value, Ellar will assume that it is a query parameter. But you can instruct Ellar to treat it as another body key using Body: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Body , post , put , ControllerBase from pydantic import BaseModel class Item ( Serializer ): name : str description : str = None price : float quantity : int class User ( BaseModel ): username : str full_name : str @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } @put ( \"/ {item_id} /another\" ) async def update_another ( self , item_id : int , item : Item , user : User , importance : int = Body ()): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance } return results In this case, Ellar will expect a body like: { \"item\" : { \"name\" : \"Foo\" , \"description\" : \"The pretender\" , \"price\" : 42.0 , \"tax\" : 3.2 }, \"user\" : { \"username\" : \"dave\" , \"full_name\" : \"Dave Grohl\" }, \"importance\" : 5 }","title":"Singular values in body"},{"location":"techniques/validations/body/#multiple-body-params-and-query","text":"Of course, you can also declare additional query parameters whenever you need, additional to anybody parameters. As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a Query , you can just do: For example: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Body , post , put , ControllerBase from pydantic import BaseModel class Item ( Serializer ): name : str description : str = None price : float quantity : int class User ( BaseModel ): username : str full_name : str @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item ): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } @put ( \"/ {item_id} /another\" ) async def update_another ( self , item_id : int , item : Item , user : User , importance : int = Body (), q : str = None ): results = { \"item_id\" : item_id , \"item\" : item , \"user\" : user , \"importance\" : importance , \"q\" : q } return results And you will have this: Info Body also has all the same extra validation and metadata parameters as Query , Path and others you will see later.","title":"Multiple body params and query"},{"location":"techniques/validations/cookie-params/","text":"Cookie Parameters \u00b6 You can define Cookie parameters the same way you define Path parameters. Import Cookie \u00b6 First import Cookie from ellar.common module Declare Cookie parameters \u00b6 Then declare the cookie parameters using the same structure as with Path and Query . The first value is the default value, you can pass all the extra validation or annotation parameters: # project_name/apps/items/controllers.py from typing import Optional from ellar.common import get , Controller , Cookie , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , ads_id : Optional [ str ] = Cookie ( default = None )): return { \"ads_id\" : ads_id } Info To declare cookies, you need to use Cookie , because otherwise the parameters would be interpreted as query parameters. Using Schema \u00b6 You can also use Schema to encapsulate Cookies parameters: # project_name/apps/items/controllers.py from ellar.common import Serializer , get , Controller , Cookie , ControllerBase class CookieSchema ( Serializer ): cookieItem1 : int = 100 cookieItem2 : str = None @Controller class ItemsController ( ControllerBase ): @get ( '/cookie-as-schema' ) def cookie_as_schema ( self , cookie_values : CookieSchema = Cookie ()): return { \"cookie_values\" : cookie_values . dict ()}","title":"Cookie"},{"location":"techniques/validations/cookie-params/#cookie-parameters","text":"You can define Cookie parameters the same way you define Path parameters.","title":"Cookie Parameters"},{"location":"techniques/validations/cookie-params/#import-cookie","text":"First import Cookie from ellar.common module","title":"Import Cookie"},{"location":"techniques/validations/cookie-params/#declare-cookie-parameters","text":"Then declare the cookie parameters using the same structure as with Path and Query . The first value is the default value, you can pass all the extra validation or annotation parameters: # project_name/apps/items/controllers.py from typing import Optional from ellar.common import get , Controller , Cookie , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , ads_id : Optional [ str ] = Cookie ( default = None )): return { \"ads_id\" : ads_id } Info To declare cookies, you need to use Cookie , because otherwise the parameters would be interpreted as query parameters.","title":"Declare Cookie parameters"},{"location":"techniques/validations/cookie-params/#using-schema","text":"You can also use Schema to encapsulate Cookies parameters: # project_name/apps/items/controllers.py from ellar.common import Serializer , get , Controller , Cookie , ControllerBase class CookieSchema ( Serializer ): cookieItem1 : int = 100 cookieItem2 : str = None @Controller class ItemsController ( ControllerBase ): @get ( '/cookie-as-schema' ) def cookie_as_schema ( self , cookie_values : CookieSchema = Cookie ()): return { \"cookie_values\" : cookie_values . dict ()}","title":"Using Schema"},{"location":"techniques/validations/file-params/","text":"File Uploads \u00b6 Handling files are no different from other parameters. You can define files to be uploaded by using File . Info To receive uploaded files, first install python-multipart . E.g. pip install python-multipart . This is because uploaded files are sent as \"form data\". Import File \u00b6 First import File from ellar.common module Define File parameters \u00b6 Create file parameters the same way you would for Body or Form : # project_name/apps/items/controllers.py from ellar.common import File , Controller , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/files/\" ) async def create_file ( self , file : bytes = File ()): return { \"file_size\" : len ( file )} The files will be uploaded as \"form data\". If you declare the type of your path operation function parameter as bytes , Ellar will read the file for you and you will receive the contents as bytes . Have in mind that this means that the whole contents will be stored in memory. This will work well for small files. But there are several cases in which you might benefit from using UploadFile . File parameters with UploadFile \u00b6 Define a File parameter with a type of UploadFile : # project_name/apps/items/controllers.py from ellar.common import File , UploadFile , Controller , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/files/\" ) async def create_file ( self , file : bytes = File ()): return { \"file_size\" : len ( file )} @post ( \"/uploadfile/\" ) async def create_upload_file ( self , file : UploadFile = File ()): return { \"filename\" : file . filename } Using UploadFile has several advantages over bytes : It uses a \"spooled\" file: A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk. This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory. You can get metadata from the uploaded file. It has a file-like async interface. It exposes an actual Python SpooledTemporaryFile object that you can pass directly to other libraries that expect a file-like object. UploadFile \u00b6 UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). write(data) : Writes data ( str or bytes ) to the file. read(size) : Reads size ( int ) bytes/characters of the file. seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. This is especially useful if you run await myfile.read() once and then need to read the contents again. close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, inside an async path operation function you can get the contents with: contents = await myfile . read () If you are inside of a normal def path operation function , you can access the UploadFile.file directly, for example: contents = myfile . file . read () async Technical Details When you use the async methods, Ellar runs the file methods in a threadpool and awaits for them. Starlette Technical Details Ellar 's UploadFile inherits directly from Starlette 's UploadFile , but adds some necessary parts to make it compatible with Pydantic and the other parts of Ellar. Uploading array of files \u00b6 To upload several files at the same time, just declare a List of UploadFile : # project_name/apps/items/controllers.py from typing import List from ellar.common import File , UploadFile , Controller , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/upload-many\" ) def upload_many ( self , files : List [ UploadFile ] = File ()): return [ f . filename for f in files ] Uploading files with extra fields \u00b6 Note: HTTP protocol does not allow you to send files in application/json format by default (unless you encode it somehow to JSON on client side) To send files along with some extra attributes you need to send bodies in multipart/form-data encoding. You can do it by simply marking fields with Form : # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Form , File , UploadFile , post , ControllerBase from datetime import date class UserDetails ( Serializer ): first_name : str last_name : str birthdate : date @Controller class ItemsController ( ControllerBase ): @post ( '/user' ) def create_user ( self , details : UserDetails = Form (), file : UploadFile = File ()): return [ details . dict (), file . filename ] Note: in this case all fields should be sent as form fields You can as well send payload in single field as JSON - just remove the Form mark from: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , File , UploadFile , post , ControllerBase from datetime import date class UserDetails ( Serializer ): first_name : str last_name : str birthdate : date @Controller class ItemsController ( ControllerBase ): @post ( '/user' ) def create_user ( self , details : UserDetails , file : UploadFile = File ()): return [ details . dict (), file . filename ] this will expect from client side to send data as multipart/form-data with 2 fields: details: Json as string file: file","title":"File"},{"location":"techniques/validations/file-params/#file-uploads","text":"Handling files are no different from other parameters. You can define files to be uploaded by using File . Info To receive uploaded files, first install python-multipart . E.g. pip install python-multipart . This is because uploaded files are sent as \"form data\".","title":"File Uploads"},{"location":"techniques/validations/file-params/#import-file","text":"First import File from ellar.common module","title":"Import File"},{"location":"techniques/validations/file-params/#define-file-parameters","text":"Create file parameters the same way you would for Body or Form : # project_name/apps/items/controllers.py from ellar.common import File , Controller , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/files/\" ) async def create_file ( self , file : bytes = File ()): return { \"file_size\" : len ( file )} The files will be uploaded as \"form data\". If you declare the type of your path operation function parameter as bytes , Ellar will read the file for you and you will receive the contents as bytes . Have in mind that this means that the whole contents will be stored in memory. This will work well for small files. But there are several cases in which you might benefit from using UploadFile .","title":"Define File parameters"},{"location":"techniques/validations/file-params/#file-parameters-with-uploadfile","text":"Define a File parameter with a type of UploadFile : # project_name/apps/items/controllers.py from ellar.common import File , UploadFile , Controller , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/files/\" ) async def create_file ( self , file : bytes = File ()): return { \"file_size\" : len ( file )} @post ( \"/uploadfile/\" ) async def create_upload_file ( self , file : UploadFile = File ()): return { \"filename\" : file . filename } Using UploadFile has several advantages over bytes : It uses a \"spooled\" file: A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk. This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory. You can get metadata from the uploaded file. It has a file-like async interface. It exposes an actual Python SpooledTemporaryFile object that you can pass directly to other libraries that expect a file-like object.","title":"File parameters with UploadFile"},{"location":"techniques/validations/file-params/#uploadfile","text":"UploadFile has the following attributes: filename : A str with the original file name that was uploaded (e.g. myimage.jpg ). content_type : A str with the content type (MIME type / media type) (e.g. image/jpeg ). file : A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile ). write(data) : Writes data ( str or bytes ) to the file. read(size) : Reads size ( int ) bytes/characters of the file. seek(offset) : Goes to the byte position offset ( int ) in the file. E.g., await myfile.seek(0) would go to the start of the file. This is especially useful if you run await myfile.read() once and then need to read the contents again. close() : Closes the file. As all these methods are async methods, you need to \"await\" them. For example, inside an async path operation function you can get the contents with: contents = await myfile . read () If you are inside of a normal def path operation function , you can access the UploadFile.file directly, for example: contents = myfile . file . read () async Technical Details When you use the async methods, Ellar runs the file methods in a threadpool and awaits for them. Starlette Technical Details Ellar 's UploadFile inherits directly from Starlette 's UploadFile , but adds some necessary parts to make it compatible with Pydantic and the other parts of Ellar.","title":"UploadFile"},{"location":"techniques/validations/file-params/#uploading-array-of-files","text":"To upload several files at the same time, just declare a List of UploadFile : # project_name/apps/items/controllers.py from typing import List from ellar.common import File , UploadFile , Controller , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/upload-many\" ) def upload_many ( self , files : List [ UploadFile ] = File ()): return [ f . filename for f in files ]","title":"Uploading array of files"},{"location":"techniques/validations/file-params/#uploading-files-with-extra-fields","text":"Note: HTTP protocol does not allow you to send files in application/json format by default (unless you encode it somehow to JSON on client side) To send files along with some extra attributes you need to send bodies in multipart/form-data encoding. You can do it by simply marking fields with Form : # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Form , File , UploadFile , post , ControllerBase from datetime import date class UserDetails ( Serializer ): first_name : str last_name : str birthdate : date @Controller class ItemsController ( ControllerBase ): @post ( '/user' ) def create_user ( self , details : UserDetails = Form (), file : UploadFile = File ()): return [ details . dict (), file . filename ] Note: in this case all fields should be sent as form fields You can as well send payload in single field as JSON - just remove the Form mark from: # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , File , UploadFile , post , ControllerBase from datetime import date class UserDetails ( Serializer ): first_name : str last_name : str birthdate : date @Controller class ItemsController ( ControllerBase ): @post ( '/user' ) def create_user ( self , details : UserDetails , file : UploadFile = File ()): return [ details . dict (), file . filename ] this will expect from client side to send data as multipart/form-data with 2 fields: details: Json as string file: file","title":"Uploading files with extra fields"},{"location":"techniques/validations/form-params/","text":"Form Data \u00b6 Ellar also allows you to parse and validate request.POST data (aka application x-www-form-urlencoded or multipart/form-data ). When you need to receive form fields instead of JSON, you can use Form . Info To use forms, first install python-multipart . E.g. pip install python-multipart . Form Data as params \u00b6 # project_name/apps/items/controllers.py from ellar.common import Controller , Form , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/login\" ) def login ( self , username : str = Form (), password : str = Form ()): return { 'username' : username , 'password' : '*****' } Note the following: 1) You need to import the Form class from ninja from ellar.common import Form 2) Use Form as default value for your parameter: from ellar.common import Form username : str = Form () Using a Schema \u00b6 In a similar manner to Body , you can use a Schema to organize your parameters. # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , Form , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item = Form ()): return item Request form + path + query parameters \u00b6 In a similar manner to Body , you can use Form data in combination with other parameter sources. You can declare query and path and form field, and etc... parameters at the same time. Ellar will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Form(...) should be taken from the request form fields , etc. # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Form , post , put , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item = Form ()): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , q : str , item : Item = Form ()): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } Mapping Empty Form Field to Default \u00b6 Form fields that are optional, are often sent with an empty value. This value is interpreted as an empty string, and thus may fail validation for fields such as int or bool . This can be fixed, as described in the Pydantic docs, by using Generic Classes as Types . # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Form , post , put , ControllerBase from pydantic.fields import ModelField from typing import Generic , TypeVar PydanticField = TypeVar ( \"PydanticField\" ) class EmptyStrToDefault ( Generic [ PydanticField ]): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , value : PydanticField , field : ModelField ) -> PydanticField : if value == \"\" : return field . default return value class Item ( Serializer ): name : str description : str = None price : EmptyStrToDefault [ float ] = 0.0 quantity : EmptyStrToDefault [ int ] = 0 in_stock : EmptyStrToDefault [ bool ] = True @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item = Form ()): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , q : str , item : Item = Form ()): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } @put ( \"/items-blank-default\" ) def update ( self , item : Item = Form ()): return item . dict ()","title":"Form"},{"location":"techniques/validations/form-params/#form-data","text":"Ellar also allows you to parse and validate request.POST data (aka application x-www-form-urlencoded or multipart/form-data ). When you need to receive form fields instead of JSON, you can use Form . Info To use forms, first install python-multipart . E.g. pip install python-multipart .","title":"Form Data"},{"location":"techniques/validations/form-params/#form-data-as-params","text":"# project_name/apps/items/controllers.py from ellar.common import Controller , Form , post , ControllerBase @Controller class ItemsController ( ControllerBase ): @post ( \"/login\" ) def login ( self , username : str = Form (), password : str = Form ()): return { 'username' : username , 'password' : '*****' } Note the following: 1) You need to import the Form class from ninja from ellar.common import Form 2) Use Form as default value for your parameter: from ellar.common import Form username : str = Form ()","title":"Form Data as params"},{"location":"techniques/validations/form-params/#using-a-schema","text":"In a similar manner to Body , you can use a Schema to organize your parameters. # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , post , Form , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item = Form ()): return item","title":"Using a Schema"},{"location":"techniques/validations/form-params/#request-form-path-query-parameters","text":"In a similar manner to Body , you can use Form data in combination with other parameter sources. You can declare query and path and form field, and etc... parameters at the same time. Ellar will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Form(...) should be taken from the request form fields , etc. # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Form , post , put , ControllerBase class Item ( Serializer ): name : str description : str = None price : float quantity : int @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item = Form ()): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , q : str , item : Item = Form ()): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q }","title":"Request form + path + query parameters"},{"location":"techniques/validations/form-params/#mapping-empty-form-field-to-default","text":"Form fields that are optional, are often sent with an empty value. This value is interpreted as an empty string, and thus may fail validation for fields such as int or bool . This can be fixed, as described in the Pydantic docs, by using Generic Classes as Types . # project_name/apps/items/controllers.py from ellar.common import Serializer , Controller , Form , post , put , ControllerBase from pydantic.fields import ModelField from typing import Generic , TypeVar PydanticField = TypeVar ( \"PydanticField\" ) class EmptyStrToDefault ( Generic [ PydanticField ]): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , value : PydanticField , field : ModelField ) -> PydanticField : if value == \"\" : return field . default return value class Item ( Serializer ): name : str description : str = None price : EmptyStrToDefault [ float ] = 0.0 quantity : EmptyStrToDefault [ int ] = 0 in_stock : EmptyStrToDefault [ bool ] = True @Controller class ItemsController ( ControllerBase ): @post ( \"/\" ) def create ( self , item : Item = Form ()): return item @put ( \"/ {item_id} \" ) def update ( self , item_id : int , q : str , item : Item = Form ()): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } @put ( \"/items-blank-default\" ) def update ( self , item : Item = Form ()): return item . dict ()","title":"Mapping Empty Form Field to Default"},{"location":"techniques/validations/header-params/","text":"Header Parameters \u00b6 You can define Header parameters the same way you define Query , Path and Cookie parameters. To query this operation, you use a URL like: Import Header \u00b6 First import Header from ellar.common module Declare Header parameters \u00b6 Then declare the header parameters using the same structure as with Path , Query and Cookie . The first value is the default value, you can pass all the extra validation or annotation parameters: # project_name/apps/items/controllers.py from ellar.common import Controller , get , Header , ControllerBase from typing import Optional @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , user_agent : Optional [ str ] = Header ( default = None )): return { \"User-Agent\" : user_agent } Info To declare headers, you need to use Header , because otherwise the parameters would be interpreted as query parameters. Automatic conversion \u00b6 Header has a little extra functionality. Most of the standard headers are separated by a \"hyphen\" character, also known as the \"minus symbol\" ( - ). But a variable like user-agent is not valid in Python. By default, Header will convert the parameter names characters from underscore ( _ ) to hyphen ( - ) to extract and document the headers. Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as \"snake_case\"). So, you can use user_agent as you normally would in Python code, instead of needing to capitalize the first letters as User_Agent or something similar. If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter convert_underscores of Header to False : # project_name/apps/items/controllers.py from ellar.common import Controller , get , Header , ControllerBase from typing import Optional @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , strange_header : Optional [ str ] = Header ( default = None , convert_underscores = False ) ): return { \"strange_header\" : strange_header } Warning Before setting convert_underscores to False , bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores. Duplicate headers \u00b6 It is possible to receive duplicate headers. That means, the same header with multiple values. You can define those cases using a list in the type declaration. You will receive all the values from the duplicate header as a Python list . For example, to declare a header of X-Token that can appear more than once, you can write: # project_name/apps/items/controllers.py from ellar.common import Controller , get , Header , ControllerBase from typing import Optional , List @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , x_token : Optional [ List [ str ]] = Header ( default = None )): return { \"X-Token values\" : x_token } If you communicate with that path operation sending two HTTP headers like: X-Token: foo X-Token: bar The response would be like: { \"X-Token values\" : [ \"bar\" , \"foo\" ] } Using Schema \u00b6 You can also use Schema to encapsulate Header parameters: # project_name/apps/items/controllers.py from typing import List from ellar.common import Serializer , get , Controller , Header , ControllerBase class HeaderSchema ( Serializer ): version : int = 1 x_token : List [ str ] = None # similar to x_token: Optional[List[str]] @Controller class ItemsController ( ControllerBase ): @get ( '/header-as-schema' ) def header_as_schema ( self , headers : HeaderSchema = Header ()): return { \"headers\" : headers . dict ()}","title":"Header"},{"location":"techniques/validations/header-params/#header-parameters","text":"You can define Header parameters the same way you define Query , Path and Cookie parameters. To query this operation, you use a URL like:","title":"Header Parameters"},{"location":"techniques/validations/header-params/#import-header","text":"First import Header from ellar.common module","title":"Import Header"},{"location":"techniques/validations/header-params/#declare-header-parameters","text":"Then declare the header parameters using the same structure as with Path , Query and Cookie . The first value is the default value, you can pass all the extra validation or annotation parameters: # project_name/apps/items/controllers.py from ellar.common import Controller , get , Header , ControllerBase from typing import Optional @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , user_agent : Optional [ str ] = Header ( default = None )): return { \"User-Agent\" : user_agent } Info To declare headers, you need to use Header , because otherwise the parameters would be interpreted as query parameters.","title":"Declare Header parameters"},{"location":"techniques/validations/header-params/#automatic-conversion","text":"Header has a little extra functionality. Most of the standard headers are separated by a \"hyphen\" character, also known as the \"minus symbol\" ( - ). But a variable like user-agent is not valid in Python. By default, Header will convert the parameter names characters from underscore ( _ ) to hyphen ( - ) to extract and document the headers. Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as \"snake_case\"). So, you can use user_agent as you normally would in Python code, instead of needing to capitalize the first letters as User_Agent or something similar. If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter convert_underscores of Header to False : # project_name/apps/items/controllers.py from ellar.common import Controller , get , Header , ControllerBase from typing import Optional @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , strange_header : Optional [ str ] = Header ( default = None , convert_underscores = False ) ): return { \"strange_header\" : strange_header } Warning Before setting convert_underscores to False , bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.","title":"Automatic conversion"},{"location":"techniques/validations/header-params/#duplicate-headers","text":"It is possible to receive duplicate headers. That means, the same header with multiple values. You can define those cases using a list in the type declaration. You will receive all the values from the duplicate header as a Python list . For example, to declare a header of X-Token that can appear more than once, you can write: # project_name/apps/items/controllers.py from ellar.common import Controller , get , Header , ControllerBase from typing import Optional , List @Controller class ItemsController ( ControllerBase ): @get ( \"/\" ) async def read_items ( self , x_token : Optional [ List [ str ]] = Header ( default = None )): return { \"X-Token values\" : x_token } If you communicate with that path operation sending two HTTP headers like: X-Token: foo X-Token: bar The response would be like: { \"X-Token values\" : [ \"bar\" , \"foo\" ] }","title":"Duplicate headers"},{"location":"techniques/validations/header-params/#using-schema","text":"You can also use Schema to encapsulate Header parameters: # project_name/apps/items/controllers.py from typing import List from ellar.common import Serializer , get , Controller , Header , ControllerBase class HeaderSchema ( Serializer ): version : int = 1 x_token : List [ str ] = None # similar to x_token: Optional[List[str]] @Controller class ItemsController ( ControllerBase ): @get ( '/header-as-schema' ) def header_as_schema ( self , headers : HeaderSchema = Header ()): return { \"headers\" : headers . dict ()}","title":"Using Schema"},{"location":"techniques/validations/path-params/","text":"Path Parameters \u00b6 You can declare path \"parameters\" with the same syntax used by Python format-strings which is similar to OpenAPI path parameters # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/ {item_id} \" ) def read_item ( self , item_id ): return { \"item_id\" : item_id } The value of the path parameter item_id will be passed to your function as the argument item_id . So, if you run this example and go to http://localhost:8000/items/foo , you will see this response: { \"item_id\" : \"foo\" } Path parameters with types \u00b6 You can declare the type of path parameter in the function using standard Python type annotations: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/items/ {item_id} \" ) def read_item ( self , item_id : int ): return { \"item_id\" : item_id } In this case, item_id is declared to be an int . This will give you editor and linter support for error checks, completion, etc. If you run this in your browser with http://localhost:8000/api/items/3 , you will see this response: { \"item_id\" : 3 } Tip Notice that the value your function received (and returned) is 3 , as a Python int - not a string \"3\" . So, with just that type declaration, Ellar gives you automatic request \"parsing\" and validation. Data validation \u00b6 On the other hand, if you go to the browser at http://localhost:8000/items/foo , you will see an HTTP error like this: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } that is because the path parameter item_id had a value of \"foo\" , which is not an int . The same error would appear if you provided a float instead of an int , as in: http://localhost:8000/items/4.2 Path Converters \u00b6 You can use Starlette Path Converters to help parse the path: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/{item_id:int}\" ) def read_item ( self , item_id ): return { \"item_id\" : item_id } In this case, item_id will be parsed as an int . If item_id is not a valid int , the url will not match. (e.g. if no other path matches, a 404 Not Found will be returned) Tip Notice that, since Ellar uses a default type of str for unannotated parameters, the value the function above received (and returned) is \"3\" , as a Python str - not an integer 3 . To receive an int , simply declare item_id as an int type annotation in the function definition as normal: ... @get ( \"/items/{int:item_id}\" ) def read_item ( self , item_id : int ): return { \"item_id\" : item_id } Path params with slashes \u00b6 Starlette path converter allows you to handle path-like parameters: For example, lets another route handler some_view and give it a path /dir/{value:path} . What this means is that the parameter is value , and the last part, :path , tells it that the parameter should match any path. # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( '/dir/{value:path}' ) def some_view ( self , value : str ): return value You can query this operation with http://localhost:8000/items/dir/some/path/with-slashes and your value will be equal to \"some/path/with-slashes\" Multiple parameters \u00b6 You can pass as many variables as you want into path , just remember to have unique names and don't forget to use the same names in the function arguments. # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/events/ {year} / {month} / {day} \" ) def events ( self , year : int , month : int , day : int ): return { \"date\" : [ year , month , day ]} Using Schema \u00b6 You can also use Schema to encapsulate path parameters that depend on each other (and validate them as a group): # project_name/apps/items/controllers.py import datetime from ellar.common import Serializer , get , Controller , Path , ControllerBase class PathDate ( Serializer ): year : int month : int day : int def value ( self ): return datetime . date ( self . year , self . month , self . day ) @Controller class ItemsController ( ControllerBase ): @get ( \"/events/ {year} / {month} / {day} \" ) def events ( self , date : PathDate = Path ()): return { \"date\" : date . value ()} Note Notice that here we used a Path source hint to let Ellar know that this schema will be applied to path parameters. Documentation \u00b6 Now, when you open your browser at http://localhost:8000/docs , you will see the automatic, interactive, API documentation. Using Enum \u00b6 If you have a path operation that receives a path parameter, but you want the possible valid path parameter values to be predefined, you can use a standard Python Enum . For an example: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase from enum import Enum class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" @Controller class ItemsController ( ControllerBase ): @get ( \"/models/ {model_name} \" ) async def get_model ( self , model_name : ModelName ): if model_name is ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" } Check the docs \u00b6 Because the available values for the path parameter are predefined, the interactive docs can show them nicely:","title":"Path"},{"location":"techniques/validations/path-params/#path-parameters","text":"You can declare path \"parameters\" with the same syntax used by Python format-strings which is similar to OpenAPI path parameters # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/ {item_id} \" ) def read_item ( self , item_id ): return { \"item_id\" : item_id } The value of the path parameter item_id will be passed to your function as the argument item_id . So, if you run this example and go to http://localhost:8000/items/foo , you will see this response: { \"item_id\" : \"foo\" }","title":"Path Parameters"},{"location":"techniques/validations/path-params/#path-parameters-with-types","text":"You can declare the type of path parameter in the function using standard Python type annotations: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/items/ {item_id} \" ) def read_item ( self , item_id : int ): return { \"item_id\" : item_id } In this case, item_id is declared to be an int . This will give you editor and linter support for error checks, completion, etc. If you run this in your browser with http://localhost:8000/api/items/3 , you will see this response: { \"item_id\" : 3 } Tip Notice that the value your function received (and returned) is 3 , as a Python int - not a string \"3\" . So, with just that type declaration, Ellar gives you automatic request \"parsing\" and validation.","title":"Path parameters with types"},{"location":"techniques/validations/path-params/#data-validation","text":"On the other hand, if you go to the browser at http://localhost:8000/items/foo , you will see an HTTP error like this: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } that is because the path parameter item_id had a value of \"foo\" , which is not an int . The same error would appear if you provided a float instead of an int , as in: http://localhost:8000/items/4.2","title":"Data validation"},{"location":"techniques/validations/path-params/#path-converters","text":"You can use Starlette Path Converters to help parse the path: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/{item_id:int}\" ) def read_item ( self , item_id ): return { \"item_id\" : item_id } In this case, item_id will be parsed as an int . If item_id is not a valid int , the url will not match. (e.g. if no other path matches, a 404 Not Found will be returned) Tip Notice that, since Ellar uses a default type of str for unannotated parameters, the value the function above received (and returned) is \"3\" , as a Python str - not an integer 3 . To receive an int , simply declare item_id as an int type annotation in the function definition as normal: ... @get ( \"/items/{int:item_id}\" ) def read_item ( self , item_id : int ): return { \"item_id\" : item_id }","title":"Path Converters"},{"location":"techniques/validations/path-params/#path-params-with-slashes","text":"Starlette path converter allows you to handle path-like parameters: For example, lets another route handler some_view and give it a path /dir/{value:path} . What this means is that the parameter is value , and the last part, :path , tells it that the parameter should match any path. # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( '/dir/{value:path}' ) def some_view ( self , value : str ): return value You can query this operation with http://localhost:8000/items/dir/some/path/with-slashes and your value will be equal to \"some/path/with-slashes\"","title":"Path params with slashes"},{"location":"techniques/validations/path-params/#multiple-parameters","text":"You can pass as many variables as you want into path , just remember to have unique names and don't forget to use the same names in the function arguments. # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase @Controller class ItemsController ( ControllerBase ): @get ( \"/events/ {year} / {month} / {day} \" ) def events ( self , year : int , month : int , day : int ): return { \"date\" : [ year , month , day ]}","title":"Multiple parameters"},{"location":"techniques/validations/path-params/#using-schema","text":"You can also use Schema to encapsulate path parameters that depend on each other (and validate them as a group): # project_name/apps/items/controllers.py import datetime from ellar.common import Serializer , get , Controller , Path , ControllerBase class PathDate ( Serializer ): year : int month : int day : int def value ( self ): return datetime . date ( self . year , self . month , self . day ) @Controller class ItemsController ( ControllerBase ): @get ( \"/events/ {year} / {month} / {day} \" ) def events ( self , date : PathDate = Path ()): return { \"date\" : date . value ()} Note Notice that here we used a Path source hint to let Ellar know that this schema will be applied to path parameters.","title":"Using Schema"},{"location":"techniques/validations/path-params/#documentation","text":"Now, when you open your browser at http://localhost:8000/docs , you will see the automatic, interactive, API documentation.","title":"Documentation"},{"location":"techniques/validations/path-params/#using-enum","text":"If you have a path operation that receives a path parameter, but you want the possible valid path parameter values to be predefined, you can use a standard Python Enum . For an example: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase from enum import Enum class ModelName ( str , Enum ): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" @Controller class ItemsController ( ControllerBase ): @get ( \"/models/ {model_name} \" ) async def get_model ( self , model_name : ModelName ): if model_name is ModelName . alexnet : return { \"model_name\" : model_name , \"message\" : \"Deep Learning FTW!\" } if model_name . value == \"lenet\" : return { \"model_name\" : model_name , \"message\" : \"LeCNN all the images\" } return { \"model_name\" : model_name , \"message\" : \"Have some residuals\" }","title":"Using Enum"},{"location":"techniques/validations/path-params/#check-the-docs","text":"Because the available values for the path parameter are predefined, the interactive docs can show them nicely:","title":"Check the docs"},{"location":"techniques/validations/query-params/","text":"Query Parameters \u00b6 When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters. # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] @Controller class ItemsController ( ControllerBase ): @get ( '/weapons' ) def list_weapons ( self , limit : int = 10 , offset : int = 0 ): return fake_items_db [ offset : offset + limit ] To query this operation, you use a URL like: http://localhost:8000/api/weapons?offset=0&limit=10 By default, all GET parameters are strings, and when you annotate your function arguments with types, they are converted to that type and validated against it. The same benefits that apply to path parameters also apply to query parameters: Editor support (obviously) Data \"parsing\" Data validation Automatic documentation Note: if you do not annotate your arguments, they will be treated as str types: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] @Controller class ItemsController ( ControllerBase ): @get ( '/weapons' ) def list_weapons ( self , limit , offset ): assert type ( limit ) == str assert type ( offset ) == str return fake_items_db [ offset : int ( offset ) + int ( limit )] Defaults \u00b6 As query parameters are not a fixed part of a path, they are optional and can have default values: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] @Controller class ItemsController ( ControllerBase ): @get ( '/weapons' ) def list_weapons ( self , limit : int = 10 , offset : int = 0 ): return fake_items_db [ offset : offset + limit ] In the example above we set default values of offset=0 and limit=10 . So, going to the URL: http://localhost:8000/items/weapons would be the same as going to: http://localhost:8000/items/weapons?offset=0&limit=10 If you go to, for example: http://localhost:8000/items/weapons?offset=20 the parameter values in your function will be: offset=20 (because you set it in the URL) limit=10 (because that was the default value) Required and optional parameters \u00b6 You can declare required or optional GET parameters in the same way as declaring Python function arguments: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @Controller class ItemsController ( ControllerBase ): @get ( \"/weapons/search\" ) def search_weapons ( self , q : str , offset : int = 0 ): results = [ w for w in weapons if q in w . lower ()] print ( q , results ) return results [ offset : offset + 10 ] In this case, Ellar will always validate that you pass the q param in the GET, and the offset param is an optional integer. GET parameters type conversion \u00b6 Let's declare multiple type arguments: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase from datetime import date @Controller class ItemsController ( ControllerBase ): @get ( \"/example\" ) def example ( self , s : str = None , b : bool = None , d : date = None , i : int = None ): return [ s , b , d , i ] The str type is passed as is. For the bool type, all the following: http://localhost:8000/items/example?b=1 http://localhost:8000/items/example?b=True http://localhost:8000/items/example?b=true http://localhost:8000/items/example?b=on http://localhost:8000/items/example?b=yes or any other case variation (uppercase, first letter in uppercase, etc.), your function will see the parameter b with a bool value of True , otherwise as False . Date can be both date string and integer (unix timestamp): http://localhost:8000/items/example?d=1672286800 # same as 2022-12-29 http://localhost:8000/items/example?d=2022-12-29 Using Schema \u00b6 You can also use Schema to encapsulate GET parameters: # project_name/apps/items/controllers.py from typing import List from pydantic import Field from ellar.common import Serializer , get , Controller , Query , ControllerBase class Filters ( Serializer ): limit : int = 100 offset : int = None query : str = None category__in : List [ str ] = Field ( None , alias = \"categories\" ) @Controller class ItemsController ( ControllerBase ): @get ( '/query-as-schema' ) def query_as_schema ( self , filters : Filters = Query ()): return { \"filters\" : filters . dict ()}","title":"Query"},{"location":"techniques/validations/query-params/#query-parameters","text":"When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters. # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] @Controller class ItemsController ( ControllerBase ): @get ( '/weapons' ) def list_weapons ( self , limit : int = 10 , offset : int = 0 ): return fake_items_db [ offset : offset + limit ] To query this operation, you use a URL like: http://localhost:8000/api/weapons?offset=0&limit=10 By default, all GET parameters are strings, and when you annotate your function arguments with types, they are converted to that type and validated against it. The same benefits that apply to path parameters also apply to query parameters: Editor support (obviously) Data \"parsing\" Data validation Automatic documentation Note: if you do not annotate your arguments, they will be treated as str types: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] @Controller class ItemsController ( ControllerBase ): @get ( '/weapons' ) def list_weapons ( self , limit , offset ): assert type ( limit ) == str assert type ( offset ) == str return fake_items_db [ offset : int ( offset ) + int ( limit )]","title":"Query Parameters"},{"location":"techniques/validations/query-params/#defaults","text":"As query parameters are not a fixed part of a path, they are optional and can have default values: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase fake_items_db = [{ \"item_name\" : \"Foo\" }, { \"item_name\" : \"Bar\" }, { \"item_name\" : \"Baz\" }] @Controller class ItemsController ( ControllerBase ): @get ( '/weapons' ) def list_weapons ( self , limit : int = 10 , offset : int = 0 ): return fake_items_db [ offset : offset + limit ] In the example above we set default values of offset=0 and limit=10 . So, going to the URL: http://localhost:8000/items/weapons would be the same as going to: http://localhost:8000/items/weapons?offset=0&limit=10 If you go to, for example: http://localhost:8000/items/weapons?offset=20 the parameter values in your function will be: offset=20 (because you set it in the URL) limit=10 (because that was the default value)","title":"Defaults"},{"location":"techniques/validations/query-params/#required-and-optional-parameters","text":"You can declare required or optional GET parameters in the same way as declaring Python function arguments: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @Controller class ItemsController ( ControllerBase ): @get ( \"/weapons/search\" ) def search_weapons ( self , q : str , offset : int = 0 ): results = [ w for w in weapons if q in w . lower ()] print ( q , results ) return results [ offset : offset + 10 ] In this case, Ellar will always validate that you pass the q param in the GET, and the offset param is an optional integer.","title":"Required and optional parameters"},{"location":"techniques/validations/query-params/#get-parameters-type-conversion","text":"Let's declare multiple type arguments: # project_name/apps/items/controllers.py from ellar.common import get , Controller , ControllerBase from datetime import date @Controller class ItemsController ( ControllerBase ): @get ( \"/example\" ) def example ( self , s : str = None , b : bool = None , d : date = None , i : int = None ): return [ s , b , d , i ] The str type is passed as is. For the bool type, all the following: http://localhost:8000/items/example?b=1 http://localhost:8000/items/example?b=True http://localhost:8000/items/example?b=true http://localhost:8000/items/example?b=on http://localhost:8000/items/example?b=yes or any other case variation (uppercase, first letter in uppercase, etc.), your function will see the parameter b with a bool value of True , otherwise as False . Date can be both date string and integer (unix timestamp): http://localhost:8000/items/example?d=1672286800 # same as 2022-12-29 http://localhost:8000/items/example?d=2022-12-29","title":"GET parameters type conversion"},{"location":"techniques/validations/query-params/#using-schema","text":"You can also use Schema to encapsulate GET parameters: # project_name/apps/items/controllers.py from typing import List from pydantic import Field from ellar.common import Serializer , get , Controller , Query , ControllerBase class Filters ( Serializer ): limit : int = 100 offset : int = None query : str = None category__in : List [ str ] = Field ( None , alias = \"categories\" ) @Controller class ItemsController ( ControllerBase ): @get ( '/query-as-schema' ) def query_as_schema ( self , filters : Filters = Query ()): return { \"filters\" : filters . dict ()}","title":"Using Schema"},{"location":"websockets/socketio/","text":"Socket IO - python-socketio \u00b6 Ellar integration with python-socketio , a library that enables real-time, bidirectional and event-based communication between the browser and the server. Gateways \u00b6 A class annotated with WebSocketGateway decorator is like a controller that creates a compatibles with python-socketio, ellar and websocket. A gateway class also supports dependency injection and guards. from ellar.socket_io import WebSocketGateway @WebSocketGateway ( path = '/events-ws' , name = 'event-gateway' ) class EventGateway : pass Installation \u00b6 To start building Socket.IO webSockets-based applications, first install the required package: $( venv ) pip install python-socketio Overview \u00b6 In general, each gateway is listening on the same port as the HTTP server and has a path /socket.io unless changed manually. This default behavior can be modified by passing an argument to the @WebSocketGateway(path='/event-ws') . You can also set a namespace used by the gateway as shown below: # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway @WebSocketGateway ( path = '/socket.io' , namespace = 'events' ) class EventGateway : pass Warning Gateways are not instantiated until they are referenced in the controllers array of an existing module. You can pass any supported option to the socket constructor with the second argument to the @WebSocketGateway() decorator, as shown below: # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway , GatewayBase @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): pass The gateway is now listening, but we have not yet subscribed to any incoming messages. Let's create a handler that will subscribe to the events messages and respond to the user with the exact same data. # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway , subscribe_message , GatewayBase from ellar.common import WsBody @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : str = WsBody ()): return data You can also define schema for the data receive, for example: # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway , subscribe_message , GatewayBase from ellar.common import WsBody from pydantic import BaseModel class MessageBody ( BaseModel ): data : str @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return data . dict () Once the gateway is created, we can register it in our module. # project_name/events/module.py from ellar.common import Module from .gateway import EventGateway @Module ( controllers = [ EventGateway ]) class EventsModule : pass WebSocketGateway decorated class comes with a different context that providers extra information/access to server , sid and current message environment . from ellar.socket_io import GatewayBase from socketio import AsyncServer @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): assert isinstance ( self . context . server , AsyncServer ) assert isinstance ( self . context . sid , str ) assert isinstance ( self . context . environment , dict ) await self . context . server . emit ( 'my_custom_event' , data . dict (), room = None ) WsResponse \u00b6 You may return a WsResponse object and supply two properties. The event which is a name of the emitted event and the data that has to be forwarded to the client. from ellar.socket_io import GatewayBase from ellar.socket_io import WsResponse @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return WsResponse ( 'events' , data . dict ()) Hint The WsResponse class is imported from ellar.socketio package. And its has similar interface as AsyncServer().emit Warning If you return a response that is not a WsResponse object, ellar will assume handler as the event to emit the response. Or you can use self.context.server.emit to send the message back to the client. In order to listen for the incoming response(s), the client has to apply another event listener. socket . on ( 'events' , ( data ) => console . log ( data )); Gateway Connection and Disconnection Handling \u00b6 on_connected and on_disconnected can be used to define on_connect and on_disconnect handler in your gateway controller. For example, from ellar.socket_io import GatewayBase , WebSocketGateway , subscribe_message , on_connected , on_disconnected from ellar.socket_io import WsResponse @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @on_connected () async def connect ( self ): await self . context . server . emit ( \"my_response\" , { \"data\" : \"Connected\" , \"count\" : 0 }, room = self . context . sid ) @on_disconnected () async def disconnect ( self ): print ( \"Client disconnected\" ) @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return WsResponse ( 'events' , data . dict ()) Info @on_connected and @on_disconnected() handlers doesn't take any argument because all its arguments are already available in the self.context Exceptions \u00b6 All exceptions that happens on the server in a gateway controller after successful handshake between the server and client are sent to the client through error event. This is a standard practice when working socketio client. The client is required to subscribe to error event inorder to receive error message from the server. for example: from ellar.socket_io import GatewayBase , WebSocketGateway , subscribe_message from ellar.common.exceptions import WebSocketException from starlette import status @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): raise WebSocketException ( status . WS_1009_MESSAGE_TOO_BIG , reason = 'Message is too big' ) When client sends message to events , an exception will be raised. And the client will receive the error message if it subscribed to error events. For example: const socket = io . connect () socket . on ( 'error' , ( error ) => { console . error ( error ) }) Guards \u00b6 There is no fundamental difference between web sockets guards and regular HTTP application guards. The only difference is that instead of throwing HttpException , you should use WebSocketException Hint WebSocketException is an exception class located in ellar.common.exceptions from ellar.common import Guards ... @Guards ( MyCustomGuards ) @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return WsResponse ( 'events' , data . dict ()) ... @Guards can be applied at handler level as shown in the last construct or at class level as shown below: ... @Guards ( MyGuard ) @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @on_connected () async def connect ( self ): await self . context . server . emit ( \"my_response\" , { \"data\" : \"Connected\" , \"count\" : 0 }, room = self . context . sid ) ... Testing \u00b6 Gateway can be unit tested just like regular ellar controllers. But for integration testing, a separate testing module, TestGateway , is needed to set up a socketio client to simulation activity between server and client. Hint TestGateway class is located at ellar.socket_io.testing For example: @WebSocketGateway ( path = \"/ws\" , async_mode = \"asgi\" , cors_allowed_origins = \"*\" ) class EventGateway : @subscribe_message ( \"my_event\" ) async def my_event ( self , message : MessageData = WsBody ()): return WsResponse ( \"my_response\" , { \"data\" : message . data }, room = self . context . sid ) @subscribe_message async def my_broadcast_event ( self , message : MessageData = WsBody ()): await self . context . server . emit ( \"my_response\" , { \"data\" : message . data }) @on_connected () async def connect ( self ): await self . context . server . emit ( \"my_response\" , { \"data\" : \"Connected\" , \"count\" : 0 }, room = self . context . sid ) @on_disconnected () async def disconnect ( self ): print ( \"Client disconnected\" ) The above gateway construct integration testing can be done as shown below: import pytest from ellar.socket_io.testing import TestGateway @pytest . mark . asyncio class TestEventGateway : test_client = TestGateway . create_test_module ( controllers = [ EventGateway ]) async def test_socket_connection_work ( self ): my_response_message = [] connected_called = False disconnected_called = False async with self . test_client . run_with_server () as ctx : @ctx . sio . event async def my_response ( message ): my_response_message . append ( message ) @ctx . sio . event async def disconnect (): nonlocal disconnected_called disconnected_called = True @ctx . sio . event async def connect ( * args ): nonlocal connected_called await ctx . sio . emit ( \"my_event\" , { \"data\" : \"I'm connected!\" }) connected_called = True await ctx . connect ( socketio_path = \"/ws/\" ) await ctx . wait () assert len ( my_response_message ) == 2 assert my_response_message == [ { \"data\" : \"Connected\" , \"count\" : 0 }, { \"data\" : \"I'm connected!\" }, ] assert disconnected_called and connected_called async def test_broadcast_work ( self ): sio_1_response_message = [] sio_2_response_message = [] async with self . test_client . run_with_server () as ctx : ctx_2 = ctx . new_socket_client_context () @ctx . sio . event async def my_response ( message ): sio_1_response_message . append ( message ) @ctx_2 . sio . event async def my_response ( message ): sio_2_response_message . append ( message ) await ctx . connect ( socketio_path = \"/ws/\" ) await ctx_2 . connect ( socketio_path = \"/ws/\" ) await ctx . sio . emit ( \"my_broadcast_event\" , { \"data\" : \"Testing Broadcast\" } ) # both sio_1 and sio_2 would receive this message await ctx . wait () await ctx_2 . wait () assert len ( sio_1_response_message ) == 2 assert sio_1_response_message == [ { \"data\" : \"Connected\" , \"count\" : 0 }, { \"data\" : \"Testing Broadcast\" }, ] assert len ( sio_2_response_message ) == 2 assert sio_2_response_message == [ { \"data\" : \"Connected\" , \"count\" : 0 }, { \"data\" : \"Testing Broadcast\" }, ] self.test_client.run_with_server() setup a server and returns RunWithServerContext object. The RunWithServerContext contains a socket io client and created server url. And with the client( sio ) returned, you can subscribe to events and send messages as shown in the above construct. Warning It is important to have all the event subscription written before calling ctx.connect Also, it is possible to test with more than one client as you can see in test_broadcast_work in construct above. We created another instance of RunWithServerContext as ctx_2 from the already existing ctx with ctx.new_socket_client_context() . And both were used to test for message broadcast. SocketIO Ellar Example \u00b6 python-socketio provided a sample project on how to integrate python-socketio with django . The sample project was converted to ellar gateway and it can find it here","title":"socketio"},{"location":"websockets/socketio/#socket-io-python-socketio","text":"Ellar integration with python-socketio , a library that enables real-time, bidirectional and event-based communication between the browser and the server.","title":"Socket IO - python-socketio"},{"location":"websockets/socketio/#gateways","text":"A class annotated with WebSocketGateway decorator is like a controller that creates a compatibles with python-socketio, ellar and websocket. A gateway class also supports dependency injection and guards. from ellar.socket_io import WebSocketGateway @WebSocketGateway ( path = '/events-ws' , name = 'event-gateway' ) class EventGateway : pass","title":"Gateways"},{"location":"websockets/socketio/#installation","text":"To start building Socket.IO webSockets-based applications, first install the required package: $( venv ) pip install python-socketio","title":"Installation"},{"location":"websockets/socketio/#overview","text":"In general, each gateway is listening on the same port as the HTTP server and has a path /socket.io unless changed manually. This default behavior can be modified by passing an argument to the @WebSocketGateway(path='/event-ws') . You can also set a namespace used by the gateway as shown below: # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway @WebSocketGateway ( path = '/socket.io' , namespace = 'events' ) class EventGateway : pass Warning Gateways are not instantiated until they are referenced in the controllers array of an existing module. You can pass any supported option to the socket constructor with the second argument to the @WebSocketGateway() decorator, as shown below: # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway , GatewayBase @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): pass The gateway is now listening, but we have not yet subscribed to any incoming messages. Let's create a handler that will subscribe to the events messages and respond to the user with the exact same data. # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway , subscribe_message , GatewayBase from ellar.common import WsBody @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : str = WsBody ()): return data You can also define schema for the data receive, for example: # project_name/events/gateway.py from ellar.socket_io import WebSocketGateway , subscribe_message , GatewayBase from ellar.common import WsBody from pydantic import BaseModel class MessageBody ( BaseModel ): data : str @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return data . dict () Once the gateway is created, we can register it in our module. # project_name/events/module.py from ellar.common import Module from .gateway import EventGateway @Module ( controllers = [ EventGateway ]) class EventsModule : pass WebSocketGateway decorated class comes with a different context that providers extra information/access to server , sid and current message environment . from ellar.socket_io import GatewayBase from socketio import AsyncServer @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): assert isinstance ( self . context . server , AsyncServer ) assert isinstance ( self . context . sid , str ) assert isinstance ( self . context . environment , dict ) await self . context . server . emit ( 'my_custom_event' , data . dict (), room = None )","title":"Overview"},{"location":"websockets/socketio/#wsresponse","text":"You may return a WsResponse object and supply two properties. The event which is a name of the emitted event and the data that has to be forwarded to the client. from ellar.socket_io import GatewayBase from ellar.socket_io import WsResponse @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return WsResponse ( 'events' , data . dict ()) Hint The WsResponse class is imported from ellar.socketio package. And its has similar interface as AsyncServer().emit Warning If you return a response that is not a WsResponse object, ellar will assume handler as the event to emit the response. Or you can use self.context.server.emit to send the message back to the client. In order to listen for the incoming response(s), the client has to apply another event listener. socket . on ( 'events' , ( data ) => console . log ( data ));","title":"WsResponse"},{"location":"websockets/socketio/#gateway-connection-and-disconnection-handling","text":"on_connected and on_disconnected can be used to define on_connect and on_disconnect handler in your gateway controller. For example, from ellar.socket_io import GatewayBase , WebSocketGateway , subscribe_message , on_connected , on_disconnected from ellar.socket_io import WsResponse @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @on_connected () async def connect ( self ): await self . context . server . emit ( \"my_response\" , { \"data\" : \"Connected\" , \"count\" : 0 }, room = self . context . sid ) @on_disconnected () async def disconnect ( self ): print ( \"Client disconnected\" ) @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return WsResponse ( 'events' , data . dict ()) Info @on_connected and @on_disconnected() handlers doesn't take any argument because all its arguments are already available in the self.context","title":"Gateway Connection and Disconnection Handling"},{"location":"websockets/socketio/#exceptions","text":"All exceptions that happens on the server in a gateway controller after successful handshake between the server and client are sent to the client through error event. This is a standard practice when working socketio client. The client is required to subscribe to error event inorder to receive error message from the server. for example: from ellar.socket_io import GatewayBase , WebSocketGateway , subscribe_message from ellar.common.exceptions import WebSocketException from starlette import status @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): raise WebSocketException ( status . WS_1009_MESSAGE_TOO_BIG , reason = 'Message is too big' ) When client sends message to events , an exception will be raised. And the client will receive the error message if it subscribed to error events. For example: const socket = io . connect () socket . on ( 'error' , ( error ) => { console . error ( error ) })","title":"Exceptions"},{"location":"websockets/socketio/#guards","text":"There is no fundamental difference between web sockets guards and regular HTTP application guards. The only difference is that instead of throwing HttpException , you should use WebSocketException Hint WebSocketException is an exception class located in ellar.common.exceptions from ellar.common import Guards ... @Guards ( MyCustomGuards ) @subscribe_message ( 'events' ) async def handle_event ( self , data : MessageBody = WsBody ()): return WsResponse ( 'events' , data . dict ()) ... @Guards can be applied at handler level as shown in the last construct or at class level as shown below: ... @Guards ( MyGuard ) @WebSocketGateway ( path = '/socket.io' , transports = [ 'websocket' ]) class EventGateway ( GatewayBase ): @on_connected () async def connect ( self ): await self . context . server . emit ( \"my_response\" , { \"data\" : \"Connected\" , \"count\" : 0 }, room = self . context . sid ) ...","title":"Guards"},{"location":"websockets/socketio/#testing","text":"Gateway can be unit tested just like regular ellar controllers. But for integration testing, a separate testing module, TestGateway , is needed to set up a socketio client to simulation activity between server and client. Hint TestGateway class is located at ellar.socket_io.testing For example: @WebSocketGateway ( path = \"/ws\" , async_mode = \"asgi\" , cors_allowed_origins = \"*\" ) class EventGateway : @subscribe_message ( \"my_event\" ) async def my_event ( self , message : MessageData = WsBody ()): return WsResponse ( \"my_response\" , { \"data\" : message . data }, room = self . context . sid ) @subscribe_message async def my_broadcast_event ( self , message : MessageData = WsBody ()): await self . context . server . emit ( \"my_response\" , { \"data\" : message . data }) @on_connected () async def connect ( self ): await self . context . server . emit ( \"my_response\" , { \"data\" : \"Connected\" , \"count\" : 0 }, room = self . context . sid ) @on_disconnected () async def disconnect ( self ): print ( \"Client disconnected\" ) The above gateway construct integration testing can be done as shown below: import pytest from ellar.socket_io.testing import TestGateway @pytest . mark . asyncio class TestEventGateway : test_client = TestGateway . create_test_module ( controllers = [ EventGateway ]) async def test_socket_connection_work ( self ): my_response_message = [] connected_called = False disconnected_called = False async with self . test_client . run_with_server () as ctx : @ctx . sio . event async def my_response ( message ): my_response_message . append ( message ) @ctx . sio . event async def disconnect (): nonlocal disconnected_called disconnected_called = True @ctx . sio . event async def connect ( * args ): nonlocal connected_called await ctx . sio . emit ( \"my_event\" , { \"data\" : \"I'm connected!\" }) connected_called = True await ctx . connect ( socketio_path = \"/ws/\" ) await ctx . wait () assert len ( my_response_message ) == 2 assert my_response_message == [ { \"data\" : \"Connected\" , \"count\" : 0 }, { \"data\" : \"I'm connected!\" }, ] assert disconnected_called and connected_called async def test_broadcast_work ( self ): sio_1_response_message = [] sio_2_response_message = [] async with self . test_client . run_with_server () as ctx : ctx_2 = ctx . new_socket_client_context () @ctx . sio . event async def my_response ( message ): sio_1_response_message . append ( message ) @ctx_2 . sio . event async def my_response ( message ): sio_2_response_message . append ( message ) await ctx . connect ( socketio_path = \"/ws/\" ) await ctx_2 . connect ( socketio_path = \"/ws/\" ) await ctx . sio . emit ( \"my_broadcast_event\" , { \"data\" : \"Testing Broadcast\" } ) # both sio_1 and sio_2 would receive this message await ctx . wait () await ctx_2 . wait () assert len ( sio_1_response_message ) == 2 assert sio_1_response_message == [ { \"data\" : \"Connected\" , \"count\" : 0 }, { \"data\" : \"Testing Broadcast\" }, ] assert len ( sio_2_response_message ) == 2 assert sio_2_response_message == [ { \"data\" : \"Connected\" , \"count\" : 0 }, { \"data\" : \"Testing Broadcast\" }, ] self.test_client.run_with_server() setup a server and returns RunWithServerContext object. The RunWithServerContext contains a socket io client and created server url. And with the client( sio ) returned, you can subscribe to events and send messages as shown in the above construct. Warning It is important to have all the event subscription written before calling ctx.connect Also, it is possible to test with more than one client as you can see in test_broadcast_work in construct above. We created another instance of RunWithServerContext as ctx_2 from the already existing ctx with ctx.new_socket_client_context() . And both were used to test for message broadcast.","title":"Testing"},{"location":"websockets/socketio/#socketio-ellar-example","text":"python-socketio provided a sample project on how to integrate python-socketio with django . The sample project was converted to ellar gateway and it can find it here","title":"SocketIO Ellar Example"},{"location":"websockets/websockets/","text":"Websocket \u00b6 WebSocket is a powerful communication protocol that allows for two-way communication between a client and a server over a single, long-lived connection, making it an ideal tool for building real-time applications. Creating a WebSocket Route \u00b6 In Ellar, you create websocket route using ws_route decorator. # project_name/apps/car/controller.py from ellar.common import Controller , ControllerBase , ws_route @Controller ( '/car' ) class CarController ( ControllerBase ): @ws_route ( '/live-support' ) async def live_support ( self ): pass Let's go deep with a more practical example. First we need to create a html with some javascript scripts that will connect to our websocket. <!--project_name/apps/car/templates/ws-index.html ---> <!DOCTYPE html> < html > < head > < title > Ellar Chat Demo </ title > < link href = \"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css\" rel = \"stylesheet\" integrity = \"sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ\" crossorigin = \"anonymous\" > < script src = \"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js\" integrity = \"sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe\" crossorigin = \"anonymous\" ></ script > </ head > < body > < div class = \"container\" style = \"max-width: 40rem\" > < div class = \"mt-3 text-center\" > < h2 > Support Live Support </ h2 > </ div > < hr > < div class = \"row\" > < form action = \"\" onsubmit = \"sendMessage(event)\" > < textarea type = \"text\" class = \"form-control\" id = \"messageText\" rows = \"4\" ></ textarea > < button class = \"btn btn-primary mt-2\" > Send Message </ button > </ form > </ div > < hr > < ul id = 'messages' class = \"mx-auto list-unstyled\" > </ ul > </ div > < script > let ws = new WebSocket ( \"ws://localhost:8000/car/live-support\" ); ws . onmessage = function ( event ) { addMessage ( event . data ) }; function sendMessage ( event ) { let input = document . getElementById ( \"messageText\" ) addMessage ( input . value , true ) ws . send ( input . value ) input . value = '' event . preventDefault () } function addMessage ( data , inBound = false ) { let messages = document . getElementById ( 'messages' ) let container_message = document . createElement ( 'li' ) let message = document . createElement ( 'p' ) if ( inBound ) { container_message . classList . add ( 'd-flex' , 'justify-content-end' ) message . classList . add (...[ 'p-2' , 'rounded-2' , 'bg-danger-subtle' , 'my-1' ]) } else { container_message . classList . add ( 'd-flex' ) message . classList . add (...[ 'p-2' , 'rounded-2' , 'bg-primary-subtle' , 'my-1' ]) } message . innerHTML = data container_message . appendChild ( message ) messages . appendChild ( container_message ) } </ script > </ body > </ html > Next, we add some code to the live-feed websocket route we created initially to accept connection and send messages to the client once there is a successful handshake. @Controller ( '/car' ) class CarController ( ControllerBase ): @get ( '/ws-index' ) @render ( template_name = 'ws-index.html' ) async def ws_index ( self ): return {} @ws_route ( '/live-support' ) async def live_support ( self ): ws = self . context . switch_to_websocket () . get_client () await ws . accept () await ws . send_text ( 'Welcome to our live support room! \\n How can we help you?' ) while True : try : data = await ws . receive_text () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) except Exception as ex : assert ws . close () break In example, we added /ws-index , to fetch the html file that has some javascript websocket connection to /live-support websocket route. So, when we visit the route below http://127.0.0.1:8000/car/ws-index , you will have an interacting screen as shown below In above example, ws.receive_text() was used to receive messages sent from the websocket client. Also messages can be received in json( ws.receive_json() ), text( ws.receive_text() ) and in bytes( ws.receive_bytes() ) In the same other, messages can be sent back in the same forms; text( ws.send_text() ), json( ws.send_json() ) and bytes( ws.send_bytes() ) Guards on websockets \u00b6 Guards works exactly as described earlier for a normal HTTP request. In the case of websocket, Guards are only active when a client is about to connect to the server. After a successful handshake between the server and the client, the guards actions are no longer involved in server to client communication and vice versa. from ellar.di import injectable from ellar.common import Query , Guards , GuardCanActivate , IExecutionContext , ws_route ... @injectable class MyGuard ( GuardCanActivate ): async def can_activate ( self , context : IExecutionContext ) -> bool : print ( 'MyGuard was called.' ) return False ... @ws_route ( '/live-support' ) @Guards ( MyGuard ) async def live_support ( self , name : str = Query ( 'John' )): ws = self . context . switch_to_websocket () . get_client () await ws . accept () await ws . send_text ( f 'Welcome { name } to our live support room! \\n How can we help you?' ) while True : try : data = await ws . receive_text () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) except Exception as ex : assert ws . close () break In the construction above, we applied MyGuard to /live-suport route function. And for a connection to /live-suport to be successful, MyGuard can_activate must return True . Websocket handler Dependencies \u00b6 Websocket handler supports all route handler parameters except Body and Forms . Let's use a Query parameter on the /live-feed WebSocket route. from ellar.common import Query , ws_route ... @ws_route ( '/live-support' ) async def live_support ( self , name : str = Query ( 'John' )): ws = self . context . switch_to_websocket () . get_client () await ws . accept () await ws . send_text ( f 'Welcome { name } to our live support room! \\n How can we help you?' ) while True : try : data = await ws . receive_text () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) except Exception as ex : assert ws . close () break Now, when you visit this endpoint http://127.0.0.1:8000/car/ws-index again, you will see a name query parameter attached to the welcome message. Advance websocket usage \u00b6 The ws_route offers more than just defining a websocket route. It can also be used to define handlers for different sessions of a websocket route. By setting use_extra_handler=True in ws_route decorator, we activate an in-built handler that gives the ability to manage different sessions of websocket differently like on_connect , on_message and on_disconnect on_connect(websocket, **kwargs) : handles client connection with the server. on_message(websocket, data) : handles messages sent from the client on_disconnect(websocket, close_code) : handles server disconnecting from client Info This approach also enables message data type validation using WsBody . WsBody is similar to Body but for websockets. Let's rewrite the previous example, /live-support websocket route. # project_name/apps/car/controller.py from ellar.common import Controller , ControllerBase , ws_route , get , render , WsBody , Guards from starlette.websockets import WebSocket @Controller ( '/car' ) class CarController ( ControllerBase ): @get ( '/ws-index' ) @render ( template_name = 'ws-index.html' ) async def ws_index ( self ): return {} @ws_route ( '/live-support' , use_extra_handler = True , encoding = 'text' ) @Guards ( MyGuard ) async def live_support ( self , data : str = WsBody ()): ws = self . context . switch_to_websocket () . get_client () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) @ws_route . connect ( live_support ) async def live_support_connect ( self , websocket : WebSocket ): await websocket . accept () await websocket . send_text ( 'Welcome to our live support room! \\n How can we help you?' ) @ws_route . disconnect ( live_support ) async def live_support_disconnect ( self , websocket : WebSocket , code : int ): await websocket . close ( code ) In the construct above, we created def live_support_connect to handle connection to the '/live-support' websocket route and def live_support_disconnect to handle disconnection from it. def live_support_connect and def live_support_disconnect takes websocket instance as only parameter and must be an asynchronous function. On the other hand, def live_support function is now a message receiver handler and so, there is need to define a parameter with WsBody , in this case data:str = WsBody() . Message sent from client will be passed to data parameter after validation and procession by WsBody . If validation fails, an error will be sent to the client and connection will be destroyed. The encoding = 'text' states the message data structure that is required of the client when sending messages to the server. There are other encoding types supported: text : allows only simple text messages as in the case above, e.g. @ws_route('/path', use_extra_handler=True, encoding='text') json : allows json messages e.g. @ws_route('/path', use_extra_handler=True, encoding='json') bytes : allows byte messages e.g. @ws_route('/path', use_extra_handler=True, encoding='bytes') Simplifying the example above We can further simplify the example above by getting rid of the live_support_connect and live_support_disconnect and let the inbuilt handler apply the default connection and disconnection actions. # project_name/apps/car/controller.py from ellar.common import ControllerBase , Controller , ws_route , get , render , WsBody @Controller ( '/car' ) class CarController ( ControllerBase ): @get ( '/ws-index' ) @render ( template_name = 'ws-index.html' ) async def ws_index ( self ): return {} @ws_route ( '/live-support' , use_extra_handler = True , encoding = 'text' ) async def live_support ( self , data : str = WsBody ()): ws = self . context . switch_to_websocket () . get_client () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) Testing a Websocket Route \u00b6 You can use the same TestClient to test WebSockets. For this, you use the TestClient in a with statement, connecting to the WebSocket: # project_name/car/tests/test_controllers.py from project_name.apps.car.controllers import CarController from ellar.testing import Test , TestClient class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], config_module = dict ( REDIRECT_SLASHES = True ) ) self . client : TestClient = test_module . get_test_client () def test_live_support_works ( self ): with self . client . websocket_connect ( '/car/live-support' ) as websocket_client : data = websocket_client . receive_text () assert data == 'Welcome to our live support room! \\n How can we help you?' websocket_client . send_text ( 'Message from client' ) data = websocket_client . receive_text () assert data == 'We have received you complain:<br><br><strong>\"Message from client\"</strong><br><br>We shall get back to you.'","title":"websockets"},{"location":"websockets/websockets/#websocket","text":"WebSocket is a powerful communication protocol that allows for two-way communication between a client and a server over a single, long-lived connection, making it an ideal tool for building real-time applications.","title":"Websocket"},{"location":"websockets/websockets/#creating-a-websocket-route","text":"In Ellar, you create websocket route using ws_route decorator. # project_name/apps/car/controller.py from ellar.common import Controller , ControllerBase , ws_route @Controller ( '/car' ) class CarController ( ControllerBase ): @ws_route ( '/live-support' ) async def live_support ( self ): pass Let's go deep with a more practical example. First we need to create a html with some javascript scripts that will connect to our websocket. <!--project_name/apps/car/templates/ws-index.html ---> <!DOCTYPE html> < html > < head > < title > Ellar Chat Demo </ title > < link href = \"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css\" rel = \"stylesheet\" integrity = \"sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ\" crossorigin = \"anonymous\" > < script src = \"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js\" integrity = \"sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe\" crossorigin = \"anonymous\" ></ script > </ head > < body > < div class = \"container\" style = \"max-width: 40rem\" > < div class = \"mt-3 text-center\" > < h2 > Support Live Support </ h2 > </ div > < hr > < div class = \"row\" > < form action = \"\" onsubmit = \"sendMessage(event)\" > < textarea type = \"text\" class = \"form-control\" id = \"messageText\" rows = \"4\" ></ textarea > < button class = \"btn btn-primary mt-2\" > Send Message </ button > </ form > </ div > < hr > < ul id = 'messages' class = \"mx-auto list-unstyled\" > </ ul > </ div > < script > let ws = new WebSocket ( \"ws://localhost:8000/car/live-support\" ); ws . onmessage = function ( event ) { addMessage ( event . data ) }; function sendMessage ( event ) { let input = document . getElementById ( \"messageText\" ) addMessage ( input . value , true ) ws . send ( input . value ) input . value = '' event . preventDefault () } function addMessage ( data , inBound = false ) { let messages = document . getElementById ( 'messages' ) let container_message = document . createElement ( 'li' ) let message = document . createElement ( 'p' ) if ( inBound ) { container_message . classList . add ( 'd-flex' , 'justify-content-end' ) message . classList . add (...[ 'p-2' , 'rounded-2' , 'bg-danger-subtle' , 'my-1' ]) } else { container_message . classList . add ( 'd-flex' ) message . classList . add (...[ 'p-2' , 'rounded-2' , 'bg-primary-subtle' , 'my-1' ]) } message . innerHTML = data container_message . appendChild ( message ) messages . appendChild ( container_message ) } </ script > </ body > </ html > Next, we add some code to the live-feed websocket route we created initially to accept connection and send messages to the client once there is a successful handshake. @Controller ( '/car' ) class CarController ( ControllerBase ): @get ( '/ws-index' ) @render ( template_name = 'ws-index.html' ) async def ws_index ( self ): return {} @ws_route ( '/live-support' ) async def live_support ( self ): ws = self . context . switch_to_websocket () . get_client () await ws . accept () await ws . send_text ( 'Welcome to our live support room! \\n How can we help you?' ) while True : try : data = await ws . receive_text () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) except Exception as ex : assert ws . close () break In example, we added /ws-index , to fetch the html file that has some javascript websocket connection to /live-support websocket route. So, when we visit the route below http://127.0.0.1:8000/car/ws-index , you will have an interacting screen as shown below In above example, ws.receive_text() was used to receive messages sent from the websocket client. Also messages can be received in json( ws.receive_json() ), text( ws.receive_text() ) and in bytes( ws.receive_bytes() ) In the same other, messages can be sent back in the same forms; text( ws.send_text() ), json( ws.send_json() ) and bytes( ws.send_bytes() )","title":"Creating a WebSocket Route"},{"location":"websockets/websockets/#guards-on-websockets","text":"Guards works exactly as described earlier for a normal HTTP request. In the case of websocket, Guards are only active when a client is about to connect to the server. After a successful handshake between the server and the client, the guards actions are no longer involved in server to client communication and vice versa. from ellar.di import injectable from ellar.common import Query , Guards , GuardCanActivate , IExecutionContext , ws_route ... @injectable class MyGuard ( GuardCanActivate ): async def can_activate ( self , context : IExecutionContext ) -> bool : print ( 'MyGuard was called.' ) return False ... @ws_route ( '/live-support' ) @Guards ( MyGuard ) async def live_support ( self , name : str = Query ( 'John' )): ws = self . context . switch_to_websocket () . get_client () await ws . accept () await ws . send_text ( f 'Welcome { name } to our live support room! \\n How can we help you?' ) while True : try : data = await ws . receive_text () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) except Exception as ex : assert ws . close () break In the construction above, we applied MyGuard to /live-suport route function. And for a connection to /live-suport to be successful, MyGuard can_activate must return True .","title":"Guards on websockets"},{"location":"websockets/websockets/#websocket-handler-dependencies","text":"Websocket handler supports all route handler parameters except Body and Forms . Let's use a Query parameter on the /live-feed WebSocket route. from ellar.common import Query , ws_route ... @ws_route ( '/live-support' ) async def live_support ( self , name : str = Query ( 'John' )): ws = self . context . switch_to_websocket () . get_client () await ws . accept () await ws . send_text ( f 'Welcome { name } to our live support room! \\n How can we help you?' ) while True : try : data = await ws . receive_text () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) except Exception as ex : assert ws . close () break Now, when you visit this endpoint http://127.0.0.1:8000/car/ws-index again, you will see a name query parameter attached to the welcome message.","title":"Websocket handler Dependencies"},{"location":"websockets/websockets/#advance-websocket-usage","text":"The ws_route offers more than just defining a websocket route. It can also be used to define handlers for different sessions of a websocket route. By setting use_extra_handler=True in ws_route decorator, we activate an in-built handler that gives the ability to manage different sessions of websocket differently like on_connect , on_message and on_disconnect on_connect(websocket, **kwargs) : handles client connection with the server. on_message(websocket, data) : handles messages sent from the client on_disconnect(websocket, close_code) : handles server disconnecting from client Info This approach also enables message data type validation using WsBody . WsBody is similar to Body but for websockets. Let's rewrite the previous example, /live-support websocket route. # project_name/apps/car/controller.py from ellar.common import Controller , ControllerBase , ws_route , get , render , WsBody , Guards from starlette.websockets import WebSocket @Controller ( '/car' ) class CarController ( ControllerBase ): @get ( '/ws-index' ) @render ( template_name = 'ws-index.html' ) async def ws_index ( self ): return {} @ws_route ( '/live-support' , use_extra_handler = True , encoding = 'text' ) @Guards ( MyGuard ) async def live_support ( self , data : str = WsBody ()): ws = self . context . switch_to_websocket () . get_client () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' ) @ws_route . connect ( live_support ) async def live_support_connect ( self , websocket : WebSocket ): await websocket . accept () await websocket . send_text ( 'Welcome to our live support room! \\n How can we help you?' ) @ws_route . disconnect ( live_support ) async def live_support_disconnect ( self , websocket : WebSocket , code : int ): await websocket . close ( code ) In the construct above, we created def live_support_connect to handle connection to the '/live-support' websocket route and def live_support_disconnect to handle disconnection from it. def live_support_connect and def live_support_disconnect takes websocket instance as only parameter and must be an asynchronous function. On the other hand, def live_support function is now a message receiver handler and so, there is need to define a parameter with WsBody , in this case data:str = WsBody() . Message sent from client will be passed to data parameter after validation and procession by WsBody . If validation fails, an error will be sent to the client and connection will be destroyed. The encoding = 'text' states the message data structure that is required of the client when sending messages to the server. There are other encoding types supported: text : allows only simple text messages as in the case above, e.g. @ws_route('/path', use_extra_handler=True, encoding='text') json : allows json messages e.g. @ws_route('/path', use_extra_handler=True, encoding='json') bytes : allows byte messages e.g. @ws_route('/path', use_extra_handler=True, encoding='bytes') Simplifying the example above We can further simplify the example above by getting rid of the live_support_connect and live_support_disconnect and let the inbuilt handler apply the default connection and disconnection actions. # project_name/apps/car/controller.py from ellar.common import ControllerBase , Controller , ws_route , get , render , WsBody @Controller ( '/car' ) class CarController ( ControllerBase ): @get ( '/ws-index' ) @render ( template_name = 'ws-index.html' ) async def ws_index ( self ): return {} @ws_route ( '/live-support' , use_extra_handler = True , encoding = 'text' ) async def live_support ( self , data : str = WsBody ()): ws = self . context . switch_to_websocket () . get_client () await ws . send_text ( f 'We have received you complain:<br><br><strong>\" { data } \"</strong><br><br>We shall get back to you.' )","title":"Advance websocket usage"},{"location":"websockets/websockets/#testing-a-websocket-route","text":"You can use the same TestClient to test WebSockets. For this, you use the TestClient in a with statement, connecting to the WebSocket: # project_name/car/tests/test_controllers.py from project_name.apps.car.controllers import CarController from ellar.testing import Test , TestClient class TestCarController : def setup ( self ): test_module = Test . create_test_module ( controllers = [ CarController ,], config_module = dict ( REDIRECT_SLASHES = True ) ) self . client : TestClient = test_module . get_test_client () def test_live_support_works ( self ): with self . client . websocket_connect ( '/car/live-support' ) as websocket_client : data = websocket_client . receive_text () assert data == 'Welcome to our live support room! \\n How can we help you?' websocket_client . send_text ( 'Message from client' ) data = websocket_client . receive_text () assert data == 'We have received you complain:<br><br><strong>\"Message from client\"</strong><br><br>We shall get back to you.'","title":"Testing a Websocket Route"}]}