import math
import secrets
import typing as t
from abc import ABC, abstractmethod

from ellar.common import Serializer
from passlib.context import CryptContext

from .constants import (
    RANDOM_STRING_CHARS,
    UNUSABLE_PASSWORD_PREFIX,
    UNUSABLE_PASSWORD_SUFFIX_LENGTH,
)


def is_password_usable(encoded: t.Optional[str]) -> bool:
    """
    Return True if this password wasn't generated by
    User.set_unusable_password(), i.e. make_password(None).
    """
    return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)


def get_random_string(length: int, allowed_chars: str = RANDOM_STRING_CHARS) -> str:
    """
    Return a securely generated random string.

    The bit length of the returned value can be calculated with the formula:
        log_2(len(allowed_chars)^length)

    For example, with default `allowed_chars` (26+26+10), this gives:
      * length: 12, bit length =~ 71 bits
      * length: 22, bit length =~ 131 bits
    """
    return "".join(
        secrets.choice(allowed_chars) for _ in range(length)
    )  # pragma no cover


class PasswordHasherDecodeData(Serializer):
    algorithm: str
    hash: t.Any
    iterations: int
    salt: str


class BasePasswordHasher(ABC):
    hash_scheme: str
    algorithm: str
    salt_entropy: int = 128

    def __init__(self, **kwargs: t.Any) -> None:
        if hasattr(self, "hash_scheme") is None or hasattr(self, "algorithm") is None:
            raise NotImplementedError(
                "subclasses of BasePasswordHasher must provide an algorithm and hash scheme."
            )
        self.hasher = CryptContext(schemes=[self.hash_scheme], deprecated="auto")

    def encode(self, password: str) -> t.Union[str, t.Any]:
        return self.hasher.hash(password, scheme=self.hash_scheme)

    @abstractmethod
    def decode(self, encoded: str) -> PasswordHasherDecodeData:
        """
        Return a decoded database value.

        The result is a dictionary and should contain `algorithm`, `hash`, and
        `salt`. Extra keys can be algorithm specific like `iterations` or
        `work_factor`.
        """
        pass

    def verify(self, secret: str, hash_secret: t.Union[str, bytes]) -> bool:
        """
        verify secret against an existing hash
        """
        return self.hasher.verify(  # type:ignore[no-any-return]
            secret, hash_secret, scheme=self.hash_scheme
        )

    def must_update(self, encoded: str) -> bool:
        return False

    def _must_update_salt(self, salt: str) -> bool:
        # Each character in the salt provides log_2(len(alphabet)) bits of entropy.
        return len(salt) * math.log2(len(RANDOM_STRING_CHARS)) < self.salt_entropy

    def make_password(self, password: t.Optional[str]) -> str:
        """
        Turn a plain-text password into a hash for database storage

        Same as encode() but generate a new random salt. If password is None then
        return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
        which disallows logins. Additional random string reduces chances of gaining
        access to staff or superuser accounts. See ticket #20079 for more info.
        """
        if password is None:
            return UNUSABLE_PASSWORD_PREFIX + get_random_string(
                UNUSABLE_PASSWORD_SUFFIX_LENGTH
            )
        if not isinstance(password, (bytes, str)):
            raise TypeError(
                "Password must be a string or bytes, got %s."
                % type(password).__qualname__
            )

        # Passlib includes salt in almost every hash
        return self.encode(password)

    def check_password(
        self,
        password: str,
        encoded: str,
        setter: t.Optional[t.Callable[..., t.Any]] = None,
        preferred_hasher: t.Optional["BasePasswordHasher"] = None,
    ) -> bool:
        """
        Return a boolean of whether the raw password matches the three
        part encoded digest.

        If setter is specified, it'll be called when you need to
        regenerate the password.
        """
        if password is None or not is_password_usable(encoded):
            return False

        if preferred_hasher is None:
            preferred_hasher = self

        hasher_changed = self.algorithm != preferred_hasher.algorithm
        must_update: bool = hasher_changed or preferred_hasher.must_update(encoded)
        is_correct: bool = self.verify(password, encoded)

        if setter and is_correct and must_update:
            setter(password)
        return is_correct


class PBKDF2PasswordHasher(BasePasswordHasher):
    """
    Handles PBKDF2 passwords
    """

    hash_scheme: str = "django_pbkdf2_sha256"
    algorithm: str = "pbkdf2_sha256"
    iterations: int = 390000

    def decode(self, encoded: str) -> PasswordHasherDecodeData:
        algorithm, iterations, salt, _hash = encoded.split("$", 3)
        assert algorithm == self.algorithm
        return PasswordHasherDecodeData(
            **{  # type: ignore[arg-type]
                "algorithm": algorithm,
                "hash": _hash,
                "iterations": int(iterations),
                "salt": salt,
            }
        )

    def must_update(self, encoded: str) -> bool:
        decoded = self.decode(encoded)
        update_salt = self._must_update_salt(decoded.salt)
        return (decoded.iterations != self.iterations) or update_salt


class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):
    """
    Alternate PBKDF2 hasher which uses SHA1, the default PRF
    recommended by PKCS #5. This is compatible with other
    implementations of PBKDF2, such as openssl's
    PKCS5_PBKDF2_HMAC_SHA1().
    """

    hash_scheme: str = "django_pbkdf2_sha1"
    algorithm: str = "pbkdf2_sha1"
